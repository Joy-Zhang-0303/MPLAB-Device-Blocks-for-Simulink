
%include "MCHP_UART_Tx_SAMx5_FunUtils.tlc"
%function MCHP_UART_Tx_Interrupt(block,system) Output
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%assign UART_NAME = UART_Tx_get_UART_NAME(block)
%assign UARTString = CAST("Number",block.RTWdata.UARTString)	
%assign NSend_Input = CAST("Number",block.RTWdata.NSend_Input)
%assign NSend_Output = CAST("Number",block.RTWdata.NSend_Output)
%assign TX_IMPLEMENTATION = MchpVector(RTWGenSettings.UART_TX_IMPLEMENTATION)
%assign TX_IMPLEMENTATION = TX_IMPLEMENTATION[UARTRef-1]		
%assign BlockInputLength = LibBlockInputSignalWidth(NSend_Input==1)		
%if BlockInputLength == 1
%assign UARTString = 0	
%endif
%assign UART_HALF_DUPLEX_MODE = MchpVector(RTWGenSettings.UART_HALF_DUPLEX_MODE)
%assign UART_HALF_DUPLEX_MODE = UART_HALF_DUPLEX_MODE[UARTRef-1]
%assign AllOrNothing = CAST("Number",block.RTWdata.AllOrNothing)
%if (NSend_Input == 1)
%assign N_in = LibBlockInputSignal(0,"","",0)
%assign idxInputChars = 1
%else
%assign N_in = BlockInputLength
%assign idxInputChars = 0
%endif
%assign TxBufferPtrType = CAST( "String","uint_T")	
{
%<TxBufferPtrType> Tmp;
%if NSend_Output
%<TxBufferPtrType> N_Out;
%endif	
Tmp = ~(MCHP_%<UART_NAME>_Tx.tail - MCHP_%<UART_NAME>_Tx.head);		/* head - tail - 1 */
Tmp = Tmp & (Tx_BUFF_SIZE_%<UART_NAME> - 1);							/* Modulo Buffer Size (Buffer Size is 2^n). Tmp is the buffer free space */
%if BlockInputLength > 1
{					
uint_T i1 = 0;
uint_T LocalTail = MCHP_%<UART_NAME>_Tx.tail;	/* Tail is a volatile variable. Use local variable to speed-up execution */						
%assign u0 = LibBlockInputSignalAddr( idxInputChars, "","", 0)
const uint8_T *u0 = %<u0> ;
%assign u = "u0[i1]"					
if (Tmp >= %<N_in>)		/* Does buffer can contains all char to be sent ? */
{						
Tmp = %<N_in> ;		/* If so, set tmp to the number of char to be sent */		
%if AllOrNothing == 0		
}				/* Otherwise, send only the number of char which can be contained within the buffer (Tmp) */
%endif
while (i1 < Tmp) {
%if UARTString
if (%<u> == 0) break; /* Stop on first 0 */
%endif
MCHP_%<UART_NAME>_Tx.buffer[LocalTail] = %<u>;						
LocalTail = (LocalTail + 1) & (Tx_BUFF_SIZE_%<UART_NAME> - 1);	
i1= i1 + 1;
}
%if UART_HALF_DUPLEX_MODE
%endif
if (MCHP_%<UART_NAME>_Tx.tail != LocalTail)
{
MCHP_%<UART_NAME>_Tx.tail = LocalTail; /* Push back volatile variable */
%<UART_Tx_FlushCirculerBuffer(UART_HALF_DUPLEX_MODE,block)>
}
%if AllOrNothing						
} /* enf of if (Tmp >= %<N_in>) => option send all or nothing */
%endif
%if NSend_Output
%assign Port_NOut = LibBlockOutputSignal(0, "","", 0)
%<Port_NOut> = i1;		
%endif	
}				
%else
%assign u = LibBlockInputSignal( idxInputChars, "", "", 0)
%if UARTString
if (%<u> != 0)  /* Stop on first 0 */							
%endif
{
uint_T LocalTail = MCHP_%<UART_NAME>_Tx.tail;	/* Tail is a volatile variable. Use local variable to speed-up execution */
MCHP_%<UART_NAME>_Tx.buffer[LocalTail] = %<u>;
MCHP_%<UART_NAME>_Tx.tail = (LocalTail + 1) & (Tx_BUFF_SIZE_%<UART_NAME> - 1);		
%<UART_Tx_FlushCirculerBuffer(UART_HALF_DUPLEX_MODE,block)>
%if NSend_Output
%<Port_NOut> = 1;
%endif
}
%if UARTString							
%if NSend_Output
else %<Port_NOut> = 0;
%endif
%endif
%endif
}
%endfunction