%include "MCHP_Functions.tlc"
%function MchpStartup(ConfigChipOnly) void
%openfile tmpFcnOsc
%assign MIPS = CAST("Real",RTWGenSettings.MIPS)    
%assign MIPS_DESIRED = CAST("Real",RTWGenSettings.MIPS_DESIRED)    
%assign QUARTZ = CAST("Real",RTWGenSettings.QUARTZ)
%assign MCLK_CPUDIV = CAST("Number",RTWGenSettings.MCLK_CPUDIV) 
%assign CPU_SRC = CAST("Number",RTWGenSettings.CPU_SRC) 
%assign VDD_RANGE = CAST("Real",RTWGenSettings.VDD_RANGE) 
%assign SYSCTRL_CONFIG = CAST("Number",RTWGenSettings.SYSCTRL_CONFIG) 
%assign SYSCTRL_CALIB_ENABLE = CAST("Number",RTWGenSettings.SYSCTRL_CALIB_ENABLE) 
%assign SYSCTRL_CALIB = CAST("Number",RTWGenSettings.SYSCTRL_CALIB) 
/* WAIT STATES (start with 0 WS) */
%if VDD_RANGE < 2.7
%if %<MIPS> <= 14000000	
NVMCTRL_REGS->NVMCTRL_CTRLB |= NVMCTRL_CTRLB_RWS(0); 	/* No Wait State required below 14Mhz (VDD < 2.7) */
%elseif %<MIPS> <= 28000000	
NVMCTRL_REGS->NVMCTRL_CTRLB |= NVMCTRL_CTRLB_RWS(1);	/* 1 Wait State above 14MHz (VDD < 2.7) */
%elseif %<MIPS> <= 42000000		
NVMCTRL_REGS->NVMCTRL_CTRLB |= NVMCTRL_CTRLB_RWS(2);	/* 2 Wait State above 28MHz (VDD < 2.7) */	
%else
NVMCTRL_REGS->NVMCTRL_CTRLB |= NVMCTRL_CTRLB_RWS(3);	/* 3 Wait State above 42MHz (VDD < 2.7) */	
%endif
%else 
%if %<MIPS> <= 24000000	
NVMCTRL_REGS->NVMCTRL_CTRLB |= NVMCTRL_CTRLB_RWS(0); 	/* No Wait State required below 24MHz (VDD > 2.7V)*/
%else
NVMCTRL_REGS->NVMCTRL_CTRLB |= NVMCTRL_CTRLB_RWS(2);	/* 1 Wait State above 24MHz (VDD > 2.7V)*/		
%endif
%endif
/* ------------- Configure Oscillator -------------------------- */
%if MIPS != MIPS_DESIRED
/* Targetted frequency is %<MIPS_DESIRED>. Reached frequency is %<MIPS>. */
%else
/* Targetted frequency is %<MIPS_DESIRED> */
%endif
PM_REGS->PM_CPUSEL = PM_CPUSEL_CPUDIV_DIV%<MCLK_CPUDIV>; /* CPU Clock is %<MIPS / MCLK_CPUDIV> : %<MIPS> / %<MCLK_CPUDIV> */
{
uint_T tmp_REG; /* Temp Configuration register */
%assign SYSCTRL_DFLLCTRL_CONFIG = CAST("Number", RTWGenSettings.SYSCTRL_DFLLCTRL_CONFIG)	   
%assign SYSCTRL_DFLLCTRL_ENABLE = CAST("Number", RTWGenSettings.SYSCTRL_DFLLCTRL_ENABLE)	   
%assign SYSCTRL_DFLLCTRL_RUNSTDBY = CAST("Number", RTWGenSettings.SYSCTRL_DFLLCTRL_RUNSTDBY)	   
%assign SYSCTRL_DFLLCTRL_ONDEMAND = CAST("Number", RTWGenSettings.SYSCTRL_DFLLCTRL_ONDEMAND)	   
%assign SYSCTRL_DFLLCTRL_MODE = CAST("Number", RTWGenSettings.SYSCTRL_DFLLCTRL_MODE)	  
%if SYSCTRL_DFLLCTRL_CONFIG
/* DFLL48Mhz in open loop (internal 48Mhz Oscillator) */
tmp_REG = SYSCTRL_DFLLCTRL_ENABLE_Msk; /* Enable DFLL48M */
%if SYSCTRL_DFLLCTRL_RUNSTDBY
tmp_REG |= SYSCTRL_DFLLCTRL_RUNSTDBY_Msk; 	/* Run in Standby Position */
%endif
%if SYSCTRL_DFLLCTRL_ONDEMAND
tmp_REG |= SYSCTRL_DFLLCTRL_ONDEMAND_Msk; 	/* On Demand Control Position */
%endif
%if SYSCTRL_DFLLCTRL_MODE
tmp_REG |= SYSCTRL_DFLLCTRL_MODE_Msk; 	/* Close loop mode */
%endif
SYSCTRL_REGS->SYSCTRL_DFLLCTRL = tmp_REG;
while ((SYSCTRL_REGS->SYSCTRL_PCLKSR & SYSCTRL_PCLKSR_DFLLRDY_Msk) != SYSCTRL_PCLKSR_DFLLRDY_Msk);  /* Wait for DFLLRDY ready bit */	
%if SYSCTRL_DFLLCTRL_MODE == 0
/* Open Loop mode: Coarse calibration from factory is required */
const uint32_T * NVM_FACTORY_CAL_Ptr = (uint32_T *) 0x806020;/* NVM Software Calibration Area Mapping (@ 0x806020) */
tmp_REG = NVM_FACTORY_CAL_Ptr[1] >> 26U ;   /* Factory COARSE calibration value */
SYSCTRL_REGS->SYSCTRL_DFLLVAL = SYSCTRL_DFLLVAL_COARSE(tmp_REG) + SYSCTRL_DFLLVAL_FINE(0x1FF);/*  OSC48M factory Calibration with fine set to middle  */
%endif
%endif
%assign SYSCTRL_OSC8M_CONFIG = CAST("Number",RTWGenSettings.SYSCTRL_OSC8M_CONFIG)		
%assign SYSCTRL_OSC8M_PRESC = CAST("Number",RTWGenSettings.SYSCTRL_OSC8M_PRESC)		
%assign SYSCTRL_OSC8M_ENABLE = CAST("Number",RTWGenSettings.SYSCTRL_OSC8M_ENABLE)		
%assign SYSCTRL_OSC8M_ONDEMAND = CAST("Number",RTWGenSettings.SYSCTRL_OSC8M_ONDEMAND)		
%assign SYSCTRL_OSC8M_RUNSTDBY = CAST("Number",RTWGenSettings.SYSCTRL_OSC8M_RUNSTDBY)		
%if SYSCTRL_OSC8M_CONFIG
/* 8Mhz Internal Oscillator (OSC8M) (default osc at startup) */
tmp_REG = SYSCTRL_REGS->SYSCTRL_OSC8M; /* Grab Factory Calibration initialized at startup */
tmp_REG &= SYSCTRL_OSC8M_FRANGE_Msk | SYSCTRL_OSC8M_CALIB_Msk;	/* Keep only FRANGE and CALIB */
tmp_REG |= SYSCTRL_OSC8M_ENABLE_Msk;
tmp_REG |= SYSCTRL_OSC8M_PRESC_%<SYSCTRL_OSC8M_PRESC>;	/* Prescaler for %< 8 \>\> SYSCTRL_OSC8M_PRESC> MHz */
%if SYSCTRL_OSC8M_ONDEMAND
tmp_REG |= SYSCTRL_OSC8M_ONDEMAND_Msk;
%endif
%if SYSCTRL_OSC8M_RUNSTDBY
tmp_REG |= SYSCTRL_OSC8M_RUNSTDBY_Msk;
%endif
SYSCTRL_REGS->SYSCTRL_OSC8M = tmp_REG; /* Write back OSC8M Config */
%endif
%assign SYSCTRL_CONFIG = CAST("Number",RTWGenSettings.SYSCTRL_CONFIG)
%if SYSCTRL_CONFIG
/* 32.768kHz Ultra Low Power Oscillator is always ON */
%endif
%assign SYSCTRL_OSC32K_CONFIG = CAST("Number",RTWGenSettings.SYSCTRL_OSC32K_CONFIG) 	
%assign SYSCTRL_OSC32K_ENABLE = CAST("Number",RTWGenSettings.SYSCTRL_OSC32K_ENABLE) 	
%assign SYSCTRL_OSC32K_EN32K = CAST("Number",RTWGenSettings.SYSCTRL_OSC32K_EN32K) 	
%assign SYSCTRL_OSC32K_EN1K = CAST("Number",RTWGenSettings.SYSCTRL_OSC32K_EN1K) 	
%assign SYSCTRL_OSC32K_RUNSTDBY = CAST("Number",RTWGenSettings.SYSCTRL_OSC32K_RUNSTDBY) 	
%assign SYSCTRL_OSC32K_ONDEMAND = CAST("Number",RTWGenSettings.SYSCTRL_OSC32K_ONDEMAND) 	
%assign SYSCTRL_OSC32K_WRTLOCK = CAST("Number",RTWGenSettings.SYSCTRL_OSC32K_WRTLOCK) 	
%assign SYSCTRL_OSC32K_STARTUP_CYCLEx = CAST("Number",RTWGenSettings.SYSCTRL_OSC32K_STARTUP_CYCLEx) 	
%if SYSCTRL_OSC32K_CONFIG == 1
/* Configure OSC32K Oscillator */
const uint32_T * NVM_FACTORY_CAL_Ptr = (uint32_T *) 0x806020; /* NVM Software Calibration Area Mapping (@ 0x806020) */	
tmp_REG = SYSCTRL_OSC32K_ENABLE_Msk;	/* Oscillator Enable Mask */	
%if SYSCTRL_OSC32K_EN32K == 1
tmp_REG |= SYSCTRL_OSC32K_EN32K_Msk;	/* 32kHz Output Enable Mask */
%endif	
%if SYSCTRL_OSC32K_EN1K == 1
tmp_REG |= SYSCTRL_OSC32K_EN1K_Msk;	/* 1kHz Output Enable Mask */
%endif	
%if SYSCTRL_OSC32K_RUNSTDBY == 1
tmp_REG |= SYSCTRL_OSC32K_RUNSTDBY_Msk;	/*  Run in Standby Mask */
%endif	
%if SYSCTRL_OSC32K_ONDEMAND == 1
tmp_REG |= SYSCTRL_OSC32K_ONDEMAND_Msk;	/* On Demand Control Mask */
%endif	
%if SYSCTRL_OSC32K_WRTLOCK == 1
tmp_REG |= SYSCTRL_OSC32K_WRTLOCK_Msk;	/* Write Lock Mask */
%endif			
tmp_REG |= SYSCTRL_OSC32K_STARTUP_CYCLE%<SYSCTRL_OSC32K_STARTUP_CYCLEx>;	/* startup cycle, multiple of 30us */
tmp_REG |= SYSCTRL_OSC32K_CALIB(( NVM_FACTORY_CAL_Ptr[1] >> 6U) & 0x7F); /*  OSC32K CAL factory Calibration  */
SYSCTRL_REGS->SYSCTRL_OSC32K = tmp_REG; /* WRITE OSC32K Oscillator configuration  */
while ((SYSCTRL_REGS->SYSCTRL_PCLKSR & SYSCTRL_PCLKSR_OSC32KRDY_Msk) != SYSCTRL_PCLKSR_OSC32KRDY_Msk);  /* Wait for OSC32K ready bit */	
%endif
%assign SYSCTRL_XOSC32K_CONFIG = CAST("Number",RTWGenSettings.SYSCTRL_XOSC32K_CONFIG) 	
%assign SYSCTRL_XOSC32K_ENABLE = CAST("Number",RTWGenSettings.SYSCTRL_XOSC32K_ENABLE) 	
%assign SYSCTRL_XOSC32K_STARTUP = CAST("Number",RTWGenSettings.SYSCTRL_XOSC32K_STARTUP) 	
%assign SYSCTRL_XOSC32K_ONDEMAND = CAST("Number",RTWGenSettings.SYSCTRL_XOSC32K_ONDEMAND) 	
%assign SYSCTRL_XOSC32K_RUNSTDBY = CAST("Number",RTWGenSettings.SYSCTRL_XOSC32K_RUNSTDBY) 	
%assign SYSCTRL_XOSC32K_EN1K = CAST("Number",RTWGenSettings.SYSCTRL_XOSC32K_EN1K) 	
%assign SYSCTRL_XOSC32K_EN32K = CAST("Number",RTWGenSettings.SYSCTRL_XOSC32K_EN32K) 	
%assign SYSCTRL_XOSC32K_XTALEN = CAST("Number",RTWGenSettings.SYSCTRL_XOSC32K_XTALEN) 	
%if SYSCTRL_XOSC32K_CONFIG == 1
/* Configure XOSC32K External Oscillator */
%if SYSCTRL_XOSC32K_XTALEN
/* ---- Configure XOSC32K Crystal Oscillator source (32 Khz) on XIN32-XOUT32---- */
%else
/* ---- Configure XOSC32K Clock source (32 Khz) on XIN32 ---- */
%endif
tmp_REG = SYSCTRL_OSC32K_ENABLE_Msk;  /*   Enable XOSC32K */
tmp_REG |= SYSCTRL_XOSC32K_STARTUP(%<SYSCTRL_XOSC32K_STARTUP>);  /*  [122 1068 62592 125092 500092 1000092 2000092 4000092] us for values 0-7*/
%if SYSCTRL_XOSC32K_ONDEMAND == 1
tmp_REG |= SYSCTRL_XOSC32K_ONDEMAND_Msk;
%endif
%if SYSCTRL_XOSC32K_RUNSTDBY == 1
tmp_REG |= SYSCTRL_XOSC32K_RUNSTDBY_Msk;
%endif
%if SYSCTRL_XOSC32K_EN1K == 1
tmp_REG |= SYSCTRL_XOSC32K_EN1K_Msk;  /* 1kHz Output Enable Mask*/
%endif
%if SYSCTRL_XOSC32K_EN32K == 1
tmp_REG |= SYSCTRL_XOSC32K_EN32K_Msk;  /* 32kHz Output Enable Mask*/
%endif
%if SYSCTRL_XOSC32K_XTALEN == 1
tmp_REG |= SYSCTRL_XOSC32K_XTALEN_Msk;  /* Use External crystal oscillator */
tmp_REG |= SYSCTRL_XOSC32K_AAMPEN_Msk;  /* Automatic Amplitude Control */
%endif
SYSCTRL_REGS->SYSCTRL_XOSC32K = tmp_REG;
while ((SYSCTRL_REGS->SYSCTRL_PCLKSR & SYSCTRL_PCLKSR_XOSC32KRDY_Msk) != SYSCTRL_PCLKSR_XOSC32KRDY_Msk);  /* Wait for XOSC32K ready bit */
%endif
%assign SYSCTRL_XOSC_CONFIG = CAST("Number",RTWGenSettings.SYSCTRL_XOSC_CONFIG)			
%assign SYSCTRL_XOSC_FREQUENCY = CAST("Real",RTWGenSettings.SYSCTRL_XOSC_FREQUENCY)			
%assign SYSCTRL_XOSC_ENABLE = CAST("Number",RTWGenSettings.SYSCTRL_XOSC_ENABLE)			
%assign SYSCTRL_XOSC_STARTUP = CAST("Number",RTWGenSettings.SYSCTRL_XOSC_STARTUP)			
%assign SYSCTRL_XOSC_AMPGC = CAST("Number",RTWGenSettings.SYSCTRL_XOSC_AMPGC)			
%assign SYSCTRL_XOSC_GAIN = CAST("Number",RTWGenSettings.SYSCTRL_XOSC_GAIN)			
%assign SYSCTRL_XOSC_ONDEMAND = CAST("Number",RTWGenSettings.SYSCTRL_XOSC_ONDEMAND)			
%assign SYSCTRL_XOSC_RUNSTDBY = CAST("Number",RTWGenSettings.SYSCTRL_XOSC_RUNSTDBY)			
%assign SYSCTRL_XOSC_XTALEN = CAST("Number",RTWGenSettings.SYSCTRL_XOSC_XTALEN)			
%if SYSCTRL_XOSC_CONFIG == 1
%if SYSCTRL_XOSC_XTALEN
/* ---- Configure XOSC Crystal Oscillator source (%<SYSCTRL_XOSC_FREQUENCY>Hz) on XIN XOUT---- */
%else
/* ---- Configure XOSCL Clock source (%<SYSCTRL_XOSC_FREQUENCY>Hz) on XIN ---- */
%endif
tmp_REG = SYSCTRL_XOSC_ENABLE_Msk;		/*   OSC0 external oscilator enabled */
%if SYSCTRL_XOSC_STARTUP == 1
tmp_REG |= SYSCTRL_XOSC_STARTUP_Msk;	/*   [31us, 61, 122 ... 1s] from 0 to 16 */	
%endif
%if SYSCTRL_XOSC_AMPGC == 1
tmp_REG |= SYSCTRL_XOSC_AMPGC_Msk;		/*   Automatic loop control */
%endif
%if SYSCTRL_XOSC_GAIN == 1
tmp_REG |= SYSCTRL_XOSC_GAIN_Msk;		/*   [0-5] for [2 4 8 16 30] MHz Position */
%endif
%if SYSCTRL_XOSC_ONDEMAND == 1
tmp_REG |= SYSCTRL_XOSC_ONDEMAND_Msk;		/*   on demand  enabled */
%endif
%if SYSCTRL_XOSC_RUNSTDBY == 1
tmp_REG |= SYSCTRL_XOSC_RUNSTDBY_Msk;		/*   run in standby mode */
%endif
%if SYSCTRL_XOSC_XTALEN == 1
tmp_REG |= SYSCTRL_XOSC_XTALEN_Msk;		/*   Crystal connected to XIN/XOUT */
%endif
SYSCTRL_REGS->SYSCTRL_XOSC = tmp_REG; /* Write config XOSC */
while ((SYSCTRL_REGS->SYSCTRL_PCLKSR & SYSCTRL_PCLKSR_XOSCRDY_Msk) != SYSCTRL_PCLKSR_XOSCRDY_Msk ); /* Wait for Oscillator ready bit */	
%endif
%openfile buffer
%assign GCLK_PCHCTRLn = MchpVector64(RTWGenSettings.GCLK_PCHCTRLn) 	
%foreach iP = SIZE(GCLK_PCHCTRLn,1)	
%if GCLK_PCHCTRLn[iP] >= 0
%switch iP		
%case 0
GCLK_REGS->GCLK_CLKCTRL= GCLK_CLKCTRL_GEN_GCLK%<CAST("Number",GCLK_PCHCTRLn[iP])> | GCLK_CLKCTRL_CLKEN_Msk |  GCLK_CLKCTRL_ID_DFLL48; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by DFLL48M Reference */
%break
%case 1
GCLK_REGS->GCLK_CLKCTRL= GCLK_CLKCTRL_GEN_GCLK%<CAST("Number",GCLK_PCHCTRLn[iP])> | GCLK_CLKCTRL_CLKEN_Msk |  GCLK_CLKCTRL_ID_FDPLL; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by FDPLL input reference */				
%break
%case 2
GCLK_REGS->GCLK_CLKCTRL= GCLK_CLKCTRL_GEN_GCLK%<CAST("Number",GCLK_PCHCTRLn[iP])> | GCLK_CLKCTRL_CLKEN_Msk |  GCLK_CLKCTRL_ID_FDPLL32K; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by FDPLL 32kHz internal lock timer */
%break
%case 3
GCLK_REGS->GCLK_CLKCTRL= GCLK_CLKCTRL_GEN_GCLK%<CAST("Number",GCLK_PCHCTRLn[iP])> | GCLK_CLKCTRL_CLKEN_Msk |  GCLK_CLKCTRL_ID_WDT; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by WDT */
%break
%case 4
GCLK_REGS->GCLK_CLKCTRL= GCLK_CLKCTRL_GEN_GCLK%<CAST("Number",GCLK_PCHCTRLn[iP])> | GCLK_CLKCTRL_CLKEN_Msk |  GCLK_CLKCTRL_ID_RTC; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by RTC */
%break
%case 5
GCLK_REGS->GCLK_CLKCTRL= GCLK_CLKCTRL_GEN_GCLK%<CAST("Number",GCLK_PCHCTRLn[iP])> | GCLK_CLKCTRL_CLKEN_Msk |  GCLK_CLKCTRL_ID_EIC; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by EIC */
%break
%case 6
GCLK_REGS->GCLK_CLKCTRL= GCLK_CLKCTRL_GEN_GCLK%<CAST("Number",GCLK_PCHCTRLn[iP])> | GCLK_CLKCTRL_CLKEN_Msk |  GCLK_CLKCTRL_ID_USB; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by USB */
%break
%case 7
%case 8
%case 9
%case 10
%case 11
%case 12
%case 13
%case 14
%case 15
%case 16
%case 17
%case 18
GCLK_REGS->GCLK_CLKCTRL= GCLK_CLKCTRL_GEN_GCLK%<CAST("Number",GCLK_PCHCTRLn[iP])> | GCLK_CLKCTRL_CLKEN_Msk |  GCLK_CLKCTRL_ID_EVSYS_%<iP-7>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by  EVSYS%<iP-7> */
%break
%case 19
GCLK_REGS->GCLK_CLKCTRL= GCLK_CLKCTRL_GEN_GCLK%<CAST("Number",GCLK_PCHCTRLn[iP])> | GCLK_CLKCTRL_CLKEN_Msk |  GCLK_CLKCTRL_ID_SERCOMx_SLOW; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by SERCOMx Slow */
%break
%case 20
GCLK_REGS->GCLK_CLKCTRL= GCLK_CLKCTRL_GEN_GCLK%<CAST("Number",GCLK_PCHCTRLn[iP])> | GCLK_CLKCTRL_CLKEN_Msk |  GCLK_CLKCTRL_ID_SERCOM0_CORE; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by SERCOM0 Core */
%break
%case 21
GCLK_REGS->GCLK_CLKCTRL= GCLK_CLKCTRL_GEN_GCLK%<CAST("Number",GCLK_PCHCTRLn[iP])> | GCLK_CLKCTRL_CLKEN_Msk |  GCLK_CLKCTRL_ID_SERCOM1_CORE; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by SERCOM1 Core */
%break
%case 22
GCLK_REGS->GCLK_CLKCTRL= GCLK_CLKCTRL_GEN_GCLK%<CAST("Number",GCLK_PCHCTRLn[iP])> | GCLK_CLKCTRL_CLKEN_Msk |  GCLK_CLKCTRL_ID_SERCOM2_CORE; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by SERCOM2 Core */
%break
%case 23
GCLK_REGS->GCLK_CLKCTRL= GCLK_CLKCTRL_GEN_GCLK%<CAST("Number",GCLK_PCHCTRLn[iP])> | GCLK_CLKCTRL_CLKEN_Msk |  GCLK_CLKCTRL_ID_SERCOM3_CORE; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by SERCOM3 Core */
%break
%case 24
GCLK_REGS->GCLK_CLKCTRL= GCLK_CLKCTRL_GEN_GCLK%<CAST("Number",GCLK_PCHCTRLn[iP])> | GCLK_CLKCTRL_CLKEN_Msk |  GCLK_CLKCTRL_ID_SERCOM4_CORE; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by SERCOM4 Core */
%break
%case 25
GCLK_REGS->GCLK_CLKCTRL= GCLK_CLKCTRL_GEN_GCLK%<CAST("Number",GCLK_PCHCTRLn[iP])> | GCLK_CLKCTRL_CLKEN_Msk |  GCLK_CLKCTRL_ID_SERCOM5_CORE; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by SERCOM5 Core */
%break
%case 26
GCLK_REGS->GCLK_CLKCTRL= GCLK_CLKCTRL_GEN_GCLK%<CAST("Number",GCLK_PCHCTRLn[iP])> | GCLK_CLKCTRL_CLKEN_Msk |  GCLK_CLKCTRL_ID_TCC0_TCC1; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by TCC0, TCC1 */
%break
%case 27
GCLK_REGS->GCLK_CLKCTRL= GCLK_CLKCTRL_GEN_GCLK%<CAST("Number",GCLK_PCHCTRLn[iP])> | GCLK_CLKCTRL_CLKEN_Msk |  GCLK_CLKCTRL_ID_TCC2_TC3; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by TCC2, TC3 */
%break
%case 28
GCLK_REGS->GCLK_CLKCTRL= GCLK_CLKCTRL_GEN_GCLK%<CAST("Number",GCLK_PCHCTRLn[iP])> | GCLK_CLKCTRL_CLKEN_Msk |  GCLK_CLKCTRL_ID_TC4_TC5; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by TC4, TC5 */
%break
%case 29
GCLK_REGS->GCLK_CLKCTRL= GCLK_CLKCTRL_GEN_GCLK%<CAST("Number",GCLK_PCHCTRLn[iP])> | GCLK_CLKCTRL_CLKEN_Msk |  GCLK_CLKCTRL_ID_TC6_TC7; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by TC6, TC7 */
%break
%case 30
GCLK_REGS->GCLK_CLKCTRL= GCLK_CLKCTRL_GEN_GCLK%<CAST("Number",GCLK_PCHCTRLn[iP])> | GCLK_CLKCTRL_CLKEN_Msk |  GCLK_CLKCTRL_ID_ADC; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by ADC */
%break
%case 31
GCLK_REGS->GCLK_CLKCTRL= GCLK_CLKCTRL_GEN_GCLK%<CAST("Number",GCLK_PCHCTRLn[iP])> | GCLK_CLKCTRL_CLKEN_Msk |  GCLK_CLKCTRL_ID_AC_DIG; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by AC_DIG, AC1_DIG */
%break
%case 32
GCLK_REGS->GCLK_CLKCTRL= GCLK_CLKCTRL_GEN_GCLK%<CAST("Number",GCLK_PCHCTRLn[iP])> | GCLK_CLKCTRL_CLKEN_Msk |  GCLK_CLKCTRL_ID_AC_ANA; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by AC_ANA, AC1_ANA */
%break
%case 33
GCLK_REGS->GCLK_CLKCTRL= GCLK_CLKCTRL_GEN_GCLK%<CAST("Number",GCLK_PCHCTRLn[iP])> | GCLK_CLKCTRL_CLKEN_Msk |  GCLK_CLKCTRL_ID_DAC; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by DAC */
%break
%case 34
GCLK_REGS->GCLK_CLKCTRL= GCLK_CLKCTRL_GEN_GCLK%<CAST("Number",GCLK_PCHCTRLn[iP])> | GCLK_CLKCTRL_CLKEN_Msk |  GCLK_CLKCTRL_ID_PTC; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by PTC */
%break
%case 35
GCLK_REGS->GCLK_CLKCTRL= GCLK_CLKCTRL_GEN_GCLK%<CAST("Number",GCLK_PCHCTRLn[iP])> | GCLK_CLKCTRL_CLKEN_Msk |  GCLK_CLKCTRL_ID_I2S_0; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by I2S_0 */
%break
%case 36
GCLK_REGS->GCLK_CLKCTRL= GCLK_CLKCTRL_GEN_GCLK%<CAST("Number",GCLK_PCHCTRLn[iP])> | GCLK_CLKCTRL_CLKEN_Msk |  GCLK_CLKCTRL_ID_I2S_1; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by I2S_1 */
%break
%break
%default
%error("Peripheral GCLK clock assignement out of range")
%endswitch
%endif	
%endforeach
%closefile buffer
%if !ISEMPTY(buffer)
/* Assign Peripheral ID (GCLK_CLKCTRL_ID) to a given GCLK clock (GCLK_CLKCTRL_GEN_GCLK) */
%<buffer>
%endif
%assign GCLK_GENERATOR_x_CONFIG = MchpVector64(RTWGenSettings.GCLK_GENERATOR_x_CONFIG)  
%assign GCLK_GEN_x_SOURCE = MchpVector64(RTWGenSettings.GCLK_GEN_x_SOURCE)  
%assign GCLK_GEN_x_RUNSTDBY = MchpVector64(RTWGenSettings.GCLK_GEN_x_RUNSTDBY)  
%assign GCLK_GEN_x_DIVSEL = MchpVector64(RTWGenSettings.GCLK_GEN_x_DIVSEL)  
%assign GCLK_GEN_x_OE = MchpVector64(RTWGenSettings.GCLK_GEN_x_OE)  
%assign GCLK_GEN_x_OOV = MchpVector64(RTWGenSettings.GCLK_GEN_x_OOV)  
%assign GCLK_GEN_x_IDC = MchpVector64(RTWGenSettings.GCLK_GEN_x_IDC)  
%assign GCLK_GEN_x_GENEN = MchpVector64(RTWGenSettings.GCLK_GEN_x_GENEN)  
%assign GCLK_GEN_x_DIV = MchpVector64(RTWGenSettings.GCLK_GEN_x_DIV)  
%openfile buffer
%foreach iGLK = SIZE(GCLK_GENERATOR_x_CONFIG,1)	
%if GCLK_GENERATOR_x_CONFIG[iGLK] > 0		
%if (GCLK_PCHCTRLn[1] == iGLK) || (GCLK_PCHCTRLn[2] == iGLK)	
GCLK_REGS->GCLK_GENDIV = GCLK_GENDIV_ID(%<iGLK>) | GCLK_GENDIV_DIV(%<CAST("Number",GCLK_GEN_x_DIV[iGLK])>);	/* Clock Divider factor */						
%switch GCLK_GEN_x_SOURCE[iGLK]
%case 0
tmp_REG = GCLK_GENCTRL_SRC_XOSC;        /* XOSC oscillator output  */
%break
%case 1
tmp_REG = GCLK_GENCTRL_SRC_GCLKIN;      /* Generator input pad  */
%break
%case 2
tmp_REG = GCLK_GENCTRL_SRC_GCLKGEN1;    /* Generic clock generator 1 output  */
%break
%case 3
tmp_REG = GCLK_GENCTRL_SRC_OSCULP32K;   /* OSCULP32K oscillator output  */
%break
%case 4
tmp_REG = GCLK_GENCTRL_SRC_OSC32K;      /* OSC32K oscillator output  */
%break
%case 5
tmp_REG = GCLK_GENCTRL_SRC_XOSC32K;     /* XOSC32K oscillator output  */
%break
%case 6
tmp_REG = GCLK_GENCTRL_SRC_OSC8M;      /* OSC8M oscillator output  */
%break
%case 7
tmp_REG = GCLK_GENCTRL_SRC_DFLL48M;     /* DFLL48M output  */
%break
%case 8
tmp_REG = GCLK_GENCTRL_SRC_DPLL96M;     /* DPLL96M output  */
%break
%default
%error("Internal error: Generator source not recognized")
%endswitch		
%if GCLK_GEN_x_RUNSTDBY[iGLK]
tmp_REG |= GCLK_GENCTRL_RUNSTDBY_Msk; /* Run in stdby mode */
%endif
%if GCLK_GEN_x_DIVSEL[iGLK]
tmp_REG |= GCLK_GENCTRL_DIVSEL_Msk; /* Divide by 2^(divider factor + 1) */
%endif
%if GCLK_GEN_x_OE[iGLK]
tmp_REG |= GCLK_GENCTRL_OE_Msk; /* Output enable */
%endif
%if GCLK_GEN_x_OOV[iGLK]
tmp_REG |= GCLK_GENCTRL_OOV_Msk; /* Output Off Value */
%endif
%if GCLK_GEN_x_IDC[iGLK]
tmp_REG |= GCLK_GENCTRL_IDC_Msk; /* Improve Duty Cycle */
%endif
%if GCLK_GEN_x_GENEN[iGLK]		
tmp_REG |= GCLK_GENCTRL_GENEN_Msk; /* Generic Clock Generator Enabled */
%endif
tmp_REG |= GCLK_GENCTRL_ID(%<iGLK>); /* Clock ID */		
GCLK_REGS->GCLK_GENCTRL = tmp_REG;	/* GCLK%<iGLK> config */					
%endif			
%endif
%endforeach
%closefile buffer
%if !ISEMPTY(buffer)
/* ---- Configure GCLK used as PLL source  ---- */
%<buffer>
while ((GCLK_REGS->GCLK_STATUS) != 0) ; /* Wait Sync for GCLKs */
%endif
%assign SYSCTRL_DPLLCTRL_CONFIG = CAST("Number",RTWGenSettings.SYSCTRL_DPLLCTRL_CONFIG) 
%assign SYSCTRL_DPLLCTRL_INFO_Fin  = CAST("Real",RTWGenSettings.SYSCTRL_DPLLCTRL_INFO_Fin)
%assign SYSCTRL_DPLLCTRL_INFO_PLLout  = CAST("Real",RTWGenSettings.SYSCTRL_DPLLCTRL_INFO_PLLout)
%assign SYSCTRL_DPLLCTRLA_ENABLE = CAST("Number",RTWGenSettings.SYSCTRL_DPLLCTRLA_ENABLE) 
%assign SYSCTRL_DPLLCTRLA_ONDEMAND = CAST("Number",RTWGenSettings.SYSCTRL_DPLLCTRLA_ONDEMAND) 
%assign SYSCTRL_DPLLCTRLA_RUNSTDBY = CAST("Number",RTWGenSettings.SYSCTRL_DPLLCTRLA_RUNSTDBY) 
%assign SYSCTRL_DPLLCTRLB_REFCLK_GCLK = CAST("Number",RTWGenSettings.SYSCTRL_DPLLCTRLB_REFCLK_GCLK) 
%assign SYSCTRL_DPLLCTRLB_REFCLK_XOSC = CAST("Number",RTWGenSettings.SYSCTRL_DPLLCTRLB_REFCLK_XOSC) 
%assign SYSCTRL_DPLLCTRLB_REFCLK_XOSC32K = CAST("Number",RTWGenSettings.SYSCTRL_DPLLCTRLB_REFCLK_XOSC32K) 
%assign SYSCTRL_DPLLRATIO_LDRFRAC = CAST("Number",RTWGenSettings.SYSCTRL_DPLLRATIO_LDRFRAC) 
%assign SYSCTRL_DPLLRATIO_LDR = CAST("Number",RTWGenSettings.SYSCTRL_DPLLRATIO_LDR) 
%assign SYSCTRL_DPLLCTRLB_DIV = CAST("Number",RTWGenSettings.SYSCTRL_DPLLCTRLB_DIV) 
%assign SYSCTRL_DPLLCTRLB_LBYPASS = CAST("Number",RTWGenSettings.SYSCTRL_DPLLCTRLB_LBYPASS) 
%assign SYSCTRL_DPLLCTRLB_LTIME_DEFAULT = CAST("Number",RTWGenSettings.SYSCTRL_DPLLCTRLB_LTIME_DEFAULT)
%assign SYSCTRL_DPLLCTRLB_LTIME_8MS = CAST("Number",RTWGenSettings.SYSCTRL_DPLLCTRLB_LTIME_8MS)
%assign SYSCTRL_DPLLCTRLB_LTIME_9MS = CAST("Number",RTWGenSettings.SYSCTRL_DPLLCTRLB_LTIME_9MS)
%assign SYSCTRL_DPLLCTRLB_LTIME_10MS = CAST("Number",RTWGenSettings.SYSCTRL_DPLLCTRLB_LTIME_10MS)
%assign SYSCTRL_DPLLCTRLB_LTIME_11MS = CAST("Number",RTWGenSettings.SYSCTRL_DPLLCTRLB_LTIME_11MS)
%assign SYSCTRL_DPLLCTRLB_WUF = CAST("Number",RTWGenSettings.SYSCTRL_DPLLCTRLB_WUF) 
%assign SYSCTRL_DPLLCTRLB_LPEN = CAST("Number",RTWGenSettings.SYSCTRL_DPLLCTRLB_LPEN) 
%assign SYSCTRL_DPLLPRESC_PRESC_DIVx = CAST("Number",RTWGenSettings.SYSCTRL_DPLLPRESC_PRESC_DIVx)
%if SYSCTRL_DPLLCTRL_CONFIG
/* ---- Configure PLL from %<QUARTZ>Hz to %<SYSCTRL_DPLLCTRL_INFO_PLLout>Hz ---- */
tmp_REG = SYSCTRL_DPLLRATIO_LDR(%<SYSCTRL_DPLLRATIO_LDR>); /* PLL Multiplier (x%<SYSCTRL_DPLLRATIO_LDR+1>) from %<SYSCTRL_DPLLCTRL_INFO_Fin> to %<SYSCTRL_DPLLCTRL_INFO_PLLout> */
%if SYSCTRL_DPLLRATIO_LDRFRAC > 0
tmp_REG |= SYSCTRL_DPLLRATIO_LDRFRAC(%<SYSCTRL_DPLLRATIO_LDRFRAC>); /* PLL Multiplier Fractional (%<SYSCTRL_DPLLRATIO_LDRFRAC>/16) */
%endif
SYSCTRL_REGS->SYSCTRL_DPLLRATIO = tmp_REG; /* Write SYSCTRL_DPLL_RATIO config (x%<SYSCTRL_DPLLRATIO_LDR+1+SYSCTRL_DPLLRATIO_LDRFRAC/16>) */
%if SYSCTRL_DPLLCTRLB_REFCLK_GCLK
tmp_REG = SYSCTRL_DPLLCTRLB_REFCLK_GCLK; /* set GCLK as PLL Source Clock %<QUARTZ>Hz */
%elseif SYSCTRL_DPLLCTRLB_REFCLK_XOSC32K
tmp_REG = SYSCTRL_DPLLCTRLB_REFCLK_REF0; /* set XOSC32K as PLL Source Clock %<QUARTZ>Hz */ 
%elseif SYSCTRL_DPLLCTRLB_REFCLK_XOSC
tmp_REG = SYSCTRL_DPLLCTRLB_REFCLK_REF1; /* set XOSC as PLL Source Clock %<QUARTZ>Hz */ 
%else
%error("Unknown Source clock for PLL")
%endif
%if SYSCTRL_DPLLCTRLB_DIV == 1
tmp_REG |= SYSCTRL_DPLLCTRLB_DIV; /* PLL Divider */
%endif
%if SYSCTRL_DPLLCTRLB_LBYPASS == 1
tmp_REG |= SYSCTRL_DPLLCTRLB_LBYPASS; /* Bypasse Look up test bit */
%endif
%if SYSCTRL_DPLLCTRLB_LTIME_DEFAULT == 1
tmp_REG |= SYSCTRL_DPLLCTRLB_LTIME_DEFAULT;  /* Lookup Time Automatic */
%endif
%if SYSCTRL_DPLLCTRLB_LTIME_8MS == 1
tmp_REG |= SYSCTRL_DPLLCTRLB_LTIME_8MS; /* Lookup Time */
%endif
%if SYSCTRL_DPLLCTRLB_LTIME_9MS == 1
tmp_REG |= SYSCTRL_DPLLCTRLB_LTIME_9MS;  /* Lookup Time */
%endif
%if SYSCTRL_DPLLCTRLB_LTIME_10MS == 1
tmp_REG |= SYSCTRL_DPLLCTRLB_LTIME_10MS; /* Lookup Time */
%endif
%if SYSCTRL_DPLLCTRLB_LTIME_11MS == 1
tmp_REG |= SYSCTRL_DPLLCTRLB_LTIME_11MS; /* Lookup Time */
%endif
%if SYSCTRL_DPLLCTRLB_WUF == 1
tmp_REG |= SYSCTRL_DPLLCTRLB_WUF; /* Wake Up Fast */
%endif
%if SYSCTRL_DPLLCTRLB_LPEN == 1
tmp_REG |= SYSCTRL_DPLLCTRLB_LPEN; /* Low Power */
%endif
SYSCTRL_REGS->SYSCTRL_DPLLCTRLB = tmp_REG; /* Write SYSCTRL_DPLLCTRLB config */
tmp_REG = SYSCTRL_DPLLCTRLA_ENABLE_Msk;    	/* Enable */	
%if SYSCTRL_DPLLCTRLA_RUNSTDBY == 1
tmp_REG |= SYSCTRL_DPLLCTRLA_RUNSTDBY_Msk; /* Run in Standby  */
%endif
%if SYSCTRL_DPLLCTRLA_ONDEMAND == 1
tmp_REG |= SYSCTRL_DPLLCTRLA_ONDEMAND_Msk; /*  On Demand  */
%endif
SYSCTRL_REGS->SYSCTRL_DPLLCTRLA = tmp_REG; /* Write SYSCTRL_DPLLCTRLA config */
while ((SYSCTRL_REGS->SYSCTRL_DPLLSTATUS & SYSCTRL_DPLLSTATUS_LOCK_Msk) == 0 ); /* Wait for PLL ready bit */	
%endif
%openfile buffer
%foreach iGLK = SIZE(GCLK_GENERATOR_x_CONFIG,1)
%if GCLK_GENERATOR_x_CONFIG[iGLK] > 0	
%if 0 == ( (GCLK_PCHCTRLn[1] == iGLK) || (GCLK_PCHCTRLn[2] == iGLK) )	
GCLK_REGS->GCLK_GENDIV = GCLK_GENDIV_ID(%<iGLK>) | GCLK_GENDIV_DIV(%<CAST("Number",GCLK_GEN_x_DIV[iGLK])>);	/* Clock Divider factor */						
%switch GCLK_GEN_x_SOURCE[iGLK]
%case 0
tmp_REG = GCLK_GENCTRL_SRC_XOSC;        /* XOSC oscillator output  */
%break
%case 1
tmp_REG = GCLK_GENCTRL_SRC_GCLKIN;      /* Generator input pad  */
%break
%case 2
tmp_REG = GCLK_GENCTRL_SRC_GCLKGEN1;    /* Generic clock generator 1 output  */
%break
%case 3
tmp_REG = GCLK_GENCTRL_SRC_OSCULP32K;   /* OSCULP32K oscillator output  */
%break
%case 4
tmp_REG = GCLK_GENCTRL_SRC_OSC32K;      /* OSC32K oscillator output  */
%break
%case 5
tmp_REG = GCLK_GENCTRL_SRC_XOSC32K;     /* XOSC32K oscillator output  */
%break
%case 6
tmp_REG = GCLK_GENCTRL_SRC_OSC8M;      /* OSC8M oscillator output  */
%break
%case 7
tmp_REG = GCLK_GENCTRL_SRC_DFLL48M;     /* DFLL48M output  */
%break
%case 8
tmp_REG = GCLK_GENCTRL_SRC_DPLL96M;     /* DPLL96M output  */
%break
%default
%error("Internal error: Generator source not recognized")
%endswitch		
%if GCLK_GEN_x_RUNSTDBY[iGLK]
tmp_REG |= GCLK_GENCTRL_RUNSTDBY_Msk; /* Run in stdby mode */
%endif
%if GCLK_GEN_x_DIVSEL[iGLK]
tmp_REG |= GCLK_GENCTRL_DIVSEL_Msk; /* Divide by 2^(divider factor + 1) */
%endif
%if GCLK_GEN_x_OE[iGLK]
tmp_REG |= GCLK_GENCTRL_OE_Msk; /* Output enable */
%endif
%if GCLK_GEN_x_OOV[iGLK]
tmp_REG |= GCLK_GENCTRL_OOV_Msk; /* Output Off Value */
%endif
%if GCLK_GEN_x_IDC[iGLK]
tmp_REG |= GCLK_GENCTRL_IDC_Msk; /* Improve Duty Cycle */
%endif
%if GCLK_GEN_x_GENEN[iGLK]		
tmp_REG |= GCLK_GENCTRL_GENEN_Msk; /* Generic Clock Generator Enabled */
%endif
tmp_REG |= GCLK_GENCTRL_ID(%<iGLK>); /* Clock ID */		
GCLK_REGS->GCLK_GENCTRL = tmp_REG;	/* GCLK%<iGLK> config */					
%endif			
%endif
%endforeach
%closefile buffer
%if !ISEMPTY(buffer)
/* ---- Configure GCLK used to clock CPU (GCLK0) and peripherals ---- */
%<buffer>
while ((GCLK_REGS->GCLK_STATUS) != 0) ; /* Wait Sync for GCLKs */
%endif
}
/* ------- END of Clock Configuration ----  */
%<MCHP_ConfigPins()>
/* Initialize model */
%if ConfigChipOnly == 0
%<LibCallModelInitialize()> 	
%endif
/* ------- NVIC Setup ------ */
%assign TimeStep_SyncADC = CAST("Number",RTWGenSettings.TimeStep_SyncADC)
%if TimeStep_SyncADC == -1
%if CompiledModel.FixedStepOpts.SolverMode == "MultiTasking"
NVIC_SetPriority(SysTick_IRQn, 3U);     /* Scheduler Priority set to 3 (left aligned is 0xC0) */
NVIC_SetPriority(SVCall_IRQn, 0u);
%else
NVIC_SetPriority(SysTick_IRQn, 3U);     /* Scheduler Priority set to 3 */
%endif
%openfile LocalStartup_TrigTimeStepInstruction
%<::Startup_TrigTimeStepInstruction>\		 		
/* ------ SysTick  Init -----------  */
%assign SYS_TICK_TS_Load = CAST("Number",RTWGenSettings.SYS_TICK_TS_Load)
SysTick->VAL   =  1UL*8;								/*  Start value for the sys Tick counter. Execute first STEP ASAP */
SysTick->LOAD  =  %<SYS_TICK_TS_Load>UL;                                /*  Reload value (corresponds to 1s). This value will be decremented at each CPU tick */
SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk;   /*  Enable SysTick Interrupt; start the counter; select the source for tick (MCLK)   */
%closefile LocalStartup_TrigTimeStepInstruction
%assign ::Startup_TrigTimeStepInstruction = LocalStartup_TrigTimeStepInstruction
%else 
%openfile LocalStartup_TrigTimeStepInstruction
%<::Startup_TrigTimeStepInstruction>\		 		
%if CompiledModel.FixedStepOpts.SolverMode == "MultiTasking"
NVIC_SetPriority(PM_IRQn, 3U);     /* Scheduler Priority set to 3 */
NVIC_SetPriority(SVCall_IRQn, 0u);
%else
%endif
NVIC_EnableIRQ(PM_IRQn);                               /*  Enable NVIC line for PM_IRQn  */	
%closefile LocalStartup_TrigTimeStepInstruction
%assign ::Startup_TrigTimeStepInstruction = LocalStartup_TrigTimeStepInstruction
%endif    	
__enable_irq();	/* Enable Interrupt (Clear PRIMASK) */
%closefile tmpFcnOsc
%return tmpFcnOsc
%endfunction
