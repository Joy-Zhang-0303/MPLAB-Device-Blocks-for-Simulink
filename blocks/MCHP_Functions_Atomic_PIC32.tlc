
%function Mchp_asm_ABset(Variable,bit) Output
__asm__ volatile( "aset %<bit % 8>, %<bit/8> (%[MyVar])" : : [MyVar] "r" (&%<Variable>) );	 /* Atomic bit-set : %<Variable> |= %< 1U << bit > */
%endfunction
%function Mchp_asm_ABclr(Variable,bit) Output
__asm__ volatile( "aclr %<bit % 8>, %<bit/8> (%[MyVar])" : : [MyVar] "r" (&%<Variable>) );		 /* Atomic bit-clear of %<Variable> bit %< 1U << bit > */
%endfunction
%function Mchp_asm_Ainc(Variable) Output
{ register uint_T __a ;
__asm__ volatile ( 	"1:\n"
"ll %[tmp], %[MyVar]\n"
"addiu %[tmp], %[tmp], 1\n" /* ensure atomic increment of %<Variable> */
"sc %[tmp], %[MyVar]\n"
"beqz %[tmp],1b"      /* Jump to previous 1 label if atomic operation failed */
: [MyVar] "+ZC" (%<Variable>), [tmp] "=r" (__a)
);
}
%endfunction
%function Mchp_asm_Adec(Variable) Output
{ register uint_T __a ;
__asm__ volatile ( 	"1:\n"
"ll %[tmp], %[MyVar]\n"
"addiu %[tmp], %[tmp], -1\n" /* ensure atomic decrement of %<Variable> */
"sc %[tmp], %[MyVar]\n"
"beqz %[tmp],1b"      /* Jump to previous 1 label if atomic operation failed */
: [MyVar] "+ZC" (%<Variable>), [tmp] "=r" (__a)
);
}
%endfunction
%function Mchp_asm_DisableSchedulerInterrupt() Output
%if ::CompiledModel.FixedStepOpts.SolverMode == "MultiTasking"
__builtin_set_isr_state(8 + 2); /* Disable Scheduler Interrupts. Rise IPL from 1 to 2; keep bit ei set */ 					
%else
__builtin_set_isr_state(8 + 1); /* Disable Scheduler Interrupts. Rise IPL from 0 to 1; keep bit ei set */  
%endif
%endfunction
%function Mchp_asm_EnableSchedulerInterrupt() Output
%if ::CompiledModel.FixedStepOpts.SolverMode == "MultiTasking"
__builtin_set_isr_state(8 + 1); /* Re-Enable Scheduler re-entrant interrupt. Lower IPL from 2 to 1 ; keep bit ei set */  
%else
__builtin_set_isr_state(8 + 0); /* Re-Enable Scheduler re-entrant interrupt. Lower IPL from 1 to 0 ; keep bit ei set */
%endif
%endfunction
%function SET_AND_SAVE_CPU_IPL(cpu_ipl_switchVar,IPL,cmt) Output			
%<cpu_ipl_switchVar> = __builtin_get_isr_state(); /* Save IPL */
__builtin_set_isr_state(%<IPL>);	/* %<cmt> */
%endfunction
%function RESTORE_CPU_IPL(cpu_ipl_switchVar,cmt) Output	
__builtin_set_isr_state(%<cpu_ipl_switchVar>); /* %<cmt> */
%endfunction
%function Mchp_asm_DisableAllInterrupt() Output
__builtin_disable_interrupts();
%endfunction
%function Mchp_asm_EnableAllInterrupt() Output
__builtin_enable_interrupts();
%endfunction
