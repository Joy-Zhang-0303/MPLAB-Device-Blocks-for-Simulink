
%function MCHP_UART_Config_Tx_Interrupt(block,system) Output 	
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%assign nUSART = CAST("Number",block.RTWdata.nUSART)	
%switch ::ChipIdL1
%case "SAME"
%case "SAMS"
%case "SAMV"
%if UARTRef > nUSART
%assign Per_Type = "UART"
%assign REG_NAME = "UART"
%assign REG_NAME2 = ""
%assign INTERRUPT_STATUS_REG = "SR"
%assign UART_Index = (UARTRef-1) - nUSART
%else
%assign Per_Type = "USART"
%assign REG_NAME = "US"
%assign REG_NAME2 = "USART_"
%assign INTERRUPT_STATUS_REG = "CSR"
%assign UART_Index = UARTRef-1
%endif
%assign UART_NAME = "%<Per_Type>%<UART_Index>"
%break
%case "SAMRH"
%assign Per_Type = "USART"
%assign REG_NAME = "FLEX_US"
%assign REG_NAME2 = ""
%assign INTERRUPT_STATUS_REG = "CSR"
%assign UART_Index = UARTRef-1
%assign UART_NAME = "FLEXCOM%<UART_Index>"
%break
%default
%error("Internal error with UART")
%endswitch
%assign TX_IMPLEMENTATION = MchpVector(RTWGenSettings.UART_TX_IMPLEMENTATION)
%assign TX_IMPLEMENTATION = TX_IMPLEMENTATION[UARTRef-1]		
%assign InitSequence_enable = CAST("Number",block.RTWdata.InitSequence_enable)
%assign UART_HALF_DUPLEX_MODE = MchpVector(RTWGenSettings.UART_HALF_DUPLEX_MODE)
%assign UART_HALF_DUPLEX_MODE = UART_HALF_DUPLEX_MODE[UARTRef-1]
%assign INT_PRIORITY = CAST("Number",block.RTWdata.INT_PRIORITY)
%assign TX_BufferSize = CAST("Number",block.RTWdata.TX_CIRCULAR_SIZE)
%openfile buffer
/* Declare %<UART_NAME> Tx Circular Buffer Structure */
#define Tx_BUFF_SIZE_%<UART_NAME> (%<TX_BufferSize>)    
typedef struct MCHP_%<UART_NAME>_TxStr
{
volatile uint8_T buffer[Tx_BUFF_SIZE_%<UART_NAME>];			/* Size Rx_BUFF_SIZE_%<UART_NAME> is %<TX_BufferSize> */
volatile uint_T  tail;                                          /* tail is the index for the next value to be read from the Circular buffer */				
volatile uint_T  head;                                          /* head is the index for the next value to be written into the Circular buffer */
} MCHP_%<UART_NAME>_TxStr;
%closefile buffer
%<LibCacheTypedefs(buffer)>		
%openfile buffer
/* Declare %<UART_NAME> Tx Circular Buffer Structure */
extern MCHP_%<UART_NAME>_TxStr MCHP_%<UART_NAME>_Tx;
%closefile buffer
%<LibCacheExtern(buffer)>
%openfile ::tx_prologue			
/* Declare %<UART_NAME> Tx Circular Buffer Structure */
MCHP_%<UART_NAME>_TxStr MCHP_%<UART_NAME>_Tx = { .head = 0, .tail = 0 };	/* %<UART_NAME> Tx FIFO */
%closefile tx_prologue
%openfile ::tx_epilogue
/* Handle Tx interrupt */
if ((%<UART_NAME>_REGS->%<REG_NAME>_IMR & %<REG_NAME>_IMR_%<REG_NAME2>TXRDY_Msk) &&  (%<UART_NAME>_REGS->%<REG_NAME>_%<INTERRUPT_STATUS_REG> & %<REG_NAME>_%<INTERRUPT_STATUS_REG>_%<REG_NAME2>TXRDY_Msk))
{
uint_T LocalHead;
LocalHead = MCHP_%<UART_NAME>_Tx.head;	/* Head is a volatile variable. Use local variable to speed-up execution */
%assign ClosureUART_HALF_DUPLEX_MODE = ""
%if UART_HALF_DUPLEX_MODE == 1
if (MCHP_%<UART_NAME>_Tx.tail == LocalHead)            {
/* Wait for last transactiont to complete if any */  		
while ((%<UART_NAME>_REGS->%<REG_NAME>_%<INTERRUPT_STATUS_REG> & %<REG_NAME>_%<INTERRUPT_STATUS_REG>_%<REG_NAME2>TXRDY_Msk) == 0){
NOP();
}
%<UART_NAME>_REGS->%<REG_NAME>_CR = (%<UART_NAME>_REGS->%<REG_NAME>_CR & (~%<REG_NAME>_CR_%<REG_NAME2>>TXDIS_Msk)) | %<REG_NAME>_CR_%<REG_NAME2>>TXDIS_Msk;    /* Disable TX */
{unsigned int MCHP_dummy __attribute__((unused)) = %<UART_NAME>_REGS->%<REG_NAME>_RHR;}     /* Clear Rx Interrupt Flag by reading the receive holding register */
%<UART_NAME>_REGS->%<REG_NAME>_IER = %<REG_NAME>_IER_%<REG_NAME2>RXRDY_Msk;       /* RXRDY Interrupt Enable */
}
else {
%assign ClosureUART_HALF_DUPLEX_MODE = "}"
%endif
while ( (%<UART_NAME>_REGS->%<REG_NAME>_%<INTERRUPT_STATUS_REG> & %<REG_NAME>_%<INTERRUPT_STATUS_REG>_%<REG_NAME2>TXRDY_Msk) && (MCHP_%<UART_NAME>_Tx.tail != LocalHead) ) /* while Tx buffer is not full */
{ 									
%<UART_NAME>_REGS->%<REG_NAME>_THR = (%<UART_NAME>_REGS->%<REG_NAME>_THR & (~%<REG_NAME>_THR_TXCHR_Msk)) | %<REG_NAME>_THR_TXCHR(MCHP_%<UART_NAME>_Tx.buffer[LocalHead]);
LocalHead = (LocalHead + 1) & (Tx_BUFF_SIZE_%<UART_NAME> - 1);
}				
if  (MCHP_%<UART_NAME>_Tx.tail == LocalHead)
{
%<UART_NAME>_REGS->%<REG_NAME>_IDR = %<REG_NAME>_IDR_%<REG_NAME2>TXRDY_Msk;       /* Disable TXRDY Interrupt */
}	
MCHP_%<UART_NAME>_Tx.head = LocalHead; /* Push back volatile variable */			
%<ClosureUART_HALF_DUPLEX_MODE>	
} 		
%closefile tx_epilogue
%endfunction