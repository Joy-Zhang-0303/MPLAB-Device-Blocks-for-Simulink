%include "MCHP_Functions.tlc"
%function MchpStartup(ConfigChipOnly) void
%openfile tmpFcnOsc
/* --- WDS & Brownout setup --- */
WDT_REGS->WDT_MR |=  WDT_MR_WDDIS(1);                        /* Disable Watchdog */
%switch ::ChipIdL1
%case "SAME"
%case "SAMV"
%case "SAMS"
SUPC_REGS->SUPC_MR |= SUPC_MR_BODDIS(1);                     /* Disable Brownout detection */
%break
%case "SAMRH"
SUPC_REGS->SUPC_MR |= SUPC_MR_CORSMDIS(1);                     /* disable VDDCORE supply monitor */
%break
%default
%error("No wait state set for chip family " + ::ChipIdL1 )
%endswitch
/* --- Clock Configuration: see Datasheet section 31.17 Recommended Programming Sequence --- */
%assign TARGET_FREQUNECY = CAST("Real",RTWGenSettings.MIPS)    
%assign SELECTED_MAIN_CLOCKSOURCE = RTWGenSettings.SELECTED_MAIN_CLOCKSOURCE    
%assign MASTER_CLOCK_PRES = CAST("Number",RTWGenSettings.MCKR_PRES)
%assign MASTER_CLOCK_MDIV = CAST("Number",RTWGenSettings.MCKR_MDIV)
%assign PLL_ENABLED = CAST("Number",RTWGenSettings.PLL_ENABLED)
%assign PLL_MUL = CAST("Number",RTWGenSettings.PLL_MUL)
%assign PLL_DIV = CAST("Number",RTWGenSettings.PLL_DIV)
%assign SELECTED_MAIN_RC_FREQ = CAST("Number",RTWGenSettings.SELECTED_MAIN_RC_FREQ)
%switch ::ChipIdL1
%case "SAME"
%case "SAMV"
%case "SAMS"
EFC_REGS->EEFC_FMR = EEFC_FMR_FWS(6)|EEFC_FMR_CLOE_Msk; /* Set flash wait states to safe value. Update after clock setup if required */
%break
%case "SAMRH"
%break
%default
%error("No wait state set for chip family " + ::ChipIdL1 )
%endswitch
/* Configure Clock source with %<SELECTED_MAIN_CLOCKSOURCE> at %<TARGET_FREQUNECY>Hz */
/* Disable PLL */
PMC_REGS->CKGR_PLLAR = CKGR_PLLAR_ONE_Msk | CKGR_PLLAR_DIVA(0) | CKGR_PLLAR_MULA(0);
/* ------------- Switch on CLOCK SOURCE -------------------------- */
%switch SELECTED_MAIN_CLOCKSOURCE
%case "SLOW_RC_32K"
%assign CLOCK_SOURCE_FOR_MASTER_CLOCK = 0
%break
%case "XTAL_32K"
%assign CLOCK_SOURCE_FOR_MASTER_CLOCK = 0
SUPC_REGS->SUPC_CR |= SUPC_CR_KEY_PASSWD | SUPC_CR_XTALSEL(1u);
while((SUPC_REGS->SUPC_CR & SUPC_SR_OSCSEL_Msk) == 0U) __NOP(); /* Wait until clk switch is finished */
%break
%case "EXTERNAL_OSC_32K"
%assign CLOCK_SOURCE_FOR_MASTER_CLOCK = 0
SUPC_REGS->SUPC_MR |= SUPC_MR_KEY_PASSWD | SUPC_MR_OSCBYPASS(1u);
SUPC_REGS->SUPC_CR |= SUPC_CR_KEY_PASSWD | SUPC_CR_XTALSEL(1u);
while((SUPC_REGS->SUPC_CR & SUPC_SR_OSCSEL_Msk) == 0U) __NOP(); /* Wait until clk switch is finished */
%break
%case "MAIN_RC"
%assign CLOCK_SOURCE_FOR_MASTER_CLOCK = 1
/* Enable MAIN_RC Oscillator */
PMC_REGS->CKGR_MOR |=  CKGR_MOR_MOSCRCEN(1u) | CKGR_MOR_KEY_PASSWD;
/* Wait until Main RC oscillator is stabilized */
while((PMC_REGS->PMC_SR & PMC_SR_MOSCRCS_Msk) == 0) __NOP(); /* Wait until clk switch is finished */
/* set MAIN_RC Frequency */
PMC_REGS->CKGR_MOR = ((PMC_REGS->CKGR_MOR & (~CKGR_MOR_MOSCRCF_Msk)) | CKGR_MOR_MOSCRCF(%<SELECTED_MAIN_RC_FREQ>)) | CKGR_MOR_KEY_PASSWD;
while((PMC_REGS->PMC_SR & PMC_SR_MOSCRCS_Msk) == 0) __NOP(); /* Wait until Main RC oscillator is stabilized */
/* Select MAIN_RC as Main Clock Oscillator */
PMC_REGS->CKGR_MOR = (PMC_REGS->CKGR_MOR & (~CKGR_MOR_MOSCSEL_Msk)) | CKGR_MOR_MOSCSEL(0u)| CKGR_MOR_KEY_PASSWD;
while((PMC_REGS->PMC_SR & PMC_SR_MOSCSELS_Msk) == 0) __NOP(); /* Wait until Main Clock Source selection is DONE */
/* Disable Main Crystal Oscillator (power saving) */
PMC_REGS->CKGR_MOR = (PMC_REGS->CKGR_MOR & (~CKGR_MOR_MOSCXTEN_Msk)) | CKGR_MOR_MOSCXTEN(0u) | CKGR_MOR_KEY_PASSWD;
%break
%case "MAIN_XTAL"
%assign CLOCK_SOURCE_FOR_MASTER_CLOCK = 1
/* Set Main Crystal Oscillator Startup Time (to maximum = SLCK cycles * 8 * 255 = ~62 ms) */
PMC_REGS->CKGR_MOR = ((PMC_REGS->CKGR_MOR & (~CKGR_MOR_MOSCXTST_Msk)) | CKGR_MOR_MOSCXTST(0xFF)) | CKGR_MOR_KEY_PASSWD ;
/* Enable Main Crystal Oscillator */
PMC_REGS->CKGR_MOR |=  CKGR_MOR_MOSCXTEN(1u) |CKGR_MOR_KEY_PASSWD;
while((PMC_REGS->PMC_SR & PMC_SR_MOSCXTS_Msk) == 0U) __NOP();  /* Wait until XC oscillator is stabilized */
/* Switch Main Clock to Crystal/External Oscillator */
PMC_REGS->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL(1u);
while((PMC_REGS->PMC_SR & PMC_SR_MOSCSELS_Msk) == 0U) __NOP(); /* Wait until Main Clock Source selection is DONE */
/* Disable MAIN_RC to save power */
PMC_REGS->CKGR_MOR = (PMC_REGS->CKGR_MOR & (~CKGR_MOR_MOSCRCEN_Msk)) | CKGR_MOR_MOSCRCEN(0u) | CKGR_MOR_KEY_PASSWD;
%break
%case "EXTERNAL_OSC"
%assign CLOCK_SOURCE_FOR_MASTER_CLOCK = 1
/* Set Main Crystal Oscillator Startup Time (to maximum = SLCK cycles * 8 * 255 = ~62 ms) */
PMC_REGS->CKGR_MOR = ((PMC_REGS->CKGR_MOR & (~CKGR_MOR_MOSCXTST_Msk)) | CKGR_MOR_MOSCXTST(0xFF)) | CKGR_MOR_KEY_PASSWD ;
/* Bypass the the Main crystal oscillator to enabled External Oscillator */
PMC_REGS->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY(1u);
while((PMC_REGS->PMC_SR & PMC_SR_MOSCXTS_Msk) == 0U) __NOP(); /* Wait until External Oscillator is stabilized */
/* Switch Main Clock to Crystal/External Oscillator */
PMC_REGS->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL(1u);
while((PMC_REGS->PMC_SR & PMC_SR_MOSCSELS_Msk) == 0U) __NOP(); /* Wait until Main Clock Source selection is DONE */
/* Disable Main Crystal Oscillator if an External one is used */
PMC_REGS->CKGR_MOR = (PMC_REGS->CKGR_MOR & (~CKGR_MOR_MOSCXTEN_Msk)) | CKGR_MOR_MOSCXTEN(0u) | CKGR_MOR_KEY_PASSWD;
/* Disable MAIN_RC to save power */
PMC_REGS->CKGR_MOR = (PMC_REGS->CKGR_MOR & (~CKGR_MOR_MOSCRCEN_Msk)) | CKGR_MOR_MOSCRCEN(0u) | CKGR_MOR_KEY_PASSWD;
%break
%endswitch
%if PLL_ENABLED
%assign CLOCK_SOURCE_FOR_MASTER_CLOCK = 2
/* ------------- Setup PLL -------------------------- */
/*  Disable the PLL first */
PMC_REGS->CKGR_PLLAR = (PMC_REGS->CKGR_PLLAR & ((~CKGR_PLLAR_ONE_Msk) & (~CKGR_PLLAR_DIVA_Msk) & (~CKGR_PLLAR_MULA_Msk)))
| CKGR_PLLAR_ONE(1u) | CKGR_PLLAR_DIVA(0u) | CKGR_PLLAR_MULA(0u);
/* Load PLL Counter with maximum value (2^5 = 32)*/
PMC_REGS->CKGR_PLLAR = (PMC_REGS->CKGR_PLLAR & (~CKGR_PLLAR_PLLACOUNT_Msk)) | CKGR_PLLAR_PLLACOUNT(0b11111) | CKGR_PLLAR_ONE(1);
/* Activate PLL:  PLLACK_Output(MHz) = MAIN_CLOCK * (%<PLL_MUL>+1) / %<PLL_DIV> */
PMC_REGS->CKGR_PLLAR |=  CKGR_PLLAR_ONE(1u) | CKGR_PLLAR_DIVA(%<PLL_DIV>) | CKGR_PLLAR_MULA(%<PLL_MUL>) ;
/* Wait until PLLA is locked */
while((PMC_REGS->PMC_SR & PMC_SR_LOCKA_Msk) == 0U) __NOP();
/* ------------- Connect CLOCK SOURCE -------------------------- */
PMC_REGS->PMC_MCKR = (PMC_REGS->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | PMC_MCKR_PRES(%<MASTER_CLOCK_PRES>);
while((PMC_REGS->PMC_SR & PMC_SR_MCKRDY_Msk) == 0U) __NOP(); /* Wait for Master Clock to be ready */
/* Set Master Clock DIVIDER */
PMC_REGS->PMC_MCKR = (PMC_REGS->PMC_MCKR & (~PMC_MCKR_MDIV_Msk)) | PMC_MCKR_MDIV(%<MASTER_CLOCK_MDIV>);
while((PMC_REGS->PMC_SR & PMC_SR_MCKRDY_Msk) == 0U) __NOP(); /* Wait for Master Clock to be ready */
/* Set clock source for Master Clock */
PMC_REGS->PMC_MCKR = (PMC_REGS->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) | PMC_MCKR_CSS(%<CLOCK_SOURCE_FOR_MASTER_CLOCK>);
while((PMC_REGS->PMC_SR & PMC_SR_MCKRDY_Msk) == 0U) __NOP(); /* Wait for Master Clock to be ready */
%else 
/* ------------- Connect CLOCK SOURCE -------------------------- */
/* Set clock source for Master Clock */
PMC_REGS->PMC_MCKR = (PMC_REGS->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) | PMC_MCKR_CSS(%<CLOCK_SOURCE_FOR_MASTER_CLOCK>);
while((PMC_REGS->PMC_SR & PMC_SR_MCKRDY_Msk) == 0U) __NOP(); /* Wait for Master Clock to be ready */
/* Set Master Clock PRESCALER */
PMC_REGS->PMC_MCKR = (PMC_REGS->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | PMC_MCKR_PRES(%<MASTER_CLOCK_PRES>);
while((PMC_REGS->PMC_SR & PMC_SR_MCKRDY_Msk) == 0U) __NOP(); /* Wait for Master Clock to be ready */
/* Set Master Clock DIVIDER */
PMC_REGS->PMC_MCKR = (PMC_REGS->PMC_MCKR & (~PMC_MCKR_MDIV_Msk)) | PMC_MCKR_MDIV(%<MASTER_CLOCK_MDIV>);
while((PMC_REGS->PMC_SR & PMC_SR_MCKRDY_Msk) == 0U) __NOP(); /* Wait for Master Clock to be ready */
%endif
%switch ::ChipIdL1
%case "SAME"
%case "SAMS"
%if(TARGET_FREQUNECY <= 21000000)
%assign FlashWaitingStates = 0
%elseif (TARGET_FREQUNECY <= 42000000)
%assign FlashWaitingStates = 1
%elseif (TARGET_FREQUNECY <= 63000000)
%assign FlashWaitingStates = 2
%elseif (TARGET_FREQUNECY <= 84000000)
%assign FlashWaitingStates = 3
%elseif (TARGET_FREQUNECY <= 106000000)
%assign FlashWaitingStates = 4
%elseif (TARGET_FREQUNECY <= 125000000)
%assign FlashWaitingStates = 5
%elseif (TARGET_FREQUNECY <= 137000000)
%assign FlashWaitingStates = 6
%else
%assign FlashWaitingStates = 6 
%endif
%if FlashWaitingStates != 6
/* ------------- Optimize Wait State -------------------------- */
EFC_REGS->EEFC_FMR = EEFC_FMR_FWS(%<FlashWaitingStates>)|EEFC_FMR_CLOE_Msk; /* Update flash wait states - See DS60001527A-Table 59-51*/
%endif
%break
%case "SAMV"
%if(TARGET_FREQUNECY <= 23000000)
%assign FlashWaitingStates = 0
%elseif (TARGET_FREQUNECY <= 46000000)
%assign FlashWaitingStates = 1
%elseif (TARGET_FREQUNECY <= 69000000)
%assign FlashWaitingStates = 2
%elseif (TARGET_FREQUNECY <= 92000000)
%assign FlashWaitingStates = 3
%elseif (TARGET_FREQUNECY <= 115000000)
%assign FlashWaitingStates = 4
%elseif (TARGET_FREQUNECY <= 138000000)
%assign FlashWaitingStates = 5
%elseif (TARGET_FREQUNECY <= 150000000)
%assign FlashWaitingStates = 6
%else
%assign FlashWaitingStates = 6 
%endif
%if FlashWaitingStates != 6
/* ------------- Optimize Wait State -------------------------- */
EFC_REGS->EEFC_FMR = EEFC_FMR_FWS(%<FlashWaitingStates>)|EEFC_FMR_CLOE_Msk; /* Update flash wait states - See DS60001527A-Table 58-51*/
%endif
%break
%case "SAMRH"
%break
%default
%error("No wait state set for chip family " + ::ChipIdL1 )
%endswitch
/* ------------- Enable required peripheral clocks ------------- */
%switch ::ChipIdL1
%case "SAME"
%case "SAMS"
%case "SAMV"
%foreach k = 2
%assign PMC_REGS = 0
%foreach i = 32
%if ::MCHP_Clock_PMC_PCR[i+k*32] == 1
%assign PMC_REGS = PMC_REGS + ( 1 << i)
%endif
%endforeach
%if PMC_REGS != 0
PMC_REGS->PMC_PCER%<k> = %<MchpHex(PMC_REGS)>; /* Enable peripheral clocks derived from MCK for peripherals used */
%endif
%endforeach
%break
%case "SAMRH"
%foreach i = 128
%if ::MCHP_Clock_PMC_PCR[i] == 1
PMC_REGS->PMC_PCR = PMC_PCR_EN_Msk | PMC_PCR_CMD_Msk | PMC_PCR_PID(%<int(i)>); /* Enable peripheral clocks derived from MCK for peripherals  */
%endif
%endforeach
%break
%default
%error("No wait state set for chip family " + ::ChipIdL1 )
%endswitch
/* ------------------------ END of Clock Configuration ------------------------------  */
%<MCHP_ConfigPins()>
/* Initialize model */
%if ConfigChipOnly == 0
%<LibCallModelInitialize()> 	
%endif
/* ------- NVIC Setup ------ */
%assign TimeStep_SyncADC = CAST("Number",RTWGenSettings.TimeStep_SyncADC)
%if TimeStep_SyncADC == -1
%if CompiledModel.FixedStepOpts.SolverMode == "MultiTasking"
NVIC_SetPriority(SysTick_IRQn, 6u);     /* Scheduler Priority set to 6 */
NVIC_SetPriority(SVCall_IRQn, 0u);
__asm volatile (" SVC #1"); /* The SVC#1 exception will be triggered only once (before SysTick exception!) to ensure that processor can enter in Thread Mode when exceptions are active (see page 601 of ARMv7-M Architecture Reference Manual) */
%else
NVIC_SetPriority(SysTick_IRQn, 6u);     /* Scheduler Priority set to 6 */
%endif
NVIC_EnableIRQ(SysTick_IRQn);                               /*  Enable NVIC line for SysTick  */
%openfile LocalStartup_TrigTimeStepInstruction
%<::Startup_TrigTimeStepInstruction>\		 		
/* ------ SysTick  Init -----------  */
%assign SYS_TICK_TS_Load = CAST("Number",RTWGenSettings.SYS_TICK_TS_Load)
SysTick->VAL   =  1UL*8;								/*  Start value for the sys Tick counter. Execute first STEP ASAP */
SysTick->LOAD  =  %<SYS_TICK_TS_Load>UL;                                /*  Reload value (corresponds to 1s). This value will be decremented at each CPU tick */
SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk;   /*  Enable SysTick Interrupt; start the counter; select the source for tick (MCLK)   */
%closefile LocalStartup_TrigTimeStepInstruction
%assign ::Startup_TrigTimeStepInstruction = LocalStartup_TrigTimeStepInstruction
%else 
%openfile LocalStartup_TrigTimeStepInstruction
%<::Startup_TrigTimeStepInstruction>\		 		
%if CompiledModel.FixedStepOpts.SolverMode == "MultiTasking"
NVIC_SetPriority(TC0_CH0_IRQn, 6u);     /* Scheduler Priority set to 6 */
NVIC_SetPriority(SVCall_IRQn, 0u);
__asm volatile (" SVC #1"); /* The SVC#1 exception will be triggered only once (before SysTick exception!) to ensure that processor can enter in Thread Mode when exceptions are active (see page 601 of ARMv7-M Architecture Reference Manual) */
%else
%endif
NVIC_EnableIRQ(TC0_CH0_IRQn);                               /*  Enable NVIC line for TC0_CH0_IRQn  */	
%closefile LocalStartup_TrigTimeStepInstruction
%assign ::Startup_TrigTimeStepInstruction = LocalStartup_TrigTimeStepInstruction
%endif    	
%closefile tmpFcnOsc
%return tmpFcnOsc
%endfunction
%function int(x) void
%return CAST("Number",x)
%endfunction