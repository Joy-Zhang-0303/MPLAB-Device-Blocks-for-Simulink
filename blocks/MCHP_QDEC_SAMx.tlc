%implements MCHP_QDEC_SAMx  "C"
%include "MCHP_Functions.tlc"
%function Start(block, system) Output
%assign ChipIdL1 = CAST("String",RTWGenSettings.ChipIdL1)
%assign ChipIdL2 = CAST("String",RTWGenSettings.ChipIdL2)
%assign ChipIdL3 = CAST("String",RTWGenSettings.ChipIdL3)
%assign ChipIdN = MchpVector(RTWGenSettings.ChipIdN)
%assign QDEC_REF = CAST("String",block.RTWdata.QDEC_REF)
%assign TC_IDX = CAST("Number",block.RTWdata.TC_IDX)
%assign QDEC_MODE = CAST("String",block.RTWdata.QDEC_MODE)
%assign IDX_PIN = CAST("String",block.RTWdata.IDX_PIN)
%assign CH0_PID = CAST("Number",block.RTWdata.CH0_PID)
%assign CH1_PID = CAST("Number",block.RTWdata.CH1_PID)
%assign CH2_PID = CAST("Number",block.RTWdata.CH2_PID)
%assign CH0_PCER_IDX = CAST("Number",block.RTWdata.CH0_PCER_IDX)
%assign CH1_PCER_IDX = CAST("Number",block.RTWdata.CH1_PCER_IDX)
%assign CH2_PCER_IDX = CAST("Number",block.RTWdata.CH2_PCER_IDX)
%assign MAXFILT = CAST("Number",block.RTWdata.MAXFILT)
%assign MAXFILT_PERIOD = CAST("String",block.RTWdata.MAXFILT_PERIOD)
%assign MAXCMP = CAST("Number",block.RTWdata.MAXCMP)
%assign AUTOC = CAST("Number",block.RTWdata.AUTOC)
%assign INVA = CAST("Number",block.RTWdata.INVA)
%assign INVB = CAST("Number",block.RTWdata.INVB)
%assign INVIDX = CAST("Number",block.RTWdata.INVIDX)
%assign SWAP = CAST("Number",block.RTWdata.SWAP)
%assign POSITION_RESET_MODE = CAST("String",block.RTWdata.POSITION_RESET_MODE)
%assign POSITION_RESET_MODE_INPUT = CAST("Number",block.RTWdata.POSITION_RESET_MODE_INPUT)
%assign POSITION_RESET_MODE_EDGE = CAST("Number",block.RTWdata.POSITION_RESET_MODE_EDGE)
%openfile buffer
#define MCHP_TC_BMR_AUTOC_Pos                    (18U)                                              /**< (TC_BMR) AutoCorrection Position */
#define MCHP_TC_BMR_AUTOC_Msk                    (0x1U << MCHP_TC_BMR_AUTOC_Pos)                    /**< (TC_BMR) AutoCorrection Mask */
#define MCHP_TC_BMR_AUTOC(value)                 (MCHP_TC_BMR_AUTOC_Msk & ((value) << MCHP_TC_BMR_AUTOC_Pos))
#define MCHP_TC_BMR_MAXCMP_Pos                   (26U)                                              /**< (TC_BMR) Maximum Consecutive Missing Pulses Position */
#define MCHP_TC_BMR_MAXCMP_Msk                   (0xFU << MCHP_TC_BMR_MAXCMP_Pos)                   /**< (TC_BMR) Maximum Consecutive Missing Pulses Mask */
#define MCHP_TC_BMR_MAXCMP(value)                (MCHP_TC_BMR_MAXCMP_Msk & ((value) << MCHP_TC_BMR_MAXCMP_Pos))
#define MCHP_TC_QISR_MPE_Pos                     (3U)                                               /**< (TC_QISR) Direction Position */
#define MCHP_TC_QISR_MPE_Msk                     (0x1U << TC_QISR_DIR_Pos)                          /**< (TC_QISR) Direction Mask */
%closefile buffer
%<LibCacheExtern(buffer)>
/*================= Initialize QDEC Peripheral (TC%<TC_IDX>) =================*/
{
uint32_T MCHP_BMR_reg = 0;          /* temporary variable to store BMR data */
uint32_T MCHP_CMR_CH0_reg = 0;      /* temporary variable to store CH0 configuration */
uint32_T MCHP_CMR_CH1_reg = 0;      /* temporary variable to store CH1 configuration */
uint32_T MCHP_CMR_CH2_reg = 0;      /* temporary variable to store CH2 configuration */
PMC_REGS->PMC_PCER%<CH0_PCER_IDX> |= PMC_PCER%<CH0_PCER_IDX>_PID%<CH0_PID>(1u);         /* Enable TC%<TC_IDX> CH0 clock */
PMC_REGS->PMC_PCER%<CH1_PCER_IDX> |= PMC_PCER%<CH1_PCER_IDX>_PID%<CH1_PID>(1u);         /* Enable TC%<TC_IDX> CH1 clock */
%if ISEQUAL(QDEC_MODE, "Speed")
PMC_REGS->PMC_PCER%<CH2_PCER_IDX> |= PMC_PCER%<CH2_PCER_IDX>_PID%<CH2_PID>(1u);     /* Enable TC%<TC_IDX> CH2 clock */
%endif
MCHP_BMR_reg |= TC_BMR_QDEN(1u);                                /* Enable Quadrature Decoder on TC%<TC_IDX> */
MCHP_BMR_reg |= TC_BMR_EDGPHA(1u);                              /* Edges are detected on both PHA and PHB */
%if MAXFILT > 0
MCHP_BMR_reg |= TC_BMR_MAXFILT(%<MAXFILT>u);                    /* Maximum Filter period: %<MAXFILT_PERIOD> */
%endif
%if MAXCMP > 0
MCHP_BMR_reg |= MCHP_TC_BMR_MAXCMP(%<MAXCMP>u);                 /* Define the number of consecutive missing pulses before a flag report */
%endif
%if AUTOC > 0
MCHP_BMR_reg |= MCHP_TC_BMR_AUTOC(%<AUTOC>u);                   /* AutoCorrection of missing pulses (0-Disabled, 1-Enabled) */
%endif
%if INVA > 0
MCHP_BMR_reg |= TC_BMR_INVA(%<INVA>u);                          /* Inverted PHA (0-Disabled, 1-Enabled) */
%endif
%if INVB > 0
MCHP_BMR_reg |= TC_BMR_INVB(%<INVB>u);                          /* Inverted PHB (0-Disabled, 1-Enabled) */
%endif
%if INVIDX > 0
MCHP_BMR_reg |= TC_BMR_INVIDX(%<INVIDX>u);                      /* Inverted Index (0-Disabled, 1-Enabled) */
%endif
%if SWAP > 0
MCHP_BMR_reg |= TC_BMR_SWAP(%<SWAP>u);                          /* Swap PHA and PHB (0-Disabled, 1-Enabled) */
%endif
MCHP_CMR_CH0_reg  |=  TC_CMR_WAVE(0u);           /* Set TC%<TC_IDX> CH0 to Capture Mode */
MCHP_CMR_CH0_reg  |=  TC_CMR_TCCLKS(5u);         /* Select XC0 as input for TC%<TC_IDX> CH0 (Speed/Position)*/
MCHP_CMR_CH1_reg  |=  TC_CMR_WAVE(0u);           /* Set TC%<TC_IDX> CH1 to Capture Mode */
MCHP_CMR_CH1_reg  |=  TC_CMR_TCCLKS(5u);         /* Select XC0 as input for TC%<TC_IDX> CH1 (IDX) */
MCHP_CMR_CH2_reg |= TC_CMR_WAVE_Msk;                /* mode Waveform*/
MCHP_CMR_CH2_reg |= TC_CMR_WAVEFORM_EEVTEDG_FALLING; /* Falling edge (2u) */
%if ISEQUAL(QDEC_MODE, "Position")
%assign POSITION_RESET_MODE = CAST("String",block.RTWdata.POSITION_RESET_MODE)
/* Configure QDEC for 'Position' measurement mode */
MCHP_BMR_reg |=  TC_BMR_POSEN(1u);          /* Enable the position measurement on channel 0 */
MCHP_BMR_reg |=  TC_BMR_SPEEDEN(0u);        /* Disable the speed measurement on channel 0 */
%if ISEQUAL(POSITION_RESET_MODE, "at user defined value")
%assign POSITION_RESET_VALUE = CAST("Number",block.RTWdata.POSITION_RESET_VALUE)
TC%<TC_IDX>_REGS->TC_CHANNEL[0].TC_RC = %<POSITION_RESET_VALUE>u;       /* Define value that will reset CH0 Counter (Absolute Position) */
MCHP_CMR_CH0_reg  |= TC_CMR_CAPTURE_CPCTRG_Msk;                                 /* Enable RC Compare Trigger (RC Compare resets CH0 counter and starts the counter clock) */
%endif
%if ISEQUAL(POSITION_RESET_MODE, "on each IDX signal")
MCHP_CMR_CH0_reg  |= TC_CMR_CAPTURE_ABETRG(1u);    /* TIOAx must be selected as the External Trigger for CH0 */
%switch POSITION_RESET_MODE_EDGE
%case 1
MCHP_CMR_CH0_reg  |= TC_CMR_CAPTURE_ETRGEDG_RISING;   /* Rising edge is selected as the External Trigger Edge for CH0 */
%break
%case 2
MCHP_CMR_CH0_reg  |= TC_CMR_CAPTURE_ETRGEDG_FALLING;   /* Falling edge is selected as the External Trigger Edge for CH0 */
%break
%endswitch
%endif
%else
%assign CH2_TCCLKS = CAST("Number",block.RTWdata.CH2_TCCLKS)
%assign SPEED_TIME_BASE = CAST("String",block.RTWdata.SPEED_TIME_BASE)
/* Configure QDEC for 'Speed' measurement mode */
MCHP_BMR_reg |= TC_BMR_POSEN(0u);              /* Disable the position measurement on channel 0 */
MCHP_BMR_reg |= TC_BMR_SPEEDEN(1u);            /* Enable the speed measurement on channel 0 */
/* Setup CH2 (base time for speed measurement) */
TC%<TC_IDX>_REGS->TC_CHANNEL[2].TC_CMR  |= (TC%<TC_IDX>_REGS->TC_CHANNEL[2].TC_CMR & (~TC_CMR_WAVE_Msk))   | TC_CMR_WAVE(1u);       /* Set TC%<TC_IDX> CH2 to Wave Mode */
TC%<TC_IDX>_REGS->TC_CHANNEL[2].TC_CMR  |= (TC%<TC_IDX>_REGS->TC_CHANNEL[2].TC_CMR & (~TC_CMR_WAVEFORM_WAVSEL_Msk)) | TC_CMR_WAVEFORM_WAVSEL(2u);     /* Clear the CH2 counter by comparison and matching with TC_RC value. */
TC%<TC_IDX>_REGS->TC_CHANNEL[2].TC_RC  = 0xFFFFu;                                       /* Load CH2 RC with maximum value  */
MCHP_CMR_CH2_reg  |= TC_CMR_WAVEFORM_ACPC(3u);         /* RC Compare Effect on TIOAx: Toggle TIOAx*/
MCHP_CMR_CH2_reg  |= TC_CMR_TCCLKS(%<CH2_TCCLKS>u); /* CH2 time base for speed measurement: %<SPEED_TIME_BASE> */
/* Setup CH0 (Speed) to be cleared by a TIOA0 event generated by CH2 */
MCHP_CMR_CH0_reg  |=  TC_CMR_CAPTURE_ABETRG(1u);     /* TIOAx must be selected as the External Trigger for CH0 */
MCHP_CMR_CH0_reg  |=  TC_CMR_CAPTURE_ETRGEDG(1u);    /* Rising edge is selected as the External Trigger Edge for CH0 */
MCHP_CMR_CH0_reg  |=  TC_CMR_CAPTURE_LDRA(1u);         /* Load TC_RA0 at the same time as the counter is cleared */
MCHP_CMR_CH0_reg  |=  TC_CMR_CAPTURE_LDRB(1u);         /* Load TC_RB0 at the same time as the counter is cleared */
%endif 
/* Load Channels configuration values into TC%<TC_IDX> registers */
TC%<TC_IDX>_REGS->TC_BMR = MCHP_BMR_reg;                        /* Write setup into BMR Register */
TC%<TC_IDX>_REGS->TC_CHANNEL[0].TC_CMR = MCHP_CMR_CH0_reg;      /* Write CH0 confguration */
TC%<TC_IDX>_REGS->TC_CHANNEL[1].TC_CMR = MCHP_CMR_CH1_reg;      /* Write CH1 confguration */
TC%<TC_IDX>_REGS->TC_CHANNEL[2].TC_CMR = MCHP_CMR_CH2_reg;      /* Write CH2 confguration */
}
/* Enable Channels clocks */
TC%<TC_IDX>_REGS->TC_CHANNEL[0].TC_CCR  |= TC_CCR_CLKEN(1u);        /* Enable CH0 clock (PHA,PHB - Position/Speed) */
%if !ISEQUAL(IDX_PIN, "not used")
TC%<TC_IDX>_REGS->TC_CHANNEL[1].TC_CCR  |= TC_CCR_CLKEN(1u);    /* Enable CH1 clock (IDX) */
%endif
%if ISEQUAL(QDEC_MODE, "Speed")
TC%<TC_IDX>_REGS->TC_CHANNEL[2].TC_CCR  |= TC_CCR_CLKEN(1u);    /* Enable CH2 clock (Base time) */
%endif
TC%<TC_IDX>_REGS->TC_BCR = TC_BCR_SYNC(1u);      /* Assert the SYNC signal which generates a software trigger simultaneously for each of the channels */
%endfunction
%function Outputs(block, system) Output
%assign QDEC_REF = CAST("String",block.RTWdata.QDEC_REF)
%assign TC_IDX = CAST("Number",block.RTWdata.TC_IDX)
%assign QDEC_MODE = CAST("String",block.RTWdata.QDEC_MODE)
%assign IDX_PIN = CAST("String",block.RTWdata.IDX_PIN)
%assign INDEX_OUTPUT = CAST("Number",block.RTWdata.INDEX_OUTPUT)
%assign DIR_OUTPUT = CAST("Number",block.RTWdata.DIR_OUTPUT)
%assign DIRCHG_OUTPUT = CAST("Number",block.RTWdata.DIRCHG_OUTPUT)
%assign MPE_OUTPUT = CAST("Number",block.RTWdata.MPE_OUTPUT)
%assign QERR_OUTPUT = CAST("Number",block.RTWdata.QERR_OUTPUT)
%assign IndexOutput = 0
%assign IndexInput = 0
%if ISEQUAL(IDX_PIN, "not used") && (INDEX_OUTPUT != 0)
%<LibBlockReportError(block, "IDX Counter is a block output but there is no IDX pin selected. Please select an IDX pin")>
%endif
%if ISEQUAL(QDEC_MODE, "Position")
%assign POSITION_RESET_MODE = CAST("String",block.RTWdata.POSITION_RESET_MODE)
%assign POSITION_OUTPUT = CAST("Number",block.RTWdata.POSITION_OUTPUT)
%assign RESET_INPUT = CAST("Number",block.RTWdata.RESET_INPUT)
%if ISEQUAL(IDX_PIN, "not used") && ISEQUAL(POSITION_RESET_MODE, "on each IDX signal")
%<LibBlockReportError(block, "IDX signal is set to reset the Position Counter but there is no IDX Pin selected. Please select an IDX pin")>
%endif
%if !ISEQUAL(IDX_PIN, "not used") && ( !ISEQUAL(POSITION_RESET_MODE, "on each IDX signal") && (INDEX_OUTPUT == 0) )
%<LibBlockReportWarning(block, "IDX pin selected but not used")>
%endif
%if POSITION_OUTPUT != 0
%assign POSITION_OUTPUT_SIGNAL = LibBlockOutputSignal(IndexOutput, "", "",0)
%assign IndexOutput = IndexOutput + 1
%endif
%if INDEX_OUTPUT != 0
%assign INDEX_OUTPUT_SIGNAL = LibBlockOutputSignal(IndexOutput, "", "",0)
%assign IndexOutput = IndexOutput + 1
%endif
%if RESET_INPUT == 1
%assign RESET_INPUT_SIGNAL = LibBlockInputSignal(IndexInput, "", "",0)
%assign IndexInput = IndexInput + 1
if (%<RESET_INPUT_SIGNAL> == 0) {
%if POSITION_OUTPUT != 0
%<POSITION_OUTPUT_SIGNAL> = TC%<TC_IDX>_REGS->TC_CHANNEL[0].TC_CV;      /* Read QDEC Position Counter (CH0) */
%endif
%if INDEX_OUTPUT != 0
%<INDEX_OUTPUT_SIGNAL> = TC%<TC_IDX>_REGS->TC_CHANNEL[1].TC_CV;         /* Read QDEC Index Counter (CH1) */
%endif
} else { 
%if POSITION_OUTPUT != 0
%<POSITION_OUTPUT_SIGNAL> = 0;     /* Reset Position Counter (CH0) */
%endif
%if INDEX_OUTPUT != 0
%<INDEX_OUTPUT_SIGNAL> = 0;        /* Reset Index Counter (CH1) */
%endif
TC%<TC_IDX>_REGS->TC_BCR = TC_BCR_SYNC(1);         /* Assert the SYNC signal which generates a software trigger simultaneously for each of the channels */
}
%else
%if POSITION_OUTPUT != 0
%<POSITION_OUTPUT_SIGNAL> = TC%<TC_IDX>_REGS->TC_CHANNEL[0].TC_CV;      /* Read QDEC Position Counter (CH0) */
%endif
%if INDEX_OUTPUT != 0
%<INDEX_OUTPUT_SIGNAL> = TC%<TC_IDX>_REGS->TC_CHANNEL[1].TC_CV;         /* Read QDEC Index Counter (CH1) */
%endif
%endif
%else
%assign SPEED_OUTPUT = CAST("Number",block.RTWdata.SPEED_OUTPUT)
%if !ISEQUAL(IDX_PIN, "not used")  &&  (INDEX_OUTPUT == 0)
%<LibBlockReportWarning(block, "IDX pin selected but not used")>
%endif
%if SPEED_OUTPUT != 0
%assign SPEED_OUTPUT_SIGNAL = LibBlockOutputSignal(IndexOutput, "", "",0)
%assign IndexOutput = IndexOutput + 1
%endif
%if INDEX_OUTPUT != 0
%assign INDEX_OUTPUT_SIGNAL = LibBlockOutputSignal(IndexOutput, "", "",0)
%assign IndexOutput = IndexOutput + 1
%endif
%if SPEED_OUTPUT != 0
%<SPEED_OUTPUT_SIGNAL> = TC%<TC_IDX>_REGS->TC_CHANNEL[0].TC_RA;     /* Read QDEC Speed (CH0->RA) */
%endif
%if INDEX_OUTPUT != 0
%<INDEX_OUTPUT_SIGNAL> = TC%<TC_IDX>_REGS->TC_CHANNEL[1].TC_CV;     /* Read QDEC Index Counter (CH1) */
%endif
%endif
%if (DIR_OUTPUT != 0) || (DIRCHG_OUTPUT != 0) || (MPE_OUTPUT != 0) || (QERR_OUTPUT != 0)
{
uint32_T reg_TC_QISR = TC%<TC_IDX>_REGS->TC_QISR; /* Read once TC_QISR */
%if DIR_OUTPUT != 0
%assign DIR_OUTPUT_SIGNAL = LibBlockOutputSignal(IndexOutput, "", "",0)
%assign IndexOutput = IndexOutput + 1
%<DIR_OUTPUT_SIGNAL> = (reg_TC_QISR & TC_QISR_DIR_Msk) >> TC_QISR_DIR_Pos;    /* Get direction (DIR) status */
%endif
%if DIRCHG_OUTPUT != 0
%assign DIRCHG_OUTPUT_SIGNAL = LibBlockOutputSignal(IndexOutput, "", "",0)
%assign IndexOutput = IndexOutput + 1
%<DIRCHG_OUTPUT_SIGNAL> = (reg_TC_QISR & TC_QISR_DIRCHG_Msk) >> TC_QISR_DIRCHG_Pos;   /* Get direction change (DIRCHG) status */
%endif
%if MPE_OUTPUT != 0
%assign MPE_OUTPUT_SIGNAL = LibBlockOutputSignal(IndexOutput, "", "",0)
%assign IndexOutput = IndexOutput + 1
%<MPE_OUTPUT_SIGNAL> = (reg_TC_QISR & MCHP_TC_QISR_MPE_Msk) >> MCHP_TC_QISR_MPE_Pos;    /* Get Consecutive Missing Pulse Error (MPE) status */
%endif
%if QERR_OUTPUT != 0
%assign QERR_OUTPUT_SIGNAL = LibBlockOutputSignal(IndexOutput, "", "",0)
%assign IndexOutput = IndexOutput + 1
%<QERR_OUTPUT_SIGNAL> = (reg_TC_QISR & TC_QISR_QERR_Msk) >> TC_QISR_QERR_Pos; /* Get Quadrature Error (QERR) status */
%endif
}
%endif
%endfunction
%function Update(block, system) Output
%assign ChipIdL1 = CAST("String",RTWGenSettings.ChipIdL1)
%assign ChipIdL2 = CAST("String",RTWGenSettings.ChipIdL2)
%assign ChipIdL3 = CAST("String",RTWGenSettings.ChipIdL3)
%assign ChipIdN = MchpVector(RTWGenSettings.ChipIdN)
%assign QDEC_REF = CAST("String",block.RTWdata.QDEC_REF)
%assign TC_IDX = CAST("Number",block.RTWdata.TC_IDX)
%assign QDEC_MODE = CAST("String",block.RTWdata.QDEC_MODE)
%assign IDX_PIN = CAST("String",block.RTWdata.IDX_PIN)
%assign CH0_PID = CAST("Number",block.RTWdata.CH0_PID)
%assign CH1_PID = CAST("Number",block.RTWdata.CH1_PID)
%assign CH2_PID = CAST("Number",block.RTWdata.CH2_PID)
%assign CH0_PCER_IDX = CAST("Number",block.RTWdata.CH0_PCER_IDX)
%assign CH1_PCER_IDX = CAST("Number",block.RTWdata.CH1_PCER_IDX)
%assign CH2_PCER_IDX = CAST("Number",block.RTWdata.CH2_PCER_IDX)
%assign MAXFILT = CAST("Number",block.RTWdata.MAXFILT)
%assign MAXFILT_PERIOD = CAST("String",block.RTWdata.MAXFILT_PERIOD)
%assign MAXCMP = CAST("Number",block.RTWdata.MAXCMP)
%assign AUTOC = CAST("Number",block.RTWdata.AUTOC)
%assign INVA = CAST("Number",block.RTWdata.INVA)
%assign INVB = CAST("Number",block.RTWdata.INVB)
%assign INVIDX = CAST("Number",block.RTWdata.INVIDX)
%assign SWAP = CAST("Number",block.RTWdata.SWAP)
%if ISEQUAL(QDEC_MODE, "Position")
%assign POSITION_RESET_MODE = CAST("String",block.RTWdata.POSITION_RESET_MODE)
%assign POSITION_OUTPUT = CAST("Number",block.RTWdata.POSITION_OUTPUT)
%assign RESET_INPUT = CAST("Number",block.RTWdata.RESET_INPUT)
%assign POSITION_RESET_MODE_INPUT = CAST("Number",block.RTWdata.POSITION_RESET_MODE_INPUT)
%assign POSITION_RESET_MODE_EDGE = CAST("Number",block.RTWdata.POSITION_RESET_MODE_EDGE)
%assign IndexInput = 0
%if RESET_INPUT == 1
%assign IndexInput = IndexInput + 1
%endif
%if POSITION_RESET_MODE_INPUT == 1
%assign POSITION_RESET_MODE_INPUT_SIGNAL = LibBlockInputSignal(IndexInput, "", "",0)
{
uint32_T MCHP_CMR_CH0_reg = 0;      /* temporary variable to store CH0 configuration */
MCHP_CMR_CH0_reg  |=  TC_CMR_WAVE(0u);           /* Set TC%<TC_IDX> CH0 to Capture Mode */
MCHP_CMR_CH0_reg  |=  TC_CMR_TCCLKS(5u);         /* Select XC0 as input for TC%<TC_IDX> CH0 (Speed/Position)*/
%if ISEQUAL(POSITION_RESET_MODE, "on each IDX signal")  
MCHP_CMR_CH0_reg  |= TC_CMR_CAPTURE_ABETRG(1u);    /* TIOAx must be selected as the External Trigger for CH0 */
%endif
if (%<POSITION_RESET_MODE_INPUT_SIGNAL> != 0)
MCHP_CMR_CH0_reg  |= TC_CMR_CAPTURE_ETRGEDG_RISING;   /* Rising edge is selected as the External Trigger Edge for CH0 */
else
MCHP_CMR_CH0_reg  |= TC_CMR_CAPTURE_ETRGEDG_FALLING;   /* Falling edge is selected as the External Trigger Edge for CH0 */
TC%<TC_IDX>_REGS->TC_CHANNEL[0].TC_CMR = MCHP_CMR_CH0_reg;      /* Write CH0 confguration */
}
%endif
%endif
%endfunction
