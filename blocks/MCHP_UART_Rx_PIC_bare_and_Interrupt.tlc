
%include "MCHP_Fct_FastMemCpy_dsPIC.tlc"
%function MCHP_UART_Rx_bare(block,system) Output
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%assign UART_NAME = "UART%<UARTRef>"
/* Bare implementation for %<UART_NAME> */
%<MCHP_UART_Rx_bare_and_interrupt(block,system)>
%endfunction
%function MCHP_UART_Rx_Interrupt(block,system) Output
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%assign UART_NAME = "UART%<UARTRef>"
/* Circular Buffer implementation for %<UART_NAME> */
/* Circular Buffer implementation for %<UART_NAME> */	
%<MCHP_UART_Rx_bare_and_interrupt(block,system)>
%endfunction
%function MCHP_UART_Rx_bare_and_interrupt(block,system) Output
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%assign UART_NAME = "UART%<UARTRef>"
%assign FlagOut = CAST("Number",block.RTWdata.FlagOut)
%assign Split = CAST("Number",block.RTWdata.Split)
%assign FillIn = CAST("Number",block.RTWdata.FillIn)
/% Split:
-1 means no
other value means stop reading buffer when this value occurence
FillIn:
-1: Fill in with latest value read
-2: do nothing
-3: Add one trailing 0 (only when output is a vector of size > 1)
other positive value: default value for FillIn
%/
%assign RX_IMPLEMENTATION = MchpVector(RTWGenSettings.UART_RX_IMPLEMENTATION)
%assign RX_IMPLEMENTATION = RX_IMPLEMENTATION[UARTRef-1]		
%if (RX_IMPLEMENTATION > 1)
%assign RX_BufferPtrType = CAST( "String","uint_T")
%endif
%assign ChipIdL1 = CAST("String",RTWGenSettings.ChipIdL1)
%assign ChipIdL2 = CAST("String",RTWGenSettings.ChipIdL2)
%assign ChipIdL3 = CAST("String",RTWGenSettings.ChipIdL3)
%assign UART_HALF_DUPLEX_MODE = MchpVector(RTWGenSettings.UART_HALF_DUPLEX_MODE)
%assign UART_HALF_DUPLEX_MODE = UART_HALF_DUPLEX_MODE[UARTRef-1]
{ /* Start of Rx reception block */
%if (FillIn == -1)
static uint8_T %<UART_NAME>LastValue ;
%endif
%if FlagOut == 1
unsigned int n = 0;
%endif
%if RX_IMPLEMENTATION == 2	
%<UART_Rx_CircularBuffer_flushBuffer(block)>
%endif
%if (FlagOut == 1)	
%assign yF = LibBlockOutputSignal(0, "", "", 0)				  	
%endif
%assign OutLength = LibBlockOutputSignalWidth(%<FlagOut + 0>)
%if (OutLength == 1) && (FillIn == -3)	
%warning("Add one 0 to the UART Rx output is not possible when Rx output is a scalar. Output value will be received value if any, 0 otherwise.")
%assign FillIn = 0			
%endif
%if (FillIn == -3)
%assign OutLength = OutLength - 1	
%endif
%if (OutLength > ::FastMemCpyThreshold)  && (RX_IMPLEMENTATION == 2) && (Split == -1) && ( (FillIn == -2) || (FillIn == -3) )	
%assign y0 = LibBlockOutputSignalAddr( %<FlagOut + 0>, "","", 0)
{
int_T i1 = 0;
uint8_T *y0 = %<y0>;
%assign y = "y0[i1]"
%<RX_BufferPtrType> Tmp;
uint_T Tmp2;			
Tmp = (MCHP_%<UART_NAME>_Rx.tail - MCHP_%<UART_NAME>_Rx.head);		/* tail - head */
Tmp = Tmp & (Rx_BUFF_SIZE_%<UART_NAME> - 1);						/* Modulo Buffer Size (Buffer Size is 2^n). Tmp is the buffer used space */		
if (Tmp > 0) /* Anything to receive ? */
{
if (Tmp > %<OutLength>) /* If circular buffer contains more new data than requested, then */
Tmp = %<OutLength>;	/* read only the first %<OutLength> bytes available in the circular buffer */
Tmp2 = MCHP_%<UART_NAME>_Rx.head + Tmp;
if (Tmp2 > (Rx_BUFF_SIZE_%<UART_NAME>))	/* do we reach end of buffer ? */
{ 	
/* Yes, Read buffer until roll-off */
uint_T Tmp3 =   Rx_BUFF_SIZE_%<UART_NAME> - MCHP_%<UART_NAME>_Rx.head;
%<FastMemCpy("&(%<y>)" , "& MCHP_%<UART_NAME>_Rx.buffer[MCHP_%<UART_NAME>_Rx.head]" , "Tmp3")> 		
i1 = Tmp3; /* update destination index after First packet sent */				
Tmp2 = Tmp - Tmp3;			/* Then Read first part of buffer */				
%<FastMemCpy("&(%<y>)" , "& MCHP_%<UART_NAME>_Rx.buffer[0]" , "Tmp2")>	
} else /* No buffer wrap. Fill-in buffer */
{
%<FastMemCpy("&(%<y>)" , "& MCHP_%<UART_NAME>_Rx.buffer[MCHP_%<UART_NAME>_Rx.head]" , "Tmp")>	
}					
%if (FillIn == -3)
i1 = Tmp;	/* update index */		
%<y> = 0;	/* add one trailing 0. */			 		
%endif
MCHP_%<UART_NAME>_Rx.head = (MCHP_%<UART_NAME>_Rx.head + Tmp) & (Rx_BUFF_SIZE_%<UART_NAME>-1);
%if FlagOut == 1	
n = Tmp;
%endif
} else /* end of if (Tmp > 0) : Anything to receive ? */			
{
if ( U%<UARTRef>STAbits.OERR )
U%<UARTRef>STAbits.OERR = 0;	/* Clear UART Rx Overload Error */							
}
}	
%else 
%assign ForLoop_OutLength = OutLength
%if (FillIn == -3)
%assign ForLoop_OutLength = OutLength - 1	
%endif	
%if ForLoop_OutLength > 1
{ /* Fill-in buffer */
int_T i1;
%assign y0 = LibBlockOutputSignalAddr( %<FlagOut + 0>, "","", 0)
uint8_T *y0 = %<y0> ;
for (i1 = 0; i1 < %<ForLoop_OutLength> ; i1++) {
%assign y = "y0[i1]"
%else
%assign y = LibBlockOutputSignal( %<FlagOut + 0>, "", "", 0)
%endif
%if RX_IMPLEMENTATION == 1			
if %<URXNotEmpty(block)> /* Buffer not empty */
{
%<y> = %<UART_Rx_ReadRegister(block)>;      /* Read one received byte  */	  	
%else								
if(MCHP_%<UART_NAME>_Rx.tail != MCHP_%<UART_NAME>_Rx.head)	
{
%<y> = (uint8_T) MCHP_%<UART_NAME>_Rx.buffer[MCHP_%<UART_NAME>_Rx.head];      /* Use only the 8 low bytes or RxReg */
MCHP_%<UART_NAME>_Rx.head = (MCHP_%<UART_NAME>_Rx.head+1) & (Rx_BUFF_SIZE_%<UART_NAME> - 1);
%endif
%if (FlagOut == 1)
n += 1; /* Number of character received */
%endif
%if (Split != -1) && (ForLoop_OutLength > 1)
if (%<y> == %<Split>) {
i1++;
break; /* Exit loop on first occurence of %<Split> encountered */
}
%endif
%if ((Split != -1) && (ForLoop_OutLength <= 1)) && ( (FillIn == -1) )
if (%<y> != %<Split>) {	 
%endif
%if (FillIn == -1)
%<UART_NAME>LastValue = %<y>;
%endif
%if ((Split != -1) && (ForLoop_OutLength == 1) ) && ( (FillIn == -1) )	
} 
%endif
} else	{	 /* Buffer is empty */
%<UART_Rx_TestAndClearErrors(block)>
%if ForLoop_OutLength == 1
%switch FillIn
%case -1 	
%<y> = %<UART_NAME>LastValue; /* Rx buffer empty. fill-in output vector with repeated last value */
%break
%case -2			
%break
%case -3			
%<y> = 0; /* add one trailing 0 if nothing received */
%break			
%default							
%<y> = %<FillIn>; /* Rx buffer empty. Fill-in output vector with given value */
%break
%endswitch		
%else
break;	/* Break loop if buffer is empty */
%endif			
}
%if ForLoop_OutLength > 1
} /* end for loop */
%endif
%if (ForLoop_OutLength > 1)
%switch FillIn
%case -1 
for (; i1 < %<ForLoop_OutLength> ; i1++) {
%<y> = %<UART_NAME>LastValue; /* Rx buffer empty. fill-in output vector with repeated last value */
}
%break
%case -2			
%break
%case -3			
%<y> = 0;	/* add one trailing 0 if nothing received */
%break			
%default							
for (; i1 < %<ForLoop_OutLength> ; i1++) {
%<y> = %<FillIn>; /* Rx buffer empty. Fill-in output vector with given value */
}
%break
%endswitch				
%else  
%if ((OutLength == 2) && (FillIn == -3))	
%assign y = LibBlockOutputSignal( %<FlagOut + 0>, "", "", 1)
%<y> = 0;	/* add one trailing 0. It might be duplicated */
%endif
%endif
%if ForLoop_OutLength > 1
} /* end code-block to fill-in buffer */
%endif
%endif 
%if (FlagOut == 1)
%<yF> = n; /* Number of char received */
%endif
} /* end of Rx reception block */
%endfunction