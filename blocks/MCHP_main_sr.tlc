%selectfile NULL_FILE
%include "MCHP_Functions.tlc"
%function FcnSingleTaskingMain() void
%<LibWriteToStandardOutput("--- Single Tasking implementation ---")>
%switch MCHP_SchedulerTaskOverload
%case "Skip"
%case "Delay"
%warning Scheduler Option %<MCHP_SchedulerTaskOverload> is not available for a single tasking solver. Default Scheduler Queue tasks on overload.
%break
%case "Queue"
%break
%endswitch
%assign ::MASTER_BusyFlag = CAST("Number",RTWGenSettings.MASTER_BusyFlag)
%assign POWERSAVE = CAST("Number",RTWGenSettings.POWERSAVE)
%assign TimeStep_Timer = CAST("Number",RTWGenSettings.TimeStep_Timer)
%assign TimeStep_SyncADC = CAST("Number",RTWGenSettings.TimeStep_SyncADC)
%assign nTIMERS = CAST("Number",RTWGenSettings.nTIMERS)
%assign nSCCP = CAST("Number",RTWGenSettings.nSCCP)
%assign ChipIdL1 = CAST("String",RTWGenSettings.ChipIdL1)
%assign ChipIdL2 = CAST("String",RTWGenSettings.ChipIdL2)
%assign ChipIdL3 = CAST("String",RTWGenSettings.ChipIdL3)
%assign ChipIdN = MchpVector(RTWGenSettings.ChipIdN)
%if GenerateSampleERTMain
%assign ::CompiledModel.GenerateSampleERTMain = TLC_FALSE
%warning Overriding example ert_main.c!
%endif
%if TimeStep_Timer <= nTIMERS 
%assign idxT = TimeStep_Timer
%assign TimerName = "TIMER %<idxT>"
%assign intPrefix = "T"
%else 
%assign idxT = TimeStep_Timer - nTIMERS
%assign TimerName = "CCP TIMER %<idxT>"
%assign intPrefix = "CCP"
%endif
%openfile tmpBuf
%<SLibDeclareFcnProtoCtlVariables()>\
%<LibWriteModelData()>
%closefile tmpBuf
%<SLibCacheCodeToFile("mainSrc_data_defn", tmpBuf)>
%openfile tmpBuf
%if ExtMode
#include <ext_work.h>          /* External mode header files */
#include <ext_svr.h>
#include <ext_share.h>
#include <updown.h>
%endif
%closefile tmpBuf
%<SLibCacheCodeToFile("mainSrc_incl", tmpBuf)>
%openfile tmpBuf
%if TimeStep_SyncADC == -1  
%switch ::CORE
%case "PIC"
%assign tmp = Mchp_Interrupt16(2,"__auto_psv__","%<intPrefix>%<idxT>Interrupt",[])        
%assign fcnReturns = "void __attribute__((__interrupt__,__auto_psv__))"      
%assign fcnName = "_%<intPrefix>%<idxT>Interrupt"
%break
%case  "PIC32"          
%assign tmp = Mchp_Interrupt32(2,0,1,"TIMER_%<TimeStep_Timer>_VECTOR",[])       
%switch ::MCHP_MCU_NbrShadowRegisterSet
%case 2
%assign fcnReturns = "void __attribute__((interrupt(IPL2SOFT), vector(_TIMER_%<TimeStep_Timer>_VECTOR))) "      
%break
%case 8
%default
%assign fcnReturns = "void __attribute__((interrupt(IPL2SOFT), vector(_TIMER_%<TimeStep_Timer>_VECTOR))) "      
%break
%endswitch
%assign fcnName = "_T%<TimeStep_Timer>Interrupt"
%break
%case "CORTEX_M7"
%case "CORTEX_M4F"
%case "CORTEX_M0p"
%assign tmp = Mchp_Interrupt_ARM(1,"SysTick",[])       
%assign  fcnReturns = "void"
%assign fcnName = "SysTick_Handler"
%break
%endswitch
%assign fcnParams = "void"
%assign fcnCategory = "main"
%createrecord fcnRec {Name fcnName; Returns fcnReturns; Params fcnParams; ...
Abstract "Scheduler"; Category fcnCategory; GeneratedBy "MCHP_main_sr.tlc"; ...
Type "Main"}
%<SLibDumpFunctionBanner(fcnRec)>
%undef fcnRec
%<fcnReturns> %<fcnName>(%<fcnParams>)
{
%<MCHP_ProfileMCU("enter")>        
%<MCHP_Scheduler(intPrefix,idxT,ChipIdN)>
%<MCHP_ProfileMCU("exitUpdate")>
}
%endif
%assign fcnReturns = "int"
%assign fcnName = "main"
%assign fcnParams = ""
%assign fcnCategory = "main"
%assign fcnAbstract = "Solver mode : " + "%<CompiledModel.FixedStepOpts.SolverMode>"
%createrecord fcnRec {Name fcnName; Returns fcnReturns; Params fcnParams; ...
Abstract fcnAbstract; Category fcnCategory; GeneratedBy "MCHP_main_sr.tlc"; ...
Type "Main"}
%<SLibDumpFunctionBanner(fcnRec)>
%<fcnReturns> %<fcnName>(%<fcnParams>)
{
/* Initialize model */
%include "MCHP_Function_Startup.tlc"
%<MchpStartup(0)>   
%if ExtMode
rtExtModeParseArgs(0,NULL,NULL);    
%<SLibGenERTExtModeInit()>
%endif
/* Enable Time-step */
%<::Startup_TrigTimeStepInstruction>
/* Main Loop */
for(;;)
%if (::MCHP_srSchedulerOnInterrupt == 0)
{
%openfile tmpDeclarVar
%assign MCHP_NEAR_MEM = Mchp_NEAR_MEM()
volatile uint_T ContinueTimeStep %<MCHP_NEAR_MEM> = 0;    /* Microchip Global Variable for single rate scheduler */
%closefile tmpDeclarVar
%<SLibCacheCodeToFile("mainSrc_data_defn", tmpDeclarVar)>
while(!ContinueTimeStep);   
%if (POWERSAVE ==1)
%<MCHP_GoToSleepMode()>       
%else
%endif
/* Disable Scheduler Interrupt */
%<Mchp_asm_DisableSchedulerInterrupt()>
%<Mchp_asm_ABclr("ContinueTimeStep",0)>    
%<MCHP_ProfileMCU("enter")>
%if (::MASTER_BusyFlag != -1)
/* Set busy flag */
%<MCHP_SetOutputBit(MASTER_BusyFlag,1,"Set Busy Flag PIN")>
%endif
/* Call model Scheduler */
%if !IsModelReferenceTarget()       
%assign varbuf = LibWriteModelInputs()
%if !WHITE_SPACE(varbuf)
/* Remove conditional, and set model inputs here */
%<varbuf>\
%endif
%endif
/* Step the model for base rate */
%<MCHP_ProfileTaskStart(0)>
%foreach iTask = LibNumSynchronousSampleTimes() 
%<MCHP_ProfileMCU_Compute(iTask)>\
%endforeach
%if ExtMode
%<FcnGenerateExtModeOneStep()>  
%endif
%<LibCallModelStep(0)>\
%if ExtMode
rtExtModeCheckEndTrigger();
%endif
%<MCHP_ProfileTaskStop(0)>
%if ExtMode
if (0==(%<ERTStopCheck()>)) {
rtExtModeShutdown(%<NumSynchronousSampleTimes>);
}
%endif
%if !IsModelReferenceTarget()   
%assign varbuf = LibWriteModelOutputs()
%if !WHITE_SPACE(varbuf)
/* Remove conditional, and get model outputs here */
%<varbuf>\
%endif
%endif
%if (::MASTER_BusyFlag != -1)
/* Release busy flag */
%<MCHP_SetOutputBit(MASTER_BusyFlag,0,"Release Busy Flag PIN")>
%endif
%<MCHP_ProfileMCU("exitUpdate")>
/* Re-Enable Scheduler Interrupt */
%<Mchp_asm_EnableSchedulerInterrupt()>
}   /* End for(;;) */
%else 
%if EXISTS(::IdleTaskImplemented)
%if (::IdleTaskImplemented == 1)
%if (POWERSAVE ==1)
/* Override POWER SAVE mode */
%warning *** One Idle Task is defined while POWER SAVE mode is activated in MASTER block. POWER SAVE mode is disabled ***
%endif
{
%<::MCHP_IdleTask>
%if ExtMode
%<ExtModeExecuteIdle()>
%endif
} /* end of for (;;) */
%elseif (POWERSAVE == 1)  
{
%if ExtMode
%<ExtModeExecuteIdle()>
%endif
%<MCHP_GoToSleepMode()>       
}
%else
%if ExtMode
{
%<ExtModeExecuteIdle()>
}
%else
;
%endif
%endif
%elseif (POWERSAVE == 1) 
{
%if ExtMode
%<ExtModeExecuteIdle()>
%endif
%<MCHP_GoToSleepMode()>       
}
%else
%if ExtMode
{
%<ExtModeExecuteIdle()>
}
%else
;
%endif
%endif
%endif
}
%closefile tmpBuf
%<SLibCacheCodeToFile("mainSrc_fcn_defn", tmpBuf)>
%endfunction
%function ExtModeExecuteIdle() Output
%if ExtMode
%<FcnGenerateExtModeOneStep()>
rtExtModeCheckEndTrigger();
%endif
%endfunction