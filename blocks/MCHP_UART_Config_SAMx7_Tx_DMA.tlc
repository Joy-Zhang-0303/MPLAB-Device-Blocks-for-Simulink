
%function MCHP_UART_Config_Tx_DMA(block,system) Output
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%assign nUSART = CAST("Number",block.RTWdata.nUSART)	
%switch ::ChipIdL1
%case "SAME"
%case "SAMS"
%case "SAMV"
%if UARTRef > nUSART
%assign Per_Type = "UART"
%assign REG_NAME = "UART"
%assign REG_NAME2 = ""
%assign INTERRUPT_STATUS_REG = "SR"
%assign UART_Index = (UARTRef-1) - nUSART
%else
%assign Per_Type = "USART"
%assign REG_NAME = "US"
%assign REG_NAME2 = "USART_"
%assign INTERRUPT_STATUS_REG = "CSR"
%assign UART_Index = UARTRef-1
%endif
%assign UART_NAME = "%<Per_Type>%<UART_Index>"
%break
%case "SAMRH"
%assign Per_Type = "USART"
%assign REG_NAME = "FLEX_US"
%assign REG_NAME2 = ""
%assign INTERRUPT_STATUS_REG = "CSR"
%assign UART_Index = UARTRef-1
%assign UART_NAME = "FLEXCOM%<UART_Index>"
%break
%default
%error("Internal error with UART")
%endswitch
%assign TX_IMPLEMENTATION = MchpVector(RTWGenSettings.UART_TX_IMPLEMENTATION)
%assign TX_IMPLEMENTATION = TX_IMPLEMENTATION[UARTRef-1]		
%assign UART_TX_DMACHANNEL = MchpVector(RTWGenSettings.UART_TX_DMACHANNEL)
%assign TX_DMA_CHANNEL = UART_TX_DMACHANNEL[UARTRef-1]		
%assign TX_BufferSize = CAST("Number",block.RTWdata.TX_DMA_SIZE)
%assign TX_INT_PRIORITY = 3
%assign XDMAC_Tx_PERID = CAST("Vector",[7 ,9, 11, 20, 22, 24, 26, 28])
%assign XDMAC_UART_TX_PERID = XDMAC_Tx_PERID[UARTRef-1]
%switch TX_IMPLEMENTATION
%case 3 
MCHP_%<UART_NAME>_Tx.BufferAB = 0;
MCHP_%<UART_NAME>_Tx.overload = 0;			
%case 4	
MCHP_%<UART_NAME>_Tx.tail = 0;	
/* ================================ Initialize Tx-DMA ================================ */
/* DMA Controller Peripheral Connections for %<UART_NAME>(XDMAC_CC.PERID): %<UART_NAME>_Tx = %<TX_DMA_CHANNEL> */
/* Enable XDMAC clock. XDMAC PID: 58. The clock enable bit is located in PMC_PCER1  */
PMC_REGS->PMC_PCER1 |=  PMC_PCER1_PID58(1);
/* All XDMA channel interrupts will be enabled with the following stored value */
uint32_t xdmaint;
xdmaint = ( XDMAC_CIE_BIE_Msk   |
XDMAC_CIE_DIE_Msk   |
XDMAC_CIE_FIE_Msk   |
XDMAC_CIE_RBIE_Msk  |
XDMAC_CIE_WBIE_Msk  |
XDMAC_CIE_ROIE_Msk);
/*================ Initialize channel configuration for transmitter ===============*/
xdmac_tx_cfg.mbr_ubc = %<TX_BufferSize>;
%if TX_IMPLEMENTATION == 4 
xdmac_tx_cfg.mbr_sa = (uint32_t)MCHP_%<UART_NAME>_Tx_buffer;  /* Physical address for initial Tx Buffer */									
%else
xdmac_tx_cfg.mbr_sa = (uint32_t)MCHP_%<UART_NAME>_Tx_bufferA;  /* Physical address for initial Tx Buffer */									
%endif
xdmac_tx_cfg.mbr_da = (uint32_t) &(%<UART_NAME>_REGS->%<REG_NAME>_THR);
xdmac_tx_cfg.mbr_cfg =  XDMAC_CC_TYPE_PER_TRAN      |
XDMAC_CC_MBSIZE_SINGLE      |
XDMAC_CC_DSYNC_MEM2PER      |
XDMAC_CC_CSIZE_CHK_1        |
XDMAC_CC_DWIDTH_BYTE        |
XDMAC_CC_SIF_AHB_IF0        |
XDMAC_CC_DIF_AHB_IF1        |
XDMAC_CC_SAM_INCREMENTED_AM |
XDMAC_CC_DAM_FIXED_AM       |
XDMAC_CC_PERID(%<UART_NAME>_XDMAC_TX_CH_NUM);
xdmac_tx_cfg.mbr_bc  = 0UL;
xdmac_tx_cfg.mbr_ds  = 0UL;
xdmac_tx_cfg.mbr_sus = 0UL;
xdmac_tx_cfg.mbr_dus = 0UL;
/* Clear the pending Interrupt Status bit(s) by reading the selected XDMAC Channel x Interrupt Status Register (XDMAC_CISx) */
volatile uint32_t temp = XDMAC_REGS->XDMAC_CHID[%<TX_DMA_CHANNEL>].XDMAC_CIS;
/* Set source address */
XDMAC_REGS->XDMAC_CHID[%<TX_DMA_CHANNEL>].XDMAC_CSA = xdmac_tx_cfg.mbr_sa;
/* Set destination address */
XDMAC_REGS->XDMAC_CHID[%<TX_DMA_CHANNEL>].XDMAC_CDA = xdmac_tx_cfg.mbr_da;
/* Set microblock control*/
XDMAC_REGS->XDMAC_CHID[%<TX_DMA_CHANNEL>].XDMAC_CUBC = XDMAC_CUBC_UBLEN(xdmac_tx_cfg.mbr_ubc);
/* Set block control */
XDMAC_REGS->XDMAC_CHID[%<TX_DMA_CHANNEL>].XDMAC_CBC = XDMAC_CBC_BLEN(xdmac_tx_cfg.mbr_bc);
/* Set data stride pattern */
XDMAC_REGS->XDMAC_CHID[%<TX_DMA_CHANNEL>].XDMAC_CDS_MSP = xdmac_tx_cfg.mbr_ds;
/* Set source microblock stride */
XDMAC_REGS->XDMAC_CHID[%<TX_DMA_CHANNEL>].XDMAC_CSUS = XDMAC_CSUS_SUBS( xdmac_tx_cfg.mbr_sus);
/* Set destination microblock stride */
XDMAC_REGS->XDMAC_CHID[%<TX_DMA_CHANNEL>].XDMAC_CDUS = XDMAC_CDUS_DUBS(xdmac_tx_cfg.mbr_dus);
/* Set channel configuration */
XDMAC_REGS->XDMAC_CHID[%<TX_DMA_CHANNEL>].XDMAC_CC = xdmac_tx_cfg.mbr_cfg;
/* Disable next channel descriptor fetch */
XDMAC_REGS->XDMAC_CHID[%<TX_DMA_CHANNEL>].XDMAC_CNDC = 0UL;
/* Enable all interrupts for this DMA channel */
XDMAC_REGS->XDMAC_CHID[%<TX_DMA_CHANNEL>].XDMAC_CIE = xdmaint;
%if TX_IMPLEMENTATION == 3	
/* Setup XDMAC NVIC interrupt */
NVIC_ClearPendingIRQ(XDMAC_IRQn);
NVIC_SetPriority(XDMAC_IRQn, %<TX_INT_PRIORITY>);
NVIC_EnableIRQ(XDMAC_IRQn);
%endif
%break 
%endswitch 
%openfile ::tx_dma_prologue	
%switch TX_IMPLEMENTATION
%case 3 
%openfile buffer
/* Declare %<UART_NAME> Tx DMA Buffer Structure */
extern MCHP_%<UART_NAME>_TxStr MCHP_%<UART_NAME>_Tx;
extern uint8_T MCHP_%<UART_NAME>_Tx_bufferA[((Tx_BUFF_SIZE_%<UART_NAME>-1) / 32 + 1) * 32] ;
extern uint8_T MCHP_%<UART_NAME>_Tx_bufferB[((Tx_BUFF_SIZE_%<UART_NAME>-1) / 32 + 1) * 32] ;
%closefile buffer
%<LibCacheExtern(buffer)>	
%openfile buffer
/* Declare %<UART_NAME> Tx DMA Buffer Structure */
#define Tx_BUFF_SIZE_%<UART_NAME> (%<TX_BufferSize>)
typedef struct MCHP_%<UART_NAME>_TxStr{			
volatile uint_T BufferAB : 1; 				
volatile uint_T tail;           /* tail is the index for the next value to be read from the Circular buffer */				
volatile uint_T overload;       /* head is the index for the next value to be written into the buffer */
} MCHP_%<UART_NAME>_TxStr;
%closefile buffer
%<LibCacheTypedefs(buffer)>	
/* %<UART_NAME> Tx DMA buffers  */
MCHP_%<UART_NAME>_TxStr MCHP_%<UART_NAME>_Tx ;
uint8_T MCHP_%<UART_NAME>_Tx_bufferA[((Tx_BUFF_SIZE_%<UART_NAME>-1) / 32 + 1) * 32] __attribute__(( aligned(32) ));	/* Declare DMA buffer */
uint8_T MCHP_%<UART_NAME>_Tx_bufferB[((Tx_BUFF_SIZE_%<UART_NAME>-1) / 32 + 1) * 32] __attribute__(( aligned(32) ));    /* Declare DMA buffer */
%break
%case 4 
%openfile buffer
/* Declare %<UART_NAME> Tx DMA Buffer Structure */
extern MCHP_%<UART_NAME>_TxStr MCHP_%<UART_NAME>_Tx;
extern uint8_T MCHP_%<UART_NAME>_Tx_buffer[((Tx_BUFF_SIZE_%<UART_NAME>-1) / 32 + 1) * 32];
%closefile buffer
%<LibCacheExtern(buffer)>			
%openfile buffer
/* %<UART_NAME> Tx DMA buffer */
#define Tx_BUFF_SIZE_%<UART_NAME> (%<TX_BufferSize>)
typedef struct MCHP_%<UART_NAME>_TxStr{
volatile uint_T tail;       /* tail is the index for the next value to be read from the buffer */				
} MCHP_%<UART_NAME>_TxStr;
%closefile buffer
%<LibCacheTypedefs(buffer)>	
/* Declare %<UART_NAME> Tx DMA Buffer Structure */
MCHP_%<UART_NAME>_TxStr MCHP_%<UART_NAME>_Tx ;
uint8_T MCHP_%<UART_NAME>_Tx_buffer[((Tx_BUFF_SIZE_%<UART_NAME>-1) / 32 + 1) * 32] __attribute__(( aligned(32) )); /* Declare DMA buffer */
%break	
%endswitch 
%closefile tx_dma_prologue
%openfile ::tx_dma_epilogue
%switch TX_IMPLEMENTATION
%case 3 
/* Check if DMA(Tx) channel %<TX_DMA_CHANNEL> issued the interrupt (end of block interrupt)*/
volatile uint32_t dma_status_tx = XDMAC_REGS->XDMAC_CHID[%<TX_DMA_CHANNEL>].XDMAC_CIS;    /* Clear XDMAC Channel %<TX_DMA_CHANNEL> interrupt flags; get channel status */
if (dma_status_tx & XDMAC_CIS_BIS_Msk)
{
XDMAC_REGS->XDMAC_GID |= XDMAC_GID_ID%<TX_DMA_CHANNEL>(1);     /* Disable XDMAC CHNANNEL %<TX_DMA_CHANNEL>  interrupt */
%<MCHP_ProfileMCU("enter")>	
/* If still ongoing DMA Transfer. DMA interrupt comes too early. straight start of another transfer would corrupt data. */
while((%<UART_NAME>_REGS->%<REG_NAME>_%<INTERRUPT_STATUS_REG> & %<REG_NAME>_%<INTERRUPT_STATUS_REG>_%<REG_NAME2>TXRDY_Msk) == 0){
__NOP(); /* Wait for UART-Tx internal buffer to be empty. */
}
switch (MCHP_%<UART_NAME>_Tx.BufferAB){
case 0:
XDMAC_REGS->XDMAC_CHID[%<TX_DMA_CHANNEL>].XDMAC_CSA = (uint32_t)MCHP_%<UART_NAME>_Tx_bufferA;   /* Set source address */
MCHP_%<UART_NAME>_Tx.BufferAB = 1;
SCB_CleanDCache_by_Addr( (uint32_t*) ((uint32_t)MCHP_%<UART_NAME>_Tx_bufferA & 0xFFFFFFE0)  ,Tx_BUFF_SIZE_%<UART_NAME>);
break;
case 1:
XDMAC_REGS->XDMAC_CHID[%<TX_DMA_CHANNEL>].XDMAC_CSA = (uint32_t)MCHP_%<UART_NAME>_Tx_bufferB;   /* Set source address */
MCHP_%<UART_NAME>_Tx.BufferAB = 0;
SCB_CleanDCache_by_Addr( (uint32_t*) ((uint32_t)MCHP_%<UART_NAME>_Tx_bufferB & 0xFFFFFFE0)  ,Tx_BUFF_SIZE_%<UART_NAME>);
break;
}
XDMAC_REGS->XDMAC_GE |= XDMAC_GE_EN%<TX_DMA_CHANNEL>_Msk;  /* Enable DMA channel%<TX_DMA_CHANNEL> and start DMA data transfer */
MCHP_%<UART_NAME>_Tx.tail = 0;	
MCHP_%<UART_NAME>_Tx.overload = 0;			
%<MCHP_ProfileMCU("exitUpdate")>
}  		
%break
%case 4 
%break
%endswitch 
%closefile tx_dma_epilogue
%endfunction