%implements  MCHP_Interrupt  "C"
%include "MCHP_CN_Interrupt.tlc"
%function BlockInstanceSetup(block, system) void
%assign connected = TLC_FALSE
%foreach cidx = SIZE(SFcnSystemOutputCall,1)
%if LibIsEqual(SFcnSystemOutputCall[cidx].BlockToCall, "unconnected")
%continue
%else
%assign SSBlock = LibGetFcnCallBlock(block,0)
%addtorecord block ssBlock SSBlock
%break
%endif
%endforeach
%if !connected
%assign wrnTxt = "The output for Interrupt block '%<block.Name>' is " ...
"unconnected.  No code will be generated for this block."
%<LibReportWarning(wrnTxt)>
%endif
%if ISEMPTY(block.RTWdata.VectorName)
%assign IE_ref = CAST("String",block.RTWdata.IE_ref)
%switch IE_ref
%case "CNIE"
%if !ISFIELD(::CompiledModel.MCHP,"MCHP_CNIE")
%addtorecord ::CompiledModel.MCHP MCHP_CNIE block
%else
%<LibBlockReportError(block,"Interrupt block can use only once each interrupt. Interruption CNIE was defined at least twice.")>
%endif
%break
%case "CNAIE"		 	
%if !ISFIELD(::CompiledModel.MCHP,"MCHP_CNAIE")
%addtorecord ::CompiledModel.MCHP MCHP_CNAIE block
%else
%<LibBlockReportError(block,"Interrupt block can use only once each interrupt. Interruption CNAIE was defined at least twice.")>
%endif
%break
%case "CNBIE"
%if !ISFIELD(::CompiledModel.MCHP,"MCHP_CNBIE")
%addtorecord ::CompiledModel.MCHP MCHP_CNBIE block
%else
%<LibBlockReportError(block,"Interrupt block can use only once each interrupt. Interruption CNBIE was defined at least twice.")>
%endif
%break
%case "CNCIE"
%if !ISFIELD(::CompiledModel.MCHP,"MCHP_CNCIE")
%addtorecord ::CompiledModel.MCHP MCHP_CNCIE block
%else
%<LibBlockReportError(block,"Interrupt block can use only once each interrupt. Interruption CNCIE was defined at least twice.")>
%endif
%break
%case "CNDIE"
%if !ISFIELD(::CompiledModel.MCHP,"MCHP_CNDIE")
%addtorecord ::CompiledModel.MCHP MCHP_CNDIE block
%else
%<LibBlockReportError(block,"Interrupt block can use only once each interrupt. Interruption CNDIE was defined at least twice.")>
%endif
%break
%case "CNEIE"
%if !ISFIELD(::CompiledModel.MCHP,"MCHP_CNEIE")
%addtorecord ::CompiledModel.MCHP MCHP_CNEIE block
%else
%<LibBlockReportError(block,"Interrupt block can use only once each interrupt. Interruption CNEIE was defined at least twice.")>
%endif
%break
%case "CNFIE"
%if !ISFIELD(::CompiledModel.MCHP,"MCHP_CNFIE")
%addtorecord ::CompiledModel.MCHP MCHP_CNFIE block
%else
%<LibBlockReportError(block,"Interrupt block can use only once each interrupt. Interruption CNFIE was defined at least twice.")>
%endif
%break
%case "CNGIE"
%if !ISFIELD(::CompiledModel.MCHP,"MCHP_CNGIE")
%addtorecord ::CompiledModel.MCHP MCHP_CNGIE block
%else
%<LibBlockReportError(block,"Interrupt block can use only once each interrupt. Interruption CNGIE was defined at least twice.")>
%endif
%break
%case "CNHIE"
%if !ISFIELD(::CompiledModel.MCHP,"MCHP_CNHIE")
%addtorecord ::CompiledModel.MCHP MCHP_CNHIE block
%else
%<LibBlockReportError(block,"Interrupt block can use only once each interrupt. Interruption CNHIE was defined at least twice.")>
%endif
%break
%case "CNIIE"
%if !ISFIELD(::CompiledModel.MCHP,"MCHP_CNIIE")
%addtorecord ::CompiledModel.MCHP MCHP_CNIIE block
%else
%<LibBlockReportError(block,"Interrupt block can use only once each interrupt. Interruption CNIIE was defined at least twice.")>
%endif
%break
%case "CNJIE"
%if !ISFIELD(::CompiledModel.MCHP,"MCHP_CNJIE")
%addtorecord ::CompiledModel.MCHP MCHP_CNJIE block
%else
%<LibBlockReportError(block,"Interrupt block can use only once each interrupt. Interruption CNJIE was defined at least twice.")>
%endif
%break
%case "CNKIE"
%if !ISFIELD(::CompiledModel.MCHP,"MCHP_CNKIE")
%addtorecord ::CompiledModel.MCHP MCHP_CNKIE block
%else
%<LibBlockReportError(block,"Interrupt block can use only once each interrupt. Interruption CNKIE was defined at least twice.")>
%endif
%break
%case "CM1"
%case "CM2"
%case "CM3"
%case "CM4"
%case "CMx"
%foreach callIdx = NumSFcnSysOutputCalls		
%if LibIsEqual(SFcnSystemOutputCall[callIdx].BlockToCall, "unconnected")
%continue
%else
%assign ::MCHP_COMPARATOR1_InterruptRequest = 1
%endif
%endforeach
%break
%default
%break
%endswitch
%endif 
%endfunction
%function Outputs(block, system) Output
%if ISFIELD(block, "ssBlock")
%assign IE_ref = CAST("String",block.RTWdata.IE_ref)
%assign IE_ShortDesc = CAST("String",block.RTWdata.IE_ShortDesc)
%assign IE_LongDesc = CAST("String",block.RTWdata.IE_LongDesc)
%assign IE_LongDescCRC = CAST("Number",block.RTWdata.IE_LongDescCRC)
%assign SS_TIMESOURCE = CAST("Number",block.RTWdata.SS_TIMESOURCE)
%assign SS_ARCH = CAST("Number",block.RTWdata.SS_ARCH)
%assign TimerRef = CAST("Number",block.RTWdata.TimerRef)
%openfile tmpBuf
{
%if LibNeedAsyncCounter(block,0)
%switch SS_TIMESOURCE
%case 1
%break
%case 2
static unsigned int MCHP_LocalTime;	
%<LibSetAsyncClockTicks(block,0,"(++MCHP_LocalTime)","")>				
%break
%case 3
%if (SS_ARCH == 32)		
%<LibSetAsyncClockTicks(block,0,"((uint32_T) _mfc0(_CP0_COUNT, _CP0_COUNT_SELECT))","")>							
%else
%if TimerRef <= nTIMERS	
%assign TMRx = "TMR%<TimerRef>"
%else 
%assign TMRx = "CCP%<TimerRef - nTIMERS>TMRL"													
%endif						
%<LibSetAsyncClockTicks(block,0,"((uint16_T) %<TMRx>)","")>	
%endif
%break
%endswitch
%endif
%foreach callIdx = NumSFcnSysOutputCalls		
%if LibIsEqual(SFcnSystemOutputCall[callIdx].BlockToCall, "unconnected")
%continue
%endif
%<LibBlockExecuteFcnCall(block,callIdx)>\
%endforeach
}
%closefile tmpBuf
%if ISEMPTY(block.RTWdata.VectorName)  
%switch IE_ref
%case "CNIE"
%if ISFIELD(::CompiledModel.MCHP,"MCHP_%<IE_ref>")
%<MCHP_CN_Interrupt(::CompiledModel.MCHP.MCHP_CN_block,"Z")>	
%endif	 		
%break
%case "CNAIE"
%if ISFIELD(::CompiledModel.MCHP,"MCHP_%<IE_ref>")
%<MCHP_CN_Interrupt(::CompiledModel.MCHP.MCHP_CNA_block,"A")>
%endif	 		
%break
%case "CNBIE"
%if ISFIELD(::CompiledModel.MCHP,"MCHP_%<IE_ref>")
%<MCHP_CN_Interrupt(::CompiledModel.MCHP.MCHP_CNB_block,"B")>
%endif	 		
%break
%case "CNCIE"
%if ISFIELD(::CompiledModel.MCHP,"MCHP_%<IE_ref>")
%<MCHP_CN_Interrupt(::CompiledModel.MCHP.MCHP_CNC_block,"C")>
%endif	 		
%break
%case "CNDIE"
%if ISFIELD(::CompiledModel.MCHP,"MCHP_%<IE_ref>")
%<MCHP_CN_Interrupt(::CompiledModel.MCHP.MCHP_CND_block,"D")>
%endif	 		
%break
%case "CNEIE"
%if ISFIELD(::CompiledModel.MCHP,"MCHP_%<IE_ref>")
%<MCHP_CN_Interrupt(::CompiledModel.MCHP.MCHP_CNE_block,"E")>
%endif	 		
%break
%case "CNFIE"
%if ISFIELD(::CompiledModel.MCHP,"MCHP_%<IE_ref>")
%<MCHP_CN_Interrupt(::CompiledModel.MCHP.MCHP_CNF_block,"F")>
%endif	 		
%break
%case "CNGIE"
%if ISFIELD(::CompiledModel.MCHP,"MCHP_%<IE_ref>")
%<MCHP_CN_Interrupt(::CompiledModel.MCHP.MCHP_CNG_block,"G")>
%endif	 		
%break
%case "CNHIE"
%if ISFIELD(::CompiledModel.MCHP,"MCHP_%<IE_ref>")
%<MCHP_CN_Interrupt(::CompiledModel.MCHP.MCHP_CNH_block,"H")>
%endif	 		
%break
%case "CNIIE"
%if ISFIELD(::CompiledModel.MCHP,"MCHP_%<IE_ref>")
%<MCHP_CN_Interrupt(::CompiledModel.MCHP.MCHP_CNI_block,"I")>
%endif	 		
%break
%case "CNJIE"
%if ISFIELD(::CompiledModel.MCHP,"MCHP_%<IE_ref>")
%<MCHP_CN_Interrupt(::CompiledModel.MCHP.MCHP_CNJ_block,"J")>
%endif	 		
%break
%case "CNKIE"
%if ISFIELD(::CompiledModel.MCHP,"MCHP_%<IE_ref>")
%<MCHP_CN_Interrupt(::CompiledModel.MCHP.MCHP_CNK_block,"K")>
%endif	 		
%break
%case "SPI1"
%case "SPI2"
%case "SPI3"
%case "SPI4"
%case "SPI5"
%case "SPI6"
%case "I2C1"
%case "I2C2"
%case "I2C3"
%case "I2C4"
%case "I2C5"
%case "I2C6"
%case "CM1"
%case "CM2"
%case "CM3"
%case "CM4"
%case "CMx"
%assign hFilename = "MCHP_%<IE_ref>_%<IE_LongDescCRC>"
%openfile buffer
#define Flag_%<hFilename>
%closefile buffer
%<LibCacheExtern(buffer)>
%openfile buffer
extern inline void %<hFilename>(void);
%closefile buffer
%<LibCacheFunctionPrototype(buffer)>
%openfile Buff_IE_h_file = hFilename + ".c"
/* Implements interrupt %<IE_ref> -- %<IE_ShortDesc> -- %<IE_LongDesc> */
#include "%<LibGetMdlPubHdrBaseName()>.h"
#include "%<LibGetMdlPubHdrBaseName()>_private.h"	
inline void %<hFilename>(void) {
%if WHITE_SPACE(tmpBuf)
/* Nothing to do for system: '%<ssBlock.Name>' */
%else
/* Call the system: '%<ssBlock.Name>' */
%<tmpBuf>\
%endif					
}				
%closefile Buff_IE_h_file
%break
%default
%break
%endswitch
%else 
%assign VectorName = CAST("String",block.RTWdata.VectorName)
%assign Config_BitSet = CAST("String",block.RTWdata.Config_BitSet)
%assign RegisterReadClear = CAST("String",block.RTWdata.RegisterReadClear)
%assign Priority = CAST("Number",block.RTWdata.Priority)
%assign FPUNoSave = CAST("Number",block.RTWdata.FPUNoSave)
%foreach callIdx = NumSFcnSysOutputCalls		
%if LibIsEqual(SFcnSystemOutputCall[callIdx].BlockToCall, "unconnected")
%continue
%endif			
%assign hFilename = "MCHP_%<IE_ref>_%<IE_LongDescCRC>"
%openfile dspicfun	
/* Implements interrupt %<IE_ref> -- %<IE_ShortDesc> -- %<IE_LongDesc> */
%if ::isPIC32
%<Mchp_Interrupt32(Priority,1,FPUNoSave==0,VectorName,block)>  
%else
%<Mchp_Interrupt16(Priority,"__auto_psv__",VectorName,block)>  				
%endif
{
%<MCHP_ProfileMCU("enter")>
%if !WHITE_SPACE(RegisterReadClear)
unsigned register int tmp __attribute__((unused)) = %<RegisterReadClear>;	/* Clear interrupt cause */
%endif
%<MCHP_SFR(  "%<IE_ref>IF"  	, 0 				   , "Clear interrupt flag" )>
%if WHITE_SPACE(tmpBuf)
/* Nothing to do for system: '%<ssBlock.Name>' */
%else
/* Call the system: '%<ssBlock.Name>' */
%<tmpBuf>\
%endif	
%<MCHP_ProfileMCU("exitUpdate")>
}		 		
%closefile dspicfun
%assign srcFile = LibGetModelDotCFile()
%<LibSetSourceFileSection(srcFile, "Functions", dspicfun)>			
%endforeach
%endif  
%endif
%endfunction
%function Start(block, system) Output
%if ISFIELD(block, "ssBlock")
%assign IE_ref = CAST("String",block.RTWdata.IE_ref)
%assign IE_ShortDesc = CAST("String",block.RTWdata.IE_ShortDesc)
%assign IE_LongDesc = CAST("String",block.RTWdata.IE_LongDesc)
%assign IE_LongDescCRC = CAST("Number",block.RTWdata.IE_LongDescCRC)
%assign StartupExecute = CAST("Number",block.RTWdata.StartupExecute)	
%if ISEMPTY(block.RTWdata.VectorName)
%if StartupExecute == 1
%switch IE_ref
%case "SPI1"
%case "SPI2"
%case "SPI3"
%case "SPI4"
%case "SPI5"
%case "SPI6"
%assign hFilename = "MCHP_%<IE_ref>_%<IE_LongDescCRC>"
#ifdef Flag_%<hFilename>
%<hFilename>();	/* Call User defined Interruption at Startup */
#else
#warning  "No code were generated for at least one SPI interrupt present in an SPI sequence."
#endif
%break
%case "I2C1"
%case "I2C2"
%case "I2C3"
%case "I2C4"
%case "I2C5"
%case "I2C6"
%assign hFilename = "MCHP_%<IE_ref>_%<IE_LongDescCRC>"
#ifdef Flag_%<hFilename>
%<hFilename>();	/* Call User defined Interruption at Startup */
#else
#warning  "No code were generated for at least one I2C interrupt present in an I2C sequence."
#endif
%break
%case "CM1"
%case "CM2"
%case "CM3"
%case "CM4"
%case "CMx"
%assign hFilename = "MCHP_%<IE_ref>_%<IE_LongDescCRC>"
#ifdef Flag_%<hFilename>
%<hFilename>();	/* Call User defined Interruption at Startup */
#else
#warning  "No code were generated for at least one Comparator interrupt."
#endif
%break
%endswitch
%endif
%else 
%assign VectorName = CAST("String",block.RTWdata.VectorName)
%assign Config_BitSet = CAST("String",block.RTWdata.Config_BitSet)
%assign RegisterReadClear = CAST("String",block.RTWdata.RegisterReadClear)
%assign Priority = CAST("Number",block.RTWdata.Priority)
%foreach callIdx = NumSFcnSysOutputCalls		
%if LibIsEqual(SFcnSystemOutputCall[callIdx].BlockToCall, "unconnected")
%continue
%endif			
/* Configure %<IE_LongDesc> Interruption */
%if !WHITE_SPACE(Config_BitSet)
%<Config_BitSet> = 1;
%endif
%<MCHP_SFR(  "%<IE_ref>IP"  	, Priority			   , "Priority" )>
%<MCHP_SFR(  "%<IE_ref>IF"  	, 0 				   , "" )> 			
%openfile LocalStartup_TrigTimeStepInstruction		 		
%if StartupExecute			 	
%<MCHP_SFR(  "%<IE_ref>IF"  	, 1 				   , "Force once execution of interrupt %<IE_ShortDesc> at startup" )>
%endif
%<MCHP_SFR(  "%<IE_ref>IE"  	, 1 				   , "" )> 						
%<::Startup_TrigTimeStepInstruction>\
%closefile LocalStartup_TrigTimeStepInstruction
%assign ::Startup_TrigTimeStepInstruction = LocalStartup_TrigTimeStepInstruction				
%endforeach
%endif 
%endif
%endfunction
