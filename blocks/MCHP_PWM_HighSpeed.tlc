%implements  MCHP_PWM_HighSpeed  "C"
%include "MCHP_Functions.tlc"
%assign ::MCHP_FLTMODx_VAL = [-1,-1,-1,-1,-1,-1,-1,-1,-1]
%function BlockInstanceSetup(block, system) void
%assign FLTMODx = MchpVector(block.RTWdata.FLTMODx)		
%foreach idx = SIZE(FLTMODx,1)
%assign ::MCHP_FLTMODx_VAL[idx] = FLTMODx[idx]
%endforeach
%endfunction
%function Start(block, system) Output
%assign PTCON1 = CAST("Number",block.RTWdata.PTCON1)
%assign PTCON2 = CAST("Number",block.RTWdata.PTCON2)
%assign PTPER = CAST("Number",block.RTWdata.PTPER)
%assign MDC = CAST("Number",block.RTWdata.MDC)
%assign SEVTCMP = MchpVector(block.RTWdata.SEVTCMP)		
%assign PHASEx = MchpVector(block.RTWdata.PHASEx)		
%assign SPHASEx = MchpVector(block.RTWdata.SPHASEx)		
%assign PDCx = MchpVector(block.RTWdata.PDCx)		
%assign SDCx = MchpVector(block.RTWdata.SDCx)		
%assign DTRx = MchpVector(block.RTWdata.DTRx)		
%assign ALTDTRx = MchpVector(block.RTWdata.ALTDTRx)		
%assign IOCONx = MchpVector(block.RTWdata.IOCONx)		
%assign PWMCONx = MchpVector(block.RTWdata.PWMCONx)		
%assign FCLCONx = MchpVector(block.RTWdata.FCLCONx)		
%assign TRIGx = MchpVector(block.RTWdata.TRIGx)		
%assign TRIGx_N = MchpVector(block.RTWdata.TRIGx_N)		
%assign FLTMODx = MchpVector(block.RTWdata.FLTMODx)		
%assign AUXCONx = MchpVector(block.RTWdata.AUXCONx)
%assign LEBCONx = MchpVector(block.RTWdata.LEBCONx)
%assign LEBDLYx = MchpVector(block.RTWdata.LEBDLYx)
%assign inputSEVTCMP = CAST("Number",block.RTWdata.inputSEVTCMP)
%assign InputTRIGx = MchpVector(block.RTWdata.InputTRIGx)		
%assign nSEVTCMP = SIZE(SEVTCMP,1)
%assign DBL_UPDATE = CAST("Number",block.RTWdata.DBL_UPDATE)
%assign PDCx_DblUpdate = MchpVector(block.RTWdata.PDCx_DblUpdate)
%assign SDCx_DblUpdate = MchpVector(block.RTWdata.SDCx_DblUpdate)
%assign InputDutyCycleH = MchpVector(block.RTWdata.InputDutyCycleH)		
%assign InputDutyCycleL = MchpVector(block.RTWdata.InputDutyCycleL)		
%assign OneDutyCycleIsABlockInput = 0
%foreach idx_PDC = SIZE(PDCx,1)
%if (PDCx[idx_PDC] != -1)
%if (InputDutyCycleH[idx_PDC] != -1)
%assign OneDutyCycleIsABlockInput = 1
%endif
%endif
%endforeach
%assign ITB = CAST("Number",block.RTWdata.ITB)
%if ITB == 1
%assign PHASE_desc = "periode"
%assign SPHASE_desc = "periode"
%else
%assign PHASE_desc = "phase shift"
%assign SPHASE_desc = "phase shift"
%endif
%if (CAST("Number",RTWGenSettings.DOS_00958_pwm_TLAH) != 0) 
%assign GS_Offset = 7	
%if PTPER != -1		
%if ((PTPER-GS_Offset) < 0)
%assign PTPER = 0
%else
%assign PTPER = PTPER - GS_Offset
%endif
%endif
%if ITB == 0			
%assign PTPER = -1
%foreach idx = SIZE(SPHASEx,1)
%if SPHASEx[idx] != -1
%if ((SPHASEx[idx]-GS_Offset) < 0)
%assign SPHASEx[idx] = 0
%else
%assign SPHASEx[idx] = SPHASEx[idx] - GS_Offset
%endif					
%endif
%endforeach
%foreach idx = SIZE(PHASEx,1)
%if PHASEx[idx] != -1
%if ((PHASEx[idx]-GS_Offset) < 0)
%assign PHASEx[idx] = 0
%else
%assign PHASEx[idx] = PHASEx[idx] - GS_Offset
%endif					
%endif
%endforeach	
%endif
%endif
%assign idx_DW = 0
%if DBL_UPDATE
%assign MCHP_TRIG_DBL_UPDATE = LibBlockDWork(DWork[idx_DW], "", "", 0)
%assign idx_DW = idx_DW + 1
%assign Flag_DW_OneInputDutyCycle = 0
%assign Flag_DW_ZeroInputDutyCycle = 0
%assign idx_PeriodStored = 0
%foreach idx = SIZE(InputDutyCycleH,1)  
%if InputDutyCycleH[idx] != -1		
%<LibBlockDWork(DWork[idx_DW], "", "", 0 + idx_PeriodStored * 4)> = %<PDCx_DblUpdate[idx]>;
%<LibBlockDWork(DWork[idx_DW], "", "", 1 + idx_PeriodStored * 4)> = %<PDCx[idx]>;
%<LibBlockDWork(DWork[idx_DW], "", "", 2 + idx_PeriodStored * 4)> = %<PDCx_DblUpdate[idx]>;
%<LibBlockDWork(DWork[idx_DW], "", "", 3 + idx_PeriodStored * 4)> = %<PDCx[idx]>;			
%assign Flag_DW_OneInputDutyCycle = 1
%assign idx_PeriodStored = idx_PeriodStored + 1
%else
%assign Flag_DW_ZeroInputDutyCycle = 1
%endif
%endforeach
%assign idx_DW = idx_DW + Flag_DW_OneInputDutyCycle
%endif
%assign param_useAuxilliaryClock = CAST("Number",block.RTWdata.param_useAuxilliaryClock)
%if EXISTS(::param_useAuxilliaryClock)
%assign ::MCHP_useAuxilliaryClock_APLL = ::MCHP_useAuxilliaryClock_APLL || param_useAuxilliaryClock
%else
%assign ::MCHP_useAuxilliaryClock_APLL = param_useAuxilliaryClock
%endif
/* Set PWM Period on Primary Time Base */
%if nSEVTCMP > 1
%assign MCHP_TrigIdx = LibBlockDWork(DWork[idx_DW], "", "", 0)
%assign idx_DW = idx_DW + 1
%<MCHP_TrigIdx> = 0;	
%if inputSEVTCMP != -1
%foreach idx = nSEVTCMP-1
%if SEVTCMP[idx] != -1
%<LibBlockDWork(DWork[idx_DW], "", "", idx)> = %<SEVTCMP[idx+1]>;	/* Trig %<idx+2> */
%endif
%endforeach
%if SEVTCMP[0] != -1
%<LibBlockDWork(DWork[idx_DW], "", "", nSEVTCMP-1)> = %<SEVTCMP[0]>;			/* Trig 1 : First trig moved at last position */
%endif
%assign idx_DW = idx_DW + 1
%endif
%endif
%assign idx_TRIGx = 0
%foreach idx = SIZE(TRIGx_N,1)  
%if TRIGx_N[idx] > 1
%assign MCHP_TrigIdx = LibBlockDWork(DWork[idx_DW], "", "", 0)
%<MCHP_TrigIdx> = 0;	
%assign idx_DW = idx_DW +1
%if InputTRIGx[idx] != -1
%foreach idxN = TRIGx_N[idx]
%if idxN != (TRIGx_N[idx] - 2)
%if TRIGx[idx_TRIGx + idxN + 1] != -1
%<LibBlockDWork(DWork[idx_DW], "", "", idxN)> = %<TRIGx[idx_TRIGx + idxN + 1]>;	/* Trig %<idxN+1> */
%endif
%else
%if TRIGx[idx_TRIGx] != -1
%<LibBlockDWork(DWork[idx_DW], "", "", idxN)> = %<TRIGx[idx_TRIGx]>;	/* Trig 1 */
%endif
%endif
%endforeach
%assign idx_TRIGx = idx_TRIGx + TRIGx_N[idx]
%assign idx_DW = idx_DW + 1
%endif
%else
%assign idx_TRIGx = idx_TRIGx + 1
%endif
%endforeach
%foreach idx = SIZE(PHASEx,1)
%if PHASEx[idx] != -1
PHASE%<idx+1> = %<PHASEx[idx]>;	/* %<PHASE_desc> for channel %<idx+1> */
%endif
%endforeach
%foreach idx = SIZE(SPHASEx,1)
%if SPHASEx[idx] != -1
SPHASE%<idx+1> = %<SPHASEx[idx]>;	/* %<SPHASE_desc> for channel %<idx+1> */
%endif
%endforeach
%assign FirstPDCx = -1		
%if DBL_UPDATE
%foreach idx = SIZE(PDCx_DblUpdate,1)
%if PDCx_DblUpdate[idx] != -1
PDC%<idx+1> =  %<PDCx[idx]>; 
%if FirstPDCx == -1
%assign FirstPDCx = idx + 1
%endif
%endif
%endforeach
%else
%foreach idx = SIZE(PDCx,1)
%if PDCx[idx] != -1
PDC%<idx+1> = %<PDCx[idx]>; 
%if FirstPDCx == -1
%assign FirstPDCx = idx + 1
%endif
%endif
%endforeach
%endif
%foreach idx = SIZE(SDCx,1)
%if SDCx[idx] != -1
SDC%<idx+1> = %<SDCx[idx]>;  
%endif
%endforeach
%foreach idx = SIZE(DTRx,1)
%if DTRx[idx] != -1
DTR%<idx+1> = %<DTRx[idx]>;
%endif
%endforeach
%foreach idx = SIZE(ALTDTRx,1)
%if ALTDTRx[idx] != -1
ALTDTR%<idx+1> = %<ALTDTRx[idx]>;
%endif
%endforeach
%foreach idx = SIZE(IOCONx,1)
%if IOCONx[idx] != -1
%assign val = IOCONx[idx]
%if EXISTS(::MCHP_IOCONx_OVERREN_OVERDAT)	
%if SIZE(::MCHP_IOCONx_OVERREN_OVERDAT,1) >= (idx+1)
%assign val = val + (%<::MCHP_IOCONx_OVERREN_OVERDAT[idx] << 6>)
%endif
%endif
IOCON%<idx+1> = %<MchpHex(val)>;
%endif
%endforeach
%foreach idx = SIZE(FCLCONx,1)
%if FCLCONx[idx] != -1
FCLCON%<idx+1> = %<MchpHex(FCLCONx[idx])>;
%endif
%endforeach
%foreach idx = SIZE(AUXCONx,1)
%if AUXCONx[idx] != -1
AUXCON%<idx+1> = %<MchpHex(AUXCONx[idx])>; /* Select one Blanking input signal to apply on Fault and/or Current-Limit input */
%endif
%endforeach
%foreach idx = SIZE(LEBDLYx,1)
%if LEBDLYx[idx] != -1
LEBDLY%<idx+1> = %<LEBDLYx[idx]>; /* Leading Edge Blanking Delay for Fault and/or Current-Limit input */
%endif
%endforeach
%foreach idx = SIZE(LEBCONx,1)
%if LEBCONx[idx] != -1
LEBCON%<idx+1> = %<MchpHex(LEBCONx[idx])>; /* Blanking and Leading Edge Blanking setting for Fault and/or Current-Limit input */
%endif
%endforeach
%if PTPER != -1
PTPER = %<PTPER>;
%endif
%if nSEVTCMP != 0
%if %<SEVTCMP[0]> != -1
SEVTCMP = %<SEVTCMP[0]>;
%endif
%endif
%assign idx = 0
%assign TRIGx_Interrupt = 0
%foreach idxN = SIZE(TRIGx_N,1)  
%if TRIGx[idx] != -1
TRIG%<idx+1> = %<TRIGx[idx]>;			
%endif
%assign idx = idx + TRIGx_N[idxN]
%if  TRIGx_N[idxN] > 1
%assign TRIGx_Interrupt = 1
%endif
%endforeach
%if %<MDC> != -1
MDC = %<MchpHex(MDC)>; /* Initialize Global Duty Cycles */
%endif
%foreach idx = SIZE(PWMCONx,1)
%if PWMCONx[idx] != -1
%if FLTMODx[idx] == 0 
PWMCON%<idx+1> = %<MchpHex(PWMCONx[idx] | (1<<12))>;	/* Activate FLTIEN to Re-enabled Latched Fault. FLTSTAT acts as a latch */
%<MCHP_SFR( "PWM%<idx+1>IP" , 0 , "PWM%<FirstPDCx> interrupt is not used" )>			
%else
PWMCON%<idx+1> = %<MchpHex(PWMCONx[idx])>;
%endif
%endif
%endforeach
PTCON2 = %<MchpHex(PTCON2)>;	/* PWM Clock Divider Selection */
%if (nSEVTCMP > 0) || TRIGx_Interrupt 
%openfile LocalStartup_TrigTimeStepInstruction		
%<::Startup_TrigTimeStepInstruction>\
%endif
%assign DBL_UPDATE_BufferDCInput = DBL_UPDATE && (FirstPDCx != -1 ) && (OneDutyCycleIsABlockInput == 1)	
%assign SEIEN = 0
%if (nSEVTCMP > 1) || TRIGx_Interrupt || DBL_UPDATE 
%if DBL_UPDATE && (FirstPDCx != -1 )
/* PWM%<FirstPDCx> trigger configuration for Double Update */
TRIG%<FirstPDCx> = %<PHASEx[FirstPDCx-1]>;	/* Set first */					
TRGCON%<FirstPDCx>bits.TRGDIV = 0;
TRGCON%<FirstPDCx>bits.TRGSTRT = 0;
PWMCON%<FirstPDCx>bits.TRGIEN = 1;
%<MCHP_SFR( "PWM%<FirstPDCx>IP" , 7 , "Set PWM%<FirstPDCx> with highest priority" )>				
%<MCHP_SFR( "PWM%<FirstPDCx>IF" , 0 , "Clear Pending Interrupts if any" )>				
%<MCHP_SFR( "PWM%<FirstPDCx>IE" , 1 , "Enable Interrupt" )>				
%endif 
%if (nSEVTCMP > 1) || ( (nSEVTCMP == 1) && DBL_UPDATE_BufferDCInput )
/* PWM special event trigger configuration */			
%assign SEIEN = 2048		
%<MCHP_SFR( "PSEMIP" , 7 , "Set PWM Special trigger Event Interrupt with highest priority" )>				
%<MCHP_SFR( "PSEMIF" , 0 , "Clear Pending Interrupts if any" )>				
%<MCHP_SFR( "PSEMIE" , 1 , "Enable Special event trigger Interrupt" )>					
%else 
%foreach idxN = SIZE(TRIGx_N,1)  
%if TRIGx_N[idxN] > 1
/* PWM%<idxN+1> trigger configuration */					
TRGCON%<idxN+1>bits.TRGDIV = 0;
TRGCON%<idxN+1>bits.TRGSTRT = 0;
PWMCON%<idxN+1>bits.TRGIEN = 1;
%<MCHP_SFR( "PWM%<idxN+1>IP" , 7 , "Set PWM%<FirstPDCx> with highest priority" )>				
%<MCHP_SFR( "PWM%<idxN+1>IF" , 0 , "Clear Pending Interrupts if any" )>				
%<MCHP_SFR( "PWM%<idxN+1>IE" , 1 , "Enable Interrupt" )>								
%endif
%endforeach
%endif
%endif
PTCON =  %<MchpHex(PTCON1 | SEIEN)>; /* Enable PWM peripheral */ 
%if (nSEVTCMP > 0) || TRIGx_Interrupt 
%closefile LocalStartup_TrigTimeStepInstruction
%assign ::Startup_TrigTimeStepInstruction = LocalStartup_TrigTimeStepInstruction
%endif
%if (nSEVTCMP > 1) || TRIGx_Interrupt || DBL_UPDATE 
%openfile dspicfun = "MCHP_PWM_HS_Interrupt.c"
/* Multiple trigger are set for the PWM HS peripheral. This feature is handled through an interrupt */
#include "%<LibGetMdlPubHdrBaseName()>.h"
#include "%<LibGetMdlPubHdrBaseName()>_private.h"
/* PWM_HighSpeed - Interrupt: %<Name> */
%assign idx_TRIGx = 0
%assign idx_DW = 0
%if DBL_UPDATE && (FirstPDCx != -1 )	
%assign MCHP_TRIG_DBL_UPDATE = LibBlockDWork(DWork[idx_DW], "", "", 0)
%assign idx_DW = idx_DW +1
%<Mchp_Interrupt16(7,"__no_auto_psv__","PWM%<FirstPDCx>Interrupt",block)> 			
{
TRIG%<FirstPDCx> ^= %<PHASEx[FirstPDCx-1]>;			/* Toggle TRIG%<FirstPDCx> from 0 to %<PHASEx[FirstPDCx-1]> */ 
%<MCHP_SFR( "PWM%<FirstPDCx>IF" , 0 , "Clear Interrupt flag" )>	
switch(%<MCHP_TRIG_DBL_UPDATE>){
case 0:
if (TRIG%<FirstPDCx> == 0)
{
%assign idx_PeriodStored = 0
%foreach idx_PDC = SIZE(PDCx,1)
%if (PDCx[idx_PDC] != -1)
%if (InputDutyCycleH[idx_PDC] != -1)
PDC%<idx_PDC+1> = %<LibBlockDWork(DWork[idx_DW], "", "", idx_PeriodStored)>;	/* Update PWM%<idx_PDC+1> duty cycle */
%assign idx_PeriodStored = idx_PeriodStored + 4
%else
PDC%<idx_PDC+1>  = %<PDCx[idx_PDC]>; /* Update PWM%<idx_PDC+1> duty cycle */
%endif
%endif
%endforeach
%if (nSEVTCMP == 0)
%<MCHP_TRIG_DBL_UPDATE> ^= 1;	/* PWM Double Update buffering, toggle from 0 to 1 */	
%endif									
} else
{
%assign idx_PeriodStored = 1
%foreach idx_PDC = SIZE(PDCx,1)
%if (PDCx[idx_PDC] != -1)
%if (InputDutyCycleH[idx_PDC] != -1)
PDC%<idx_PDC+1> = %<LibBlockDWork(DWork[idx_DW], "", "", idx_PeriodStored)>;	/* Update PWM%<idx_PDC+1> duty cycle */
%assign idx_PeriodStored = idx_PeriodStored + 4
%else
PDC%<idx_PDC+1>  = %<PDCx_DblUpdate[idx_PDC]>; /* Update PWM%<idx_PDC+1> duty cycle */
%endif
%endif
%endforeach																						
}
break;
case 1:
if (TRIG%<FirstPDCx> == 0)
{
%assign idx_PeriodStored = 2
%foreach idx_PDC = SIZE(PDCx,1)
%if (PDCx[idx_PDC] != -1)
%if (InputDutyCycleH[idx_PDC] != -1)
PDC%<idx_PDC+1> = %<LibBlockDWork(DWork[idx_DW], "", "", idx_PeriodStored)>;	/* Update PWM%<idx_PDC+1> duty cycle */
%assign idx_PeriodStored = idx_PeriodStored + 4
%else
PDC%<idx_PDC+1>  = %<PDCx[idx_PDC]>; /* Update PWM%<idx_PDC+1> duty cycle */
%endif
%endif
%endforeach			
%if (nSEVTCMP == 0)
%<MCHP_TRIG_DBL_UPDATE> ^= 1;	/* PWM Double Update buffering, toggle from 0 to 1 */	
%endif						
} else
{
%assign idx_PeriodStored = 3
%foreach idx_PDC = SIZE(PDCx,1)
%if (PDCx[idx_PDC] != -1)
%if (InputDutyCycleH[idx_PDC] != -1)
PDC%<idx_PDC+1> = %<LibBlockDWork(DWork[idx_DW], "", "", idx_PeriodStored)>;	/* Update duty cycle */
%assign idx_PeriodStored = idx_PeriodStored + 4
%else
PDC%<idx_PDC+1>  = %<PDCx_DblUpdate[idx_PDC]>; /* Update duty cycle */
%endif
%endif
%endforeach														
}
break;
}
%foreach idx_PDC = SIZE(PDCx,1)
%if (PDCx[idx_PDC] != -1) && (InputDutyCycleH[idx_PDC] != -1)
%assign idx_DW = idx_DW +1
%break
%endif
%endforeach
} /* End interrupt _PWM%<FirstPDCx>Interrupt */
%endif  
%if ( (nSEVTCMP == 1) && DBL_UPDATE_BufferDCInput)
%<Mchp_Interrupt16(7,Mchp_No_auto_psv(),"PWMSpEventMatchInterrupt",block)> 			
{
%<MCHP_TRIG_DBL_UPDATE> = %<MCHP_TRIG_DBL_UPDATE> ^ 1;	/* PWM Period Double Update buffering, toggle from 0 to 1 */						
%<MCHP_SFR( "PSEMIF" , 0 , "Clear Interrutp Flag" )>		
} /* End interrupt _PWMSpEventMatchInterrupt */					
%elseif (nSEVTCMP > 1) 		
%assign MCHP_TrigIdx = LibBlockDWork(DWork[idx_DW], "", "", 0)
%assign idx_DW = idx_DW + 1
%<Mchp_Interrupt16(7,Mchp_No_auto_psv(),"PWMSpEventMatchInterrupt",block)> 			
{
%if inputSEVTCMP == -1
switch(%<MCHP_TrigIdx>){
%foreach icase = nSEVTCMP
%if icase != (nSEVTCMP-1)
case %<icase>:
SEVTCMP = %<SEVTCMP[icase+1]>; 	/* Trig %<icase+2> */
%<MCHP_TrigIdx> += 1;			/* Increment index  */
break;
%else
case %<icase>:
SEVTCMP = %<SEVTCMP[0]>;	/* Trig 1 : First trig moved at last position */
%<MCHP_TrigIdx> = 0;		/* Reset index  */
%if DBL_UPDATE_BufferDCInput
%<MCHP_TRIG_DBL_UPDATE> ^= 1;	/* PWM Period Double Update buffering, toggle from 0 to 1 */	
%endif
break;
%endif
%endforeach
}
%else
if (%<MCHP_TrigIdx> != %<MchpHex(nSEVTCMP-1)>)				
{
SEVTCMP = %<LibBlockDWork(DWork[idx_DW], MCHP_TrigIdx, "", "")>;
%<MCHP_TrigIdx> += 1;						/* Increment index  */
} else {
/* First trigger (re-)set by block update code - avoid possible false trig */
%<MCHP_TrigIdx> = 0;						/* reset index  */
%if DBL_UPDATE_BufferDCInput
%<MCHP_TRIG_DBL_UPDATE> ^= 1;	/* PWM Period Double Update buffering, toggle 0-1 */				
%endif					
}
%assign idx_DW = idx_DW + 1
%endif
%<MCHP_SFR( "PSEMIF" , 0 , "Clear Interrupt Flag" )>		
} /* End interrupt _PWMSpEventMatchInterrupt */
%else 		
%foreach idxN = SIZE(TRIGx_N,1)  
%if TRIGx_N[idxN] > 1
%assign MCHP_TrigIdx = LibBlockDWork(DWork[idx_DW], "", "", 0)
%assign idx_DW = idx_DW +1
%<Mchp_Interrupt16(7,Mchp_No_auto_psv(),"PWM%<idxN+1>Interrupt",block)> 			
{
%if InputTRIGx[idxN] == -1
switch(%<MCHP_TrigIdx>){
%foreach icase = TRIGx_N[idxN]
%if icase != (TRIGx_N[idxN]-1)
case %<icase>:
TRIG%<idxN+1> = %<TRIGx[idx_TRIGx + icase + 1]>;	/* Trig %<idxN+1> */
%<MCHP_TrigIdx> += 1;			/* Increment index  */
break;
%else
case %<icase>:
TRIG%<idxN+1> = %<TRIGx[idx_TRIGx]>;	/* Trig 1 */
%<MCHP_TrigIdx> = 0;						/* Reset index */
%if DBL_UPDATE_BufferDCInput
%<MCHP_TrigIdx> = %<MCHP_TrigIdx> ^ 1;	/* PWM Period Double Update buffering, toggle from 0 to 1 */	
%endif									
break;
%endif
%endforeach
}
%assign idx_DW = idx_DW + 1
%assign idx_TRIGx = idx_TRIGx + TRIGx_N[idxN]
%else
TRIG%<idxN> = %<LibBlockDWork(DWork[idx_DW], MCHP_TrigIdx, "", "")>;
%if FEVAL("mod",%<TRIGx_N[idxN]>,2) == 0			
%<MCHP_TrigIdx> += 1;						/* Increment index  */
%<MCHP_TrigIdx> &= %<MchpHex(TRIGx_N[idxN]-1)>;	/* within [0 - %<TRIGx_N[idxN]-1>] */
%if DBL_UPDATE_BufferDCInput
if (%<MCHP_TrigIdx> == 0)
%<MCHP_TRIG_DBL_UPDATE> = %<MCHP_TRIG_DBL_UPDATE> ^ 1;	/* PWM Period Double Update buffering, toggle 0-1 */				
%endif							
%else
if ( (++%<MCHP_TrigIdx>) >= %<TRIGx_N[idxN]>) 		/* Increment index within [0 - %<nSEVTCMP-1>] */
{
%<MCHP_TrigIdx> = 0;						/* Reset index */
%<MCHP_TRIG_DBL_UPDATE> = %<MCHP_TRIG_DBL_UPDATE> ^ 1;	/* PWM Period Double Update buffering, toggle 0-1 */				
}
%endif
%endif
%<MCHP_SFR( "PWM%<idxN+1>IF" , 0 , "Clear Interrupt flag" )>	
} /* End interrupt _PWM%<idxN+1>Interrupt */
%else
%assign idx_TRIGx = idx_TRIGx + TRIGx_N[idxN]
%endif
%endforeach
%endif 
%closefile dspicfun
%endif
%if LibBlockSampleTime(block) == -2		
%<Update(block, system)>
%endif
%endfunction
%function Update(block, system) Output
%assign InputGlobalPeriod = CAST("Number",block.RTWdata.InputGlobalPeriod)
%assign InputPeriodH = MchpVector(block.RTWdata.InputPeriodH)		
%assign InputPeriodL = MchpVector(block.RTWdata.InputPeriodL)		
%assign InputGlobalDutyCycle = CAST("Number",block.RTWdata.InputGlobalDutyCycle)
%assign InputDutyCycleH = MchpVector(block.RTWdata.InputDutyCycleH)		
%assign InputDutyCycleL = MchpVector(block.RTWdata.InputDutyCycleL)		
%assign InputPhaseShiftH = MchpVector(block.RTWdata.InputPhaseShiftH)		
%assign InputPhaseShiftL = MchpVector(block.RTWdata.InputPhaseShiftL)		
%assign inputSEVTCMP = CAST("Number",block.RTWdata.inputSEVTCMP)
%assign InputTRIGx = MchpVector(block.RTWdata.InputTRIGx)		
%assign FLTMODx = MchpVector(block.RTWdata.FLTMODx)		
%assign OutputBlockFault = MchpVector(block.RTWdata.OutputBlockFault)		
%assign PWMCONx = MchpVector(block.RTWdata.PWMCONx)		
%assign FCLCONx = MchpVector(block.RTWdata.FCLCONx)		
%assign IOCONx = MchpVector(block.RTWdata.IOCONx)		
%assign SEVTCMP = MchpVector(block.RTWdata.SEVTCMP)		
%assign nSEVTCMP = SIZE(SEVTCMP,1)
%assign DBL_UPDATE = CAST("Number",block.RTWdata.DBL_UPDATE)
%assign PDCx_DblUpdate = MchpVector(block.RTWdata.PDCx_DblUpdate)
%assign SDCx_DblUpdate = MchpVector(block.RTWdata.SDCx_DblUpdate)
%assign ITB = CAST("Number",block.RTWdata.ITB)
%if ITB == 1
%assign PHASE_desc = "periode"
%assign SPHASE_desc = "periode"
%else
%assign PHASE_desc = "phase shift"
%assign SPHASE_desc = "phase shift"
%endif
%assign GS_Offset = 7	
%assign IndexInput = 0
%assign idx_DW = 0
%if InputGlobalPeriod == 1
%assign y = LibBlockInputSignal(IndexInput, "", "",0)
%assign IndexInput = IndexInput + 1
%if LibBlockInputSignalConnected(IndexInput-1)
%if (RTWGenSettings.DOS_00958_pwm_TLAH != "1") 
PTPER = %<y>; /* Global Period */
%else 
{
register unsigned int period = %<y>; /* remove -7 Offset using hardware saturation */		
__asm__ volatile(
"sub    #0x7,%[u1]     \n\t"      /* subtract 16 bits values */
"btss   SR,#0                 \n\t"   /* skip next instr if Carry(!Borrow) flag is set */
"clr    %[u1]                 \n\t"   /* otherwise, saturate to MIN uint16 */
: [u1] "+r"(period)
:
: "cc");                                                                                    		
PTPER = period; /* Global Period */		
}		
%endif		
%endif
%endif
%foreach idx = SIZE(InputPeriodH,1)
%if InputPeriodH[idx] != -1		
%assign y = LibBlockInputSignal(IndexInput, "", "",0)
%assign IndexInput = IndexInput + 1
%if LibBlockInputSignalConnected(IndexInput-1)
%if (RTWGenSettings.DOS_00958_pwm_TLAH != "1") 
PHASE%<idx+1> = %<y>; /* Period for Channel %<idx+1> */
%else 
{
register unsigned int period = %<y>; /* remove -7 Offset using hardware saturation */		
__asm__ volatile(
"sub    #0x7,%[u1]     \n\t"      /* subtract 16 bits values */
"btss   SR,#0                 \n\t"   /* skip next instr if Carry(!Borrow) flag is set */
"clr    %[u1]                 \n\t"   /* otherwise, saturate to MIN uint16 */
: [u1] "+r"(period)
:
: "cc");                                                                                    		
PHASE%<idx+1> = period; /* Period for Channel %<idx+1> */		
}						
%endif		
%endif
%endif
%if InputPeriodL[idx] != -1 
%assign y = LibBlockInputSignal(IndexInput, "", "",0)
%assign IndexInput = IndexInput + 1
%if LibBlockInputSignalConnected(IndexInput-1)
%if (RTWGenSettings.DOS_00958_pwm_TLAH != "1") 
SPHASE%<idx+1> = %<y>; /* Period for Channel %<idx+1> */
%else 
{
register unsigned int period = %<y>; /* remove -7 Offset using hardware saturation */		
__asm__ volatile(
"sub    #0x7,%[u1]     \n\t"      /* subtract 16 bits values */
"btss   SR,#0                 \n\t"   /* skip next instr if Carry(!Borrow) flag is set */
"clr    %[u1]                 \n\t"   /* otherwise, saturate to MIN uint16 */
: [u1] "+r"(period)
:
: "cc");                                                                                    		
SPHASE%<idx+1> = period; /* Period for Channel %<idx+1> */		
}						
%endif	
%endif
%endif
%endforeach
%if InputGlobalDutyCycle == 1
%assign y = LibBlockInputSignal(IndexInput, "", "",0)
%assign IndexInput = IndexInput + 1
%if LibBlockInputSignalConnected(IndexInput-1)
MDC = %<y>; /* Global Duty Cycle */
%endif
%endif
%if DBL_UPDATE
%assign MCHP_TRIG_DBL_UPDATE = LibBlockDWork(DWork[idx_DW], "", "", 0)
%assign idx_DW = idx_DW + 1
%endif
%assign Flag_DW_OneInputDutyCycle = 0
%foreach idx = SIZE(InputDutyCycleH,1)  
%if InputDutyCycleH[idx] != -1
%assign Flag_DW_OneInputDutyCycle = 1
%endif
%endforeach
%assign ITB = CAST("Number",block.RTWdata.ITB)
%assign Flag_DW = 0
%if DBL_UPDATE
%openfile tmp
%closefile tmp
%if Flag_DW_OneInputDutyCycle
if ( %<MCHP_TRIG_DBL_UPDATE> == 0)
{
%assign idx_PeriodStored = 0
%foreach idx = SIZE(InputDutyCycleH,1)
%if InputDutyCycleH[idx] != -1			
%if LibBlockInputSignalConnected(IndexInput)				
%openfile tmp ,"a"
%<LibBlockDWork(DWork[idx_DW], "", "", 0 + idx_PeriodStored * 4 )> = %<LibBlockInputSignal(IndexInput, "", "",1)>;
%<LibBlockDWork(DWork[idx_DW], "", "", 1 + idx_PeriodStored * 4)> = %<LibBlockInputSignal(IndexInput, "", "",0)>;
%closefile tmp					
%<LibBlockDWork(DWork[idx_DW], "", "", 2 + idx_PeriodStored * 4 )> = %<LibBlockInputSignal(IndexInput, "", "",1)>;
%<LibBlockDWork(DWork[idx_DW], "", "", 3 + idx_PeriodStored * 4)> = %<LibBlockInputSignal(IndexInput, "", "",0)>;
%assign idx_PeriodStored = idx_PeriodStored + 1
%endif
%assign IndexInput = IndexInput + 1
%assign Flag_DW = 1					
%endif
%endforeach
}
else
{
%<tmp>
}
%endif
%else
%foreach idx = SIZE(InputDutyCycleH,1)
%if InputDutyCycleH[idx] != -1							
%assign y = LibBlockInputSignal(IndexInput, "", "",0)
%assign IndexInput = IndexInput + 1
%if LibBlockInputSignalConnected(IndexInput-1)
PDC%<idx+1> = %<y>; /* duty cycle for Channel %<idx+1> */
%endif
%endif
%endforeach
%endif
%assign idx_DW = idx_DW + Flag_DW
%foreach idx = SIZE(InputDutyCycleL,1)
%if InputDutyCycleL[idx] != -1
%assign y = LibBlockInputSignal(IndexInput, "", "",0)
%assign IndexInput = IndexInput + 1
%if LibBlockInputSignalConnected(IndexInput-1)
SDC%<idx+1> = %<y>; /* duty cycle for Channel %<idx+1> */
%endif
%endif
%endforeach
%foreach idx = SIZE(InputPhaseShiftH,1)
%if InputPhaseShiftH[idx] != -1
%assign y = LibBlockInputSignal(IndexInput, "", "",0)
%assign IndexInput = IndexInput + 1
%if LibBlockInputSignalConnected(IndexInput-1)
PHASE%<idx+1> = %<y>; /* %<PHASE_desc> for Channel %<idx+1> */
%endif
%endif
%endforeach
%foreach idx = SIZE(InputPhaseShiftL,1)
%if InputPhaseShiftL[idx] != -1
%assign y = LibBlockInputSignal(IndexInput, "", "",0)
%assign IndexInput = IndexInput + 1
%if LibBlockInputSignalConnected(IndexInput-1)
SPHASE%<idx+1> = %<y>; /* %<SPHASE_desc> for Channel %<idx+1> */
%endif
%endif
%endforeach
%if inputSEVTCMP != -1
%if nSEVTCMP == 1
%assign y = LibBlockInputSignal(IndexInput, "", "",0)
%assign IndexInput = IndexInput + 1
%if LibBlockInputSignalConnected(IndexInput-1)
SEVTCMP = %<y>; /* Special Event Trigger (ADC) */
%endif
%else 
%assign idx_DW = idx_DW + 1	
%if LibBlockInputSignalConnected(IndexInput)
%foreach idx = (nSEVTCMP-1)
%<LibBlockDWork(DWork[idx_DW], "", "", idx)> = %<LibBlockInputSignal(IndexInput, "", "",idx+1)>;			/* Trig %<idx+2> */
%endforeach
SEVTCMP = %<LibBlockInputSignal(IndexInput, "", "",0)>;			/* Update first trig now to avoid one delay  */
%<LibBlockDWork(DWork[idx_DW], "", "", nSEVTCMP-1)> = %<LibBlockInputSignal(IndexInput, "", "",0)>;			/* Trig 1 : First trig moved at last position */
%endif
%assign IndexInput = IndexInput + 1
%assign idx_DW = idx_DW + 1
%endif
%endif
%foreach idx = SIZE(InputTRIGx,1)
%if InputTRIGx[idx] != -1
%assign y = LibBlockInputSignal(IndexInput, "", "",0)
%assign IndexInput = IndexInput + 1
%if LibBlockInputSignalConnected(IndexInput-1)
TRIG%<idx+1> = %<y>; /* ADC Trigger for PWM channel %<idx+1> */
%endif
%endif
%endforeach
%foreach idx = SIZE(InputPhaseShiftH,1)
%if FLTMODx[idx] == 0 
%assign y = LibBlockInputSignal(IndexInput, "", "",0)
%assign IndexInput = IndexInput + 1
%if LibBlockInputSignalConnected(IndexInput-1)
%assign val = IOCONx[idx]
%if EXISTS(::MCHP_IOCONx_OVERREN_OVERDAT)	
%if SIZE(::MCHP_IOCONx_OVERREN_OVERDAT,1) >= (idx+1)
%assign val = val + (%<::MCHP_IOCONx_OVERREN_OVERDAT[idx] << 6>)
%endif
%endif
if (0U != PWMCON%<idx+1>bits.FLTSTAT)	/* two steps: first is to disengage Fault so as to be able to re-enable it (1 PWM cycle is required in between the two steps) */
{
/* Fault exit: see doc DS70323E-page 43-74 */
if (FCLCON%<idx+1> != %<MchpHex(FCLCONx[idx] | 3)>)  /* first step: disengage */ 
{
%if EXISTS(::MCHP_IOCONx_OVERREN_OVERDAT)	
%if SIZE(::MCHP_IOCONx_OVERREN_OVERDAT,1) >= (idx+1)
MCHP_IOCON%<idx+1>_save = IOCON%<idx+1>; /* Save value to restore later, might be updated by the PWM HS Override block */
%endif
%endif
IOCON%<idx+1> = %<MchpHex((val & 65343) | 768 | ((val & 48) << 2) )>;	/* Set bits 6 & 7 to Fault value, and 8 & 9 to 1 */
FCLCON%<idx+1> = %<MchpHex(FCLCONx[idx] | 3)>;		/* Disable Fault on channel %<idx+1> */
}
else if (1U == %<y>)		/* Second step: re-engage */
{
PWMCON%<idx+1>bits.FLTSTAT = 0;
FCLCON%<idx+1> = %<MchpHex(FCLCONx[idx])>; 			/* RE enable Latched Fault mode on channel %<idx+1> */
%if EXISTS(::MCHP_IOCONx_OVERREN_OVERDAT)	
%if SIZE(::MCHP_IOCONx_OVERREN_OVERDAT,1) >= (idx+1)
IOCON%<idx+1> = MCHP_IOCON%<idx+1>_save;
%else
IOCON%<idx+1> = %<MchpHex(val )>;			/* reset override */
%endif
%else
IOCON%<idx+1> = %<MchpHex(val )>;			/* reset override */
%endif
PWMCON%<idx+1>bits.FLTIEN = 0;
PWMCON%<idx+1>bits.FLTIEN = 1;
}
}
%endif
%endif
%endforeach
%endfunction
%function Outputs(block, system) Output
%assign OutputBlockFault = MchpVector(block.RTWdata.OutputBlockFault)		
%assign OutputBlockCurrentLimit = MchpVector(block.RTWdata.OutputBlockCurrentLimit)		
%assign OutputBlockCurrentLimitTime = MchpVector(block.RTWdata.OutputBlockCurrentLimitTime)		
%assign IndexOutput = 0
%foreach idx = SIZE(OutputBlockFault,1)
%if OutputBlockFault[idx] != -1
%assign u = LibBlockOutputSignal(IndexOutput, "", "",0)
%assign IndexOutput = IndexOutput + 1
%if LibBlockOutputSignalConnected(IndexOutput-1)
%<u> = PWMCON%<OutputBlockFault[idx]>bits.FLTSTAT; /* Read Fault Status for one active channel */		
%endif
%endif
%endforeach
%foreach idx = SIZE(OutputBlockCurrentLimit,1)
%if OutputBlockCurrentLimit[idx] != -1
%assign u = LibBlockOutputSignal(IndexOutput, "", "",0)
%assign IndexOutput = IndexOutput + 1
%if LibBlockOutputSignalConnected(IndexOutput-1)
%<u> = PWMCON%<OutputBlockCurrentLimit[idx]>bits.CLSTAT; /* Current Limit Status for one active channel */		
%endif
%endif
%endforeach
%foreach idx = SIZE(OutputBlockCurrentLimitTime,1)
%if OutputBlockCurrentLimitTime[idx] != -1
%assign u = LibBlockOutputSignal(IndexOutput, "", "",0)
%assign IndexOutput = IndexOutput + 1
%if LibBlockOutputSignalConnected(IndexOutput-1)
%<u> = PWMCAP%<OutputBlockCurrentLimitTime[idx]>; /* Captured PWM Time Base value on leading edge of current-limit input */		
%endif
%endif
%endforeach
%endfunction
