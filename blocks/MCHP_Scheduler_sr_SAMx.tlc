%function MCHP_srScheduler(InterruptPrefix,InterruptNumber,ChipIdN) void
%assign MCHP_NEAR_MEM = Mchp_NEAR_MEM()
%openfile srScheduler
%if (::MCHP_srSchedulerOnInterrupt == 0)
{
extern volatile uint_T ContinueTimeStep %<MCHP_NEAR_MEM>; 
%openfile overload
%<MCHP_MCUOverload(0)>
%closefile overload
%if !WHITE_SPACE(overload)
if (ContinueTimeStep != 0)
{
%<overload>
}
%endif
%<Mchp_asm_ABset("ContinueTimeStep",0)>	
%<MCHP_RemoveCauseOfInterrupt(InterruptPrefix,InterruptNumber,ChipIdN)>
}
%else
%assign ::MASTER_BusyFlag = CAST("Number",RTWGenSettings.MASTER_BusyFlag)
%assign MASTER_BusyFlagPin = CAST("Number",%<::MASTER_BusyFlag % 16>)
%assign MASTER_BusyFlagLetter = STRINGOF([%<::MASTER_BusyFlag / 16 + 65>])
{
/* Re-enable timer or interrupt */		
%<MCHP_RemoveCauseOfInterrupt(InterruptPrefix,InterruptNumber,ChipIdN)>
%if (%<::MASTER_BusyFlag> != -1)
/* Set busy flag */
%<MCHP_SetOutputBit(MASTER_BusyFlag,1,"Set Busy Flag PIN")>				
%endif
/* Call model Scheduler */
%assign varbuf = LibWriteModelInputs()
%if !WHITE_SPACE(varbuf)
/* Remove conditional, and set model inputs here */
%<varbuf>\
%endif
%<::MCHP_TimeStep_BeforeExecution>
/* Step the model for base rate */
%<MCHP_ProfileTaskStart(0)>
%foreach iTask = LibNumSynchronousSampleTimes()	
%<MCHP_ProfileMCU_Compute(iTask)>
%endforeach
%<LibCallModelStep(0)>
%<MCHP_ProfileTaskStop(0)>
%assign varbuf = LibWriteModelOutputs()
%if !WHITE_SPACE(varbuf)
/* Remove conditional, and get model outputs here */
%<varbuf>\
%endif
%if (%<::MASTER_BusyFlag> != -1)
/* Release busy flag */
%<MCHP_SetOutputBit(MASTER_BusyFlag,0,"Release Busy Flag PIN")>				
%endif
%openfile overload
%<MCHP_MCUOverload(0)>
%closefile overload
%if !WHITE_SPACE(overload)
/* Overload Detection not implemented ! */
%endif
}
%endif
%closefile srScheduler
%return srScheduler
%endfunction
