
%if ::isPIC32C
%assign ::SERCOM_I2CM_CTRLA_SDAHOLD_DISABLE =					"SERCOM_I2CM_CTRLA_SDAHOLD_DIS"
%assign ::SERCOM_I2CM_CTRLA_SPEED_STANDARD_AND_FAST_MODE =	"SERCOM_I2CM_CTRLA_SPEED_SM"
%assign ::SERCOM_I2CM_CTRLA_SPEED_FASTPLUS_MODE =				"SERCOM_I2CM_CTRLA_SPEED_FMP"
%assign ::SERCOM_I2CM_CTRLA_SPEED_HIGH_SPEED_MODE =			"SERCOM_I2CM_CTRLA_SPEED_HS"
%assign ::SERCOM_I2CM_CTRLA_INACTOUT_DISABLE =				"SERCOM_I2CM_CTRLA_INACTOUT_DIS"
%else
%assign ::SERCOM_I2CM_CTRLA_SDAHOLD_DISABLE =					"SERCOM_I2CM_CTRLA_SDAHOLD_DISABLE"
%assign ::SERCOM_I2CM_CTRLA_SPEED_STANDARD_AND_FAST_MODE =	"SERCOM_I2CM_CTRLA_SPEED_STANDARD_AND_FAST_MODE"
%assign ::SERCOM_I2CM_CTRLA_SPEED_FASTPLUS_MODE =				"SERCOM_I2CM_CTRLA_SPEED_FASTPLUS_MODE"
%assign ::SERCOM_I2CM_CTRLA_SPEED_HIGH_SPEED_MODE =			"SERCOM_I2CM_CTRLA_SPEED_HIGH_SPEED_MODE"
%assign ::SERCOM_I2CM_CTRLA_INACTOUT_DISABLE =				"SERCOM_I2CM_CTRLA_INACTOUT_DISABLE"
%endif
%assign FirstState = 3
%function I2C_WriteDataRegister(I2CRef,MASTER,NB,value) Output
SERCOM%<I2CRef>_REGS->I2CM.SERCOM_DATA = %<value>; /* Write I2C data */
%endfunction
%function I2C_ReadDataRegister(I2CRef,MASTER,NB,writeTo) Output
%<writeTo> = SERCOM%<I2CRef>_REGS->I2CM.SERCOM_DATA; /* Read I2C data */
%endfunction
%function I2C_Write_NACK(I2CRef,MASTER,MCHP_I2Cx_State) Output
%return 0
%endfunction	
%function I2C_Write_ACK(I2CRef,MASTER,MCHP_I2Cx_State) Output
%return 0
%endfunction	
%function I2C_Enable(I2CRef) Output
SERCOM%<I2CRef>_REGS->I2CM.SERCOM_CTRLA |= SERCOM_I2CM_CTRLA_ENABLE_Msk; /* Enable I2C peripheral */
while ((SERCOM%<I2CRef>_REGS->I2CM.SERCOM_SYNCBUSY) != 0) ;/* SYNCBUSY */ 	
%endfunction
%function I2C_Disable(I2CRef) Output
SERCOM%<I2CRef>_REGS->I2CM.SERCOM_CTRLA &= ~SERCOM_I2CM_CTRLA_ENABLE_Msk; /* Disable I2C peripheral */
%endfunction
%function I2C_ResetStateError(I2CRef) Output
/* Writting to ADDR automatically clear errors */
SERCOM%<I2CRef>_REGS->I2CM.SERCOM_STATUS = SERCOM_I2CM_STATUS_BUSERR_Msk; /* CLEAR I2C BUS ERROR */
SERCOM%<I2CRef>_REGS->I2CM.SERCOM_ADDR = 0x55; 	
%endfunction
%function I2C_Reset(I2CRef) Output
SERCOM%<I2CRef>_REGS->I2CM.SERCOM_CTRLA = SERCOM_I2CM_CTRLA_SWRST_Msk; /* Reset I2C peripheral */
%endfunction
%function I2C_Start(I2CRef) Output
%return 0	
%endfunction
%function I2C_Restart(I2CRef,MCHP_I2Cx_State) Output
%return 0
%endfunction
%function I2C_Stop(I2CRef,NextNACK) Output
%return 0	
%endfunction
%function I2C_Receive(I2CRef,NextNACK) Output
%endfunction
%function I2C_isNACK(I2CRef) void
%return "(0U != (SERCOM%<I2CRef>_REGS->I2CM.SERCOM_STATUS & (SERCOM_I2CM_STATUS_RXNACK_Msk + SERCOM_I2CM_STATUS_ARBLOST_Msk + SERCOM_I2CM_STATUS_BUSERR_Msk )) )"
%endfunction
%function Set_SDA_SCL_DIT_Pin_Input(PIN_SDA,PIN_SCL) Output
%endfunction
%function Set_SDA_SCL_DIT_Pin_Output(PIN_SDA,PIN_SCL) Output
%endfunction
%function SetSDA_SCL_Output_0(PIN_SDA,PIN_SCL) Output
%endfunction
%function I2C_WriteAddress_DataReadReady(I2CRef,MASTER,NB,address,RW,AddressIsBlockInput,N_Read,MCHP_I2Cx_State) void
%assign out = 0
%if N_Read > 0
%assign out = 1	
%endif
%return out
%endfunction
%function I2C_WriteAddress(I2CRef,MASTER,NB,address,RW,AddressIsBlockInput,N_Read,MCHP_I2Cx_State) Output
%assign LEN = ""
%if N_Read > 0
%assign LEN = "| (SERCOM_I2CM_ADDR_LEN(%<N_Read>) + SERCOM_I2CM_ADDR_LENEN_Msk)"
/* Set Read of N_Read Bytes. First read follow directly Write Address. */
/* ACK set for all bytes but the last */
%endif
%if AddressIsBlockInput == 0
%switch NB
%case 10
/* send 10 bit address: %<address \>\> 1>  (%<MchpHex(address \>\> 1)>) */
SERCOM%<I2CRef>_REGS->I2CM.SERCOM_ADDR = %<MchpHex(address + 1 << 15)> %<LEN>;		/* Send I2C Address : [1 1 1 1 0 A9 A8 RW A7 ... A0] */
%break
%case 7
/* send 7 bit address: %<address \>\> 1>  (%<MchpHex(address \>\> 1)>) */
SERCOM%<I2CRef>_REGS->I2CM.SERCOM_ADDR = %<MchpHex(address)> %<LEN>;		/* Send I2C Address : [A6 ... A0 RW] */
%break
%endswitch	
%else 
%switch NB
%case 10		
%if RW == 1		
SERCOM%<I2CRef>_REGS->I2CM.SERCOM_ADDR = ( (%<address> << 1) + 1 + 1 << 15) %<LEN>;	 /* Send I2C 10 bit address [1 1 1 1 0 A9 A8 A7 .. A0 RW] */
%else
SERCOM%<I2CRef>_REGS->I2CM.SERCOM_ADDR = ( (%<address> << 1) + 1 << 15) %<LEN>;	 /* Send I2C 10 bit address [1 1 1 1 0 A9 A8 A7 .. A0 RW] */
%endif
%break
%case 7
%if RW == 1
SERCOM%<I2CRef>_REGS->I2CM.SERCOM_ADDR = ([%<address>] << 1) | 1 %<LEN>;	/* Send I2C Addresss + read bit: [A6 ... A0 RW] */
%else
SERCOM%<I2CRef>_REGS->I2CM.SERCOM_ADDR = (%<address> << 1) %<LEN>;	/* Send I2C Addresss + write bit: [A6 ... A0 RW] */
%endif	
%break
%default
%error("Address bit length is different from 7 or 10")
%endswitch
%endif
%return MCHP_I2Cx_State
%endfunction
%function I2C_Declare_Interrupt(I2CRef,IntPriority,UseUserInterrupt,block) Output	
%assign INTERRUPT_name1 = ""
%if (::MCHP_modsrc_Name.SERCOM.x[I2CRef].nvect >= 2)
%assign INTERRUPT_name0 = ::MCHP_modsrc_Name.SERCOM.x[I2CRef].vector[0] 
%assign INTERRUPT_name1 = ::MCHP_modsrc_Name.SERCOM.x[I2CRef].vector[1] 
%else
%assign INTERRUPT_name0 = ::MCHP_modsrc_Name.SERCOM.x[I2CRef].vector 
%endif
%if (ISEMPTY(INTERRUPT_name1) == 0)
/* Interrupt SERCOM %<I2CRef> 1: a byte is transmitted in Master Write mode */
void %<INTERRUPT_name0>_Handler(void);
/* Interrupt SERCOM %<I2CRef> 0: when SPI Data Register is Empty */
void %<INTERRUPT_name1>_Handler(void) __attribute__((alias("%<INTERRUPT_name0>_Handler")));	
%else
/* Interrupt SERCOM %<I2CRef> */
%endif
void %<INTERRUPT_name0>_Handler(void)		
%endfunction
%function I2C_InterruptsConfig(I2CRef,IntPriority) Output
%assign INTERRUPT_name1 = ""
%if (::MCHP_modsrc_Name.SERCOM.x[I2CRef].nvect >= 2)
%assign INTERRUPT_name0 = ::MCHP_modsrc_Name.SERCOM.x[I2CRef].vector[0] 
%assign INTERRUPT_name1 = ::MCHP_modsrc_Name.SERCOM.x[I2CRef].vector[1] 
%else
%assign INTERRUPT_name0 = ::MCHP_modsrc_Name.SERCOM.x[I2CRef].vector 
%endif
/* Configure I2C%<I2CRef> interrupt */
%if (ISEMPTY(INTERRUPT_name1) == 0)
NVIC_SetPriority(%<INTERRUPT_name0>_IRQn,%<IntPriority>);		/* Set I2C%<I2CRef> MB Interrupt Priority */
NVIC_EnableIRQ(%<INTERRUPT_name0>_IRQn);    		/* Enable NVIC line for I2C%<I2CRef> */		
NVIC_SetPriority(%<INTERRUPT_name1>_IRQn,%<IntPriority>);		/* Set I2C%<I2CRef> SB Interrupt Priority */
NVIC_EnableIRQ(%<INTERRUPT_name1>_IRQn);    		/* Enable NVIC line for I2C%<I2CRef> */	
%else
NVIC_SetPriority(%<INTERRUPT_name0>_IRQn,%<IntPriority>);		/* Set I2C%<I2CRef> Interrupt Priority */
NVIC_EnableIRQ(%<INTERRUPT_name0>_IRQn);    		/* Enable NVIC line for I2C%<I2CRef> */	
%endif	 	
SERCOM%<I2CRef>_REGS->I2CM.SERCOM_INTENSET = SERCOM_I2CM_INTENSET_SB_Msk;    /* Enable I2C%<I2CRef> interrupt */ 	 	
SERCOM%<I2CRef>_REGS->I2CM.SERCOM_INTENSET = SERCOM_I2CM_INTENSET_MB_Msk;    /* Enable I2C%<I2CRef> interrupt */
%endfunction
%function I2C_Trig_Interrupt(I2CRef,cmt) Output
%assign INTERRUPT_name1 = ""
%if (::MCHP_modsrc_Name.SERCOM.x[I2CRef].nvect >= 2)
%assign INTERRUPT_name0 = ::MCHP_modsrc_Name.SERCOM.x[I2CRef].vector[0] 
%assign INTERRUPT_name1 = ::MCHP_modsrc_Name.SERCOM.x[I2CRef].vector[1] 
%else
%assign INTERRUPT_name0 = ::MCHP_modsrc_Name.SERCOM.x[I2CRef].vector 
%endif
%if (ISEMPTY(INTERRUPT_name1) == 0)	
{
NVIC_ClearPendingIRQ(%<INTERRUPT_name1>_IRQn);  /* Merged I2C MS and SB interrupts to implementation */	
NVIC_SetPendingIRQ(%<INTERRUPT_name0>_IRQn); /* %<cmt> */		
}
%else
NVIC_SetPendingIRQ(%<INTERRUPT_name0>_IRQn); /* %<cmt> */		
%endif
%endfunction
%function I2C_DisableInterrupt() Output
%endfunction
%function Clear_I2C_Interrupt_Flag(I2CRef) Output	
SERCOM%<I2CRef>_REGS->I2CM.SERCOM_INTFLAG = SERCOM_I2CM_INTFLAG_MB_Msk + SERCOM_I2CM_INTFLAG_SB_Msk + SERCOM_I2CM_INTFLAG_ERROR_Msk;    /* Clear I2C%<I2CRef> interrupt Flags */		
%endfunction
%function I2C_Config(I2CRef,I2CSequence,idx) Output
/* ========================= SERCOM I2C %<I2CRef> Peripheral setup ========================= */		
/* Set-up I2C %<I2CRef> peripheral with Fsck = %<I2CSequence[idx+3]>   (%<I2CSequence[idx+2]> with  %<I2CSequence[idx+3]/(0.01*I2CSequence[idx+2]) - 100>% error) */ 			
while ((SERCOM%<I2CRef>_REGS->I2CM.SERCOM_SYNCBUSY) != 0) ;/* SYNCBUSY */
while((SERCOM%<I2CRef>_REGS->I2CM.SERCOM_STATUS & SERCOM_I2CM_STATUS_BUSSTATE_Msk) == SERCOM_I2CM_STATUS_BUSSTATE(2));  /* Finish Current transaction if any (while owner of the I2C BUS) */
%<I2C_Disable(I2CRef)>
while ((SERCOM%<I2CRef>_REGS->I2CM.SERCOM_SYNCBUSY) != 0) ;/* SYNCBUSY */
{
uint32_T tmp_reg;
/* SERCOM%<I2CRef> (I2CM)  APB clock */
%<Enable_Peripheral_Clock("SERCOM%<I2CRef>")>
SERCOM%<I2CRef>_REGS->I2CM.SERCOM_BAUD = %<MchpHex(I2CSequence[idx+4])>;   /* I2C clock = %<I2CSequence[idx+3]>  */
%assign tmp = CAST("Number",I2CSequence[idx+1])	
%assign I2C_Enabled = 1 & (tmp >> 15)	
%assign SMB_Threshold = 1 & (tmp >> 8)
%assign SlewRate = 1 & (tmp >> 9)
/* I2C CTRL B */
tmp_reg = SERCOM_I2CM_CTRLB_SMEN_Msk;	 /* Smart Mode, affect Read operations */	
SERCOM%<I2CRef>_REGS->I2CM.SERCOM_CTRLB = tmp_reg; /* I2C%<I2CRef> CTRLB */
%if ISEQUAL(::MCHP_modsrc_Name.SERCOM.version,"5.0.0")
/* I2C CTRL C */	
SERCOM%<I2CRef>_REGS->I2CM.SERCOM_CTRLC = 0; /* I2C%<I2CRef> CTRLC */
%endif
/* I2C CTRL A */
tmp_reg = SERCOM_I2CM_CTRLA_MODE_I2C_MASTER;	/* SERCOM%<I2CRef> is I2C Master */				
%if I2CSequence[idx+2] > 1000000
tmp_reg |= %<SERCOM_I2CM_CTRLA_SPEED_HIGH_SPEED_MODE>; /* High-speed mode Upto 3.4 MHz */
%elseif I2CSequence[idx+2] > 400000
tmp_reg |= %<SERCOM_I2CM_CTRLA_SPEED_FASTPLUS_MODE>;	/* up to 1 MHz*/		
%else
tmp_reg |= %<SERCOM_I2CM_CTRLA_SPEED_STANDARD_AND_FAST_MODE>; /* up to 400 kHz*/
%endif			
%if SMB_Threshold
tmp_reg |= SERCOM_I2CM_CTRLA_INACTOUT_205US;     /* 20-21 SCL Time-Out(200-210us)  */
%else
tmp_reg |= %<SERCOM_I2CM_CTRLA_INACTOUT_DISABLE>;  /* Disable SCL Time-out */
%endif
tmp_reg |= SERCOM_I2CM_CTRLA_LOWTOUTEN_Msk; /* SCL Low Time-Out Enabled */	
tmp_reg |= SERCOM_I2CM_CTRLA_RUNSTDBY_Msk; /* Run in Standby */				
tmp_reg |= SERCOM_I2CM_CTRLA_SCLSM_Msk;   /**< (SERCOM_I2CM_CTRLA) SCL Clock Stretch Mode Mask */		
SERCOM%<I2CRef>_REGS->I2CM.SERCOM_CTRLA = tmp_reg; /* I2C%<I2CRef> CTRLA & Enable */
while ((SERCOM%<I2CRef>_REGS->I2CM.SERCOM_SYNCBUSY) != 0) ;/* SYNCBUSY */ 	
tmp_reg |= SERCOM_I2CM_CTRLA_ENABLE_Msk; /* Enable */
SERCOM%<I2CRef>_REGS->I2CM.SERCOM_CTRLA = tmp_reg; /* I2C%<I2CRef> CTRLA & Enable */
while ((SERCOM%<I2CRef>_REGS->I2CM.SERCOM_SYNCBUSY) != 0) ;/* SYNCBUSY */ 	
SERCOM%<I2CRef>_REGS->I2CM.SERCOM_STATUS = SERCOM_I2CM_STATUS_BUSSTATE(1);    /* SET BUS state to IDLE */
while ((SERCOM%<I2CRef>_REGS->I2CM.SERCOM_SYNCBUSY) != 0) ;/* SYNCBUSY */      	
}
%endfunction
%function I2C_delay(time_s,param) Output
%error("I2C delay not implemented on PIC32 chip family. Remove delay from I2C Block")
%endfunction