%implements  MCHP_UART_TxMatlab  "C"
%include "MCHP_Functions.tlc"
%include "MCHP_UART_Tx_FunUtils.tlc"
%function Start(block, system) Output
%endfunction
%function BlockInstanceSetup(block, system) void
%<UART_Tx_BlockInstanceSetup(block)>
%endfunction
%function Update(block, system) Output
%if ::isSAMx7                                    
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%assign nUSART = CAST("Number",block.RTWdata.nUSART)	
%switch ::ChipIdL1
%case "SAME"
%case "SAMS"
%case "SAMV"
%if UARTRef > nUSART
%assign Per_Type = "UART"
%assign REG_NAME = "UART"
%assign REG_NAME2 = ""
%assign INTERRUPT_STATUS_REG = "SR"
%assign UART_Index = (UARTRef-1) - nUSART
%else
%assign Per_Type = "USART"
%assign REG_NAME = "US"
%assign REG_NAME2 = "USART_"
%assign INTERRUPT_STATUS_REG = "CSR"
%assign UART_Index = UARTRef-1
%endif
%assign UART_NAME = "%<Per_Type>%<UART_Index>"
%break
%case "SAMRH"
%assign Per_Type = "USART"
%assign REG_NAME = "FLEX_US"
%assign REG_NAME2 = ""
%assign INTERRUPT_STATUS_REG = "CSR"
%assign UART_Index = UARTRef-1
%assign UART_NAME = "FLEXCOM%<UART_Index>"
%break
%default
%error("Internal error with UART")
%endswitch
%elseif ::isSAMx5 || ::isSAMC2 || ::isPIC32C || ::isSAMD2_DA1
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%assign UART_NAME = UART_Tx_get_UART_NAME(block)
%elseif ::isdsPIC || ::isPIC32
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%assign UART_NAME = "UART%<UARTRef>"
%endif
%assign AllOrNothing = CAST("Number",block.RTWdata.AllOrNothing)
%assign BytesSent = CAST("Number",block.RTWdata.BytesSent)
%assign ControlChar = MchpVector(block.RTWdata.ControlChar)
%assign NbrDataBytes = MchpVector(block.RTWdata.NbrDataBytes)
%assign UART_HALF_DUPLEX_MODE = MchpVector(RTWGenSettings.UART_HALF_DUPLEX_MODE)
%assign UART_HALF_DUPLEX_MODE = UART_HALF_DUPLEX_MODE[UARTRef-1]
%assign TX_IMPLEMENTATION = MchpVector(RTWGenSettings.UART_TX_IMPLEMENTATION)
%assign TX_IMPLEMENTATION = TX_IMPLEMENTATION[UARTRef-1]		
%assign UART_TX_DMACHANNEL = MchpVector(RTWGenSettings.UART_TX_DMACHANNEL)
%assign TX_DMA_CHANNEL = UART_TX_DMACHANNEL[UARTRef-1]		
%assign ChipIdL1 = CAST("String",RTWGenSettings.ChipIdL1)
%assign ChipIdL2 = CAST("String",RTWGenSettings.ChipIdL2)
%assign ChipIdL3 = CAST("String",RTWGenSettings.ChipIdL3)
%assign ChipIdN =  CAST("String",RTWGenSettings.ChipIdN)
%assign ChipIdN = FEVAL("str2num",ChipIdN)
%assign ChipIdN = FEVAL("int32",ChipIdN)		
%assign UART_TX_THREAD_PROTECTION = MchpVector(RTWGenSettings.UART_TX_THREAD_PROTECTION)
%assign UART_TX_THREAD_PROTECTION = UART_TX_THREAD_PROTECTION[UARTRef-1]
%assign DMA_DCH = ""	
%if ::isdsPIC || ::isPIC32
%if ::isPIC32
%assign DMA_DCH = "DCH"	
%else
%assign DMA_DCH = "DMA"	
%endif
%endif
/* MCHP_UART_Tx-Matlab Block for %<UART_NAME>: %<Name>/Outputs */
%if TX_IMPLEMENTATION
%assign BlockInputLength = 2
%assign NSend_Input = 0
%assign N_in = ""		
%<UART_ThreadProtection(block,UARTRef,UART_TX_THREAD_PROTECTION,BlockInputLength,NSend_Input,N_in,"Start")>
%endif
%assign arrayRequired = 0
%foreach port = block.NumDataInputPorts
%switch NbrDataBytes[port]
%case 2
%case 4
%case 8
%assign arrayRequired = 1
%endswitch
%endforeach
%switch TX_IMPLEMENTATION
%case 0	
%error("UART TxMatlab block: UART TX is not configured, please select one implementation method in the %<UART_NAME> configuration block.")
%break
%case 1		
%error("UART TxMatlab block does not suport the selected UART Tx implementation (simplest) please use interrupt or DMA based implementation.")
%break
%case 2		
%assign TxBufferPtrType = CAST( "String","uint_T")	
{
%if arrayRequired
char* array;
%endif	
uint_T LocalTail = MCHP_%<UART_NAME>_Tx.tail;	/* Tail is a volatile variable. Use local variable to speed-up execution */	
%if AllOrNothing == 1
%<TxBufferPtrType> tmp;	
tmp = ~(LocalTail - MCHP_%<UART_NAME>_Tx.head);		
tmp = tmp & (Tx_BUFF_SIZE_%<UART_NAME> - 1);	/* Modulo Buffer Size */
if(tmp >= %<BytesSent>)	
{	
%foreach port = block.NumDataInputPorts
%assign rollVars = ["U"]
%roll sigIdx=RollRegions, lcv = RollThreshold, block, "Roller", rollVars				  	
/* CH %< (ControlChar[port] \>\> 4) +1> */
MCHP_%<UART_NAME>_Tx.buffer[LocalTail] = %<ControlChar[port]> ; /* Control byte */
LocalTail = (LocalTail + 1) & (Tx_BUFF_SIZE_%<UART_NAME> - 1);
%switch NbrDataBytes[port]
%case 1
%assign u = LibBlockInputSignal( port, "", lcv, sigIdx)
MCHP_%<UART_NAME>_Tx.buffer[LocalTail] = %<u> ;
LocalTail = (LocalTail + 1) & (Tx_BUFF_SIZE_%<UART_NAME> - 1);
%break
%case 2
%case 4
%case 8
%assign u = LibBlockInputSignalAddr( port, "", lcv, sigIdx)																		
array = (char*) %<u>;										
%foreach ia = NbrDataBytes[port]
MCHP_%<UART_NAME>_Tx.buffer[LocalTail] = array[%<ia>];
LocalTail = (LocalTail + 1) & (Tx_BUFF_SIZE_%<UART_NAME> - 1);
%endforeach																		
%break
%endswitch
%endroll
%endforeach
}
%else
volatile static uint_T index = 0;	
int_T tmp;
tmp = ~(LocalTail - MCHP_%<UART_NAME>_Tx.head);		
tmp = tmp & (Tx_BUFF_SIZE_%<UART_NAME> - 1);	/* Modulo Buffer Size */
if (tmp > %<BytesSent>)
tmp = %<BytesSent>;	/* Stop condition for do-while loop*/
do{
switch(index) {
%foreach port = block.NumDataInputPorts
case %<port>: 							/* CH %< (ControlChar[port] \>\> 4) +1> */
%assign rollVars = ["U"]
%roll sigIdx=RollRegions, lcv = RollThreshold, block, "Roller", rollVars							  	
%switch NbrDataBytes[port]
%case 1
tmp = tmp - 2;		
if (tmp < 0) break;
%assign u = LibBlockInputSignal( port, "", lcv, sigIdx)
MCHP_%<UART_NAME>_Tx.buffer[LocalTail] = %<ControlChar[port]> ; /* Control byte */
LocalTail = (LocalTail + 1) & (Tx_BUFF_SIZE_%<UART_NAME> - 1);
MCHP_%<UART_NAME>_Tx.buffer[LocalTail] = %<u> ;
LocalTail = (LocalTail + 1) & (Tx_BUFF_SIZE_%<UART_NAME> - 1);
%break
%case 2
%case 4
%case 8
tmp = tmp - %<NbrDataBytes[port]+1>;			
if (tmp < 0) break;
%assign u = LibBlockInputSignalAddr( port, "", lcv, sigIdx)
{
array = (char*) %<u>;
MCHP_%<UART_NAME>_Tx.buffer[LocalTail] = %<ControlChar[port]> ; /* Control byte */
LocalTail = (LocalTail + 1) & (Tx_BUFF_SIZE_%<UART_NAME> - 1);
%foreach ia = NbrDataBytes[port]
MCHP_%<UART_NAME>_Tx.buffer[LocalTail] = array[%<ia>];	
LocalTail = (LocalTail + 1) & (Tx_BUFF_SIZE_%<UART_NAME> - 1);
%endforeach
}
%break
%endswitch
if (++index >= %<block.NumDataInputPorts>) index = 0;
%endroll
%endforeach
}
}
while(tmp >= 1);	/* either buffer is full or we send all datas */	
%endif 
if (MCHP_%<UART_NAME>_Tx.tail != LocalTail){
MCHP_%<UART_NAME>_Tx.tail = LocalTail; /* Push back volatile variable */
%<UART_Tx_FlushCirculerBuffer(UART_HALF_DUPLEX_MODE,block)>
}
}
%break
%case 3		
%assign MEMORY_DMA_QUALIFIER = MchpDMA_MemoryQualifier()
%assign No_DMA_Transfert = Test_No_DMA_Transfert_F(DMA_DCH,TX_DMA_CHANNEL,UARTRef,block) 				
if (MCHP_%<UART_NAME>_Tx.overload != 1)
{
%<MEMORY_DMA_QUALIFIER> uint8_T*  BuffPtrList[] = {MCHP_%<UART_NAME>_Tx_bufferA,MCHP_%<UART_NAME>_Tx_bufferB};
%if arrayRequired
char* array;
%endif	
uint_T LocalTail = MCHP_%<UART_NAME>_Tx.tail;	/* Tail is a volatile variable. Use local variable to speed-up execution */	
%if AllOrNothing == 1
uint_T 	tmp;
tmp = (uint_T) Tx_BUFF_SIZE_%<UART_NAME> - LocalTail;	/* Free space in current buffer */
if (tmp >= %<BytesSent>)	 /* Enough space to send all %<BytesSent> Bytes at once ? */
{
%<MEMORY_DMA_QUALIFIER> uint8_T*  BuffPtr;
BuffPtr = BuffPtrList[MCHP_%<UART_NAME>_Tx.BufferAB];
%foreach port = block.NumDataInputPorts
%assign rollVars = ["U"]
%roll sigIdx=RollRegions, lcv = RollThreshold, block, "Roller", rollVars									  	
/* CH %< (ControlChar[port] \>\> 4) +1> */
BuffPtr[LocalTail++] = %<ControlChar[port]> ; /* Control byte */
%switch NbrDataBytes[port]
%case 1
%assign u = LibBlockInputSignal( port, "", lcv, sigIdx)
BuffPtr[LocalTail++] = %<u> ;
%break
%case 2
%case 4
%case 8
%assign u = LibBlockInputSignalAddr( port, "", lcv, sigIdx)														
array = (char*) %<u>;
%foreach ia = NbrDataBytes[port]
BuffPtr[LocalTail++] = array[%<ia>];
%endforeach																													
%break
%endswitch
%endroll
%endforeach
if (LocalTail >= (Tx_BUFF_SIZE_%<UART_NAME> ) )	/* Buffer Full ? switching buffer */
{UART%<UARTRef>PingPongSwitch(); LocalTail = 0;}							 							
}
#if Tx_BUFF_SIZE_%<UART_NAME> >= %<BytesSent> /* buffer switching might be required at anytime ! */
else if ( %<No_DMA_Transfert> && ( (uint_T) Tx_BUFF_SIZE_%<UART_NAME> >= %<BytesSent>)  )
#else
else if ( %<No_DMA_Transfert> && ((tmp + (uint_T) Tx_BUFF_SIZE_%<UART_NAME>) >= %<BytesSent>)  ) 			
#endif
{
%<MEMORY_DMA_QUALIFIER> uint8_T*  BuffPtr;
BuffPtr = BuffPtrList[MCHP_%<UART_NAME>_Tx.BufferAB];
%foreach port = block.NumDataInputPorts
%assign rollVars = ["U"]
%roll sigIdx=RollRegions, lcv = RollThreshold, block, "Roller", rollVars									  	
/* CH %< (ControlChar[port] \>\> 4) +1> */
BuffPtr[LocalTail++] = %<ControlChar[port]> ; /* Control byte */
if (LocalTail >= (Tx_BUFF_SIZE_%<UART_NAME> ) )	/* Buffer Full, require switching */
{UART%<UARTRef>PingPongSwitch(); LocalTail = 0;BuffPtr = BuffPtrList[MCHP_%<UART_NAME>_Tx.BufferAB];}
%switch NbrDataBytes[port]
%case 1
%assign u = LibBlockInputSignal( port, "", lcv, sigIdx)
BuffPtr[LocalTail++] = %<u> ;
if (LocalTail >= (Tx_BUFF_SIZE_%<UART_NAME> ) )	/* Buffer Full, require switching */
{UART%<UARTRef>PingPongSwitch(); LocalTail = 0;BuffPtr = BuffPtrList[MCHP_%<UART_NAME>_Tx.BufferAB];}
%break
%case 2
%case 4
%case 8
%assign u = LibBlockInputSignalAddr( port, "", lcv, sigIdx)														
array = (char*) %<u>;
%foreach ia = NbrDataBytes[port]
BuffPtr[LocalTail++] = array[%<ia>];
if (LocalTail >= (Tx_BUFF_SIZE_%<UART_NAME> ) )	/* Buffer Full, require switching */
{UART%<UARTRef>PingPongSwitch(); LocalTail = 0;BuffPtr = BuffPtrList[MCHP_%<UART_NAME>_Tx.BufferAB];}
%endforeach
%break
%endswitch
%endroll
%endforeach
}
%else 
static uint_T index = 0; 
int_T tmp;
%<MEMORY_DMA_QUALIFIER> uint8_T*  BuffPtr;
BuffPtr = BuffPtrList[MCHP_%<UART_NAME>_Tx.BufferAB];
tmp = (uint_T) Tx_BUFF_SIZE_%<UART_NAME> - LocalTail;	/* Free space in current buffer */
if (tmp >= %<BytesSent>)
{
tmp = %<BytesSent>;	/* Stop condition for do-while loop*/
do{  /* Send all at once, no buffer check required */
switch(index) {
%foreach port = block.NumDataInputPorts
case %<port>: 							/* CH %< (ControlChar[port] \>\> 4) +1> */
%assign rollVars = ["U"]
%roll sigIdx=RollRegions, lcv = RollThreshold, block, "Roller", rollVars								  	
%switch NbrDataBytes[port]
%case 1
%assign u = LibBlockInputSignal( port, "", lcv, sigIdx)
tmp = tmp - 2;		
BuffPtr[LocalTail++] = %<ControlChar[port]> ; /* Control byte */
BuffPtr[LocalTail++] = %<u> ;
%break
%case 2
%case 4
%case 8
%assign u = LibBlockInputSignalAddr( port, "", lcv, sigIdx)													
tmp = tmp - %<NbrDataBytes[port]+1>;			
array = (char*) %<u>;
BuffPtr[LocalTail++] = %<ControlChar[port]> ; /* Control byte */
%foreach ia = NbrDataBytes[port]
BuffPtr[LocalTail++] = array[%<ia>] ;	
%endforeach												
%break
%endswitch
%if port == (block.NumDataInputPorts-1)
index = 0;
%else
index++;
%endif
%endroll
%endforeach
}
}	while(tmp > 0);	/* either buffer is full or we send all datas */	
if (LocalTail >= (Tx_BUFF_SIZE_%<UART_NAME> ) )	/* Buffer Full, require switching */
{UART%<UARTRef>PingPongSwitch(); LocalTail = 0;}
} /* End if (tmp > %<BytesSent>)*/
else {
if %<No_DMA_Transfert>		/* If no ongoing DMA Transfer */				
tmp += Tx_BUFF_SIZE_%<UART_NAME>;	/* Take into account the other empty buffer */
do{
switch(index) {
%foreach port = block.NumDataInputPorts
case %<port>: 							/* CH %< (ControlChar[port] \>\> 4) +1> */
%assign rollVars = ["U"]
%roll sigIdx=RollRegions, lcv = RollThreshold, block, "Roller", rollVars								  	
%switch NbrDataBytes[port]
%case 1
%assign u = LibBlockInputSignal( port, "", lcv, sigIdx)
tmp = tmp - 2;		
if (tmp < 0)  break;
BuffPtr[LocalTail++] = %<ControlChar[port]> ; /* Control byte */
if ((LocalTail >= (Tx_BUFF_SIZE_%<UART_NAME> ) ) || (MCHP_%<UART_NAME>_Tx.overload != 1) ) /* Buffer Full, require switching */
{UART%<UARTRef>PingPongSwitch(); LocalTail = 0;BuffPtr = BuffPtrList[MCHP_%<UART_NAME>_Tx.BufferAB];}
BuffPtr[LocalTail++] = %<u> ;
if ((LocalTail >= (Tx_BUFF_SIZE_%<UART_NAME> ) ) || (MCHP_%<UART_NAME>_Tx.overload != 1) )	/* Buffer Full, require switching */
{UART%<UARTRef>PingPongSwitch(); LocalTail = 0;BuffPtr = BuffPtrList[MCHP_%<UART_NAME>_Tx.BufferAB];}
%break
%case 2
%case 4
%case 8
%assign u = LibBlockInputSignalAddr( port, "", lcv, sigIdx)
tmp = tmp - %<NbrDataBytes[port]+1>;			
if (tmp < 0) break;													
array = (char*) %<u>;												
BuffPtr[LocalTail++] = %<ControlChar[port]> ; /* Control byte */
if ((LocalTail >= (Tx_BUFF_SIZE_%<UART_NAME> ) ) || (MCHP_%<UART_NAME>_Tx.overload != 1) )	/* Buffer Full, require switching */
{UART%<UARTRef>PingPongSwitch(); LocalTail = 0;BuffPtr = BuffPtrList[MCHP_%<UART_NAME>_Tx.BufferAB];}
%foreach ia = NbrDataBytes[port]															
BuffPtr[LocalTail++] = array[%<ia>] ;	/* LSB First*/
if ((LocalTail >= (Tx_BUFF_SIZE_%<UART_NAME> ) ) || (MCHP_%<UART_NAME>_Tx.overload != 1) )	/* Buffer Full, require switching */
{UART%<UARTRef>PingPongSwitch(); LocalTail = 0;BuffPtr = BuffPtrList[MCHP_%<UART_NAME>_Tx.BufferAB];}													
%endforeach													
%break
%endswitch
%if port == (block.NumDataInputPorts-1)
index = 0;
%else
index++;
%endif
%endroll
%endforeach
}
} while ((tmp > 0) || (MCHP_%<UART_NAME>_Tx.overload != 1)) ;	/* either buffer is full or we send all datas */	
} /* End else if (tmp > %<BytesSent>)*/
%endif
MCHP_%<UART_NAME>_Tx.tail = LocalTail; /* Push back volatile variable */
} /* end of if (MCHP_%<UART_NAME>_Tx.overload != 1) */
%openfile dspicfun = "MCHP_UART%<UARTRef>_PingPongSwitch.c"				
#include "%<LibGetMdlPubHdrBaseName()>.h"
#include "%<LibGetMdlPubHdrBaseName()>_private.h"
void UART%<UARTRef>PingPongSwitch() 
{									
if (!%<No_DMA_Transfert>) /* If still ongoing DMA Transfer */
{	
MCHP_%<UART_NAME>_Tx.overload = 1;	
%<Enable_Tx_DMA_interrupt(TX_DMA_CHANNEL,"Buffer full, other buffer beeing send through DMA : Enable Interrupt to start DMA Transfer of buffer full as soon as current buffer is sent.")>				
}
else
{
%<UART_Tx_DMA_Send_SwitchBuffer(UART_NAME,TX_DMA_CHANNEL,ChipIdN,ChipIdL1)>								
}									
}
%closefile dspicfun
%openfile buffer
extern void UART%<UARTRef>PingPongSwitch();	/* DMA buffer switch for UART %<UARTRef> */
%closefile buffer
%<LibCacheExtern(buffer)>			
%break
%case 4		
%assign MEMORY_DMA_QUALIFIER = MchpDMA_MemoryQualifier()
%assign UART_TX_DMACHANNEL = MchpVector(RTWGenSettings.UART_TX_DMACHANNEL)
%assign TX_DMA_CHANNEL = UART_TX_DMACHANNEL[UARTRef-1]		
%assign No_DMA_Transfert = Test_No_DMA_Transfert_F(DMA_DCH,TX_DMA_CHANNEL,UARTRef,block) 				
if %<No_DMA_Transfert>		/* If no ongoing DMA Transfer */				
{
uint_T LocalTail = MCHP_%<UART_NAME>_Tx.tail;	/* Tail is a volatile variable. Use local variable to speed-up execution */						
%if arrayRequired
char* array;
%endif	
%if AllOrNothing == 1
if ((Tx_BUFF_SIZE_%<UART_NAME> - LocalTail) >= %<BytesSent> )	/* Enough space to send all %<BytesSent> Bytes ?*/
%foreach port = block.NumDataInputPorts
%assign rollVars = ["U"]
%roll sigIdx=RollRegions, lcv = RollThreshold, block, "Roller", rollVars					  	
/* CH %< (ControlChar[port] \>\> 4) +1> */
MCHP_%<UART_NAME>_Tx_buffer[LocalTail++] = %<ControlChar[port]> ; /* Control byte */
%switch NbrDataBytes[port]
%case 1
%assign u = LibBlockInputSignal( port, "", lcv, sigIdx)
MCHP_%<UART_NAME>_Tx_buffer[LocalTail++] = %<u> ;
%break
%case 2
%case 4
%case 8
%assign u = LibBlockInputSignalAddr( port, "", lcv, sigIdx)									
array = (char*) %<u>;
%foreach ia = NbrDataBytes[port]
MCHP_%<UART_NAME>_Tx_buffer[LocalTail++] = array[%<ia>];
%endforeach 									
%break
%endswitch
%endroll
%endforeach
%else
volatile static uint_T index = 0; 
int_T tmp;
tmp = (Tx_BUFF_SIZE_%<UART_NAME> - LocalTail);
if (tmp > %<BytesSent>)
tmp = %<BytesSent>;	/* Stop condition for do-while loop*/
do{
switch(index) {
%foreach port = block.NumDataInputPorts
case %<port>: 							/* CH %< (ControlChar[port] \>\> 4) +1> */
%assign rollVars = ["U"]
%roll sigIdx=RollRegions, lcv = RollThreshold, block, "Roller", rollVars							  	
%switch NbrDataBytes[port]
%case 1
%assign u = LibBlockInputSignal( port, "", lcv, sigIdx)
tmp = tmp - 2;		
if (tmp < 0) break;
MCHP_%<UART_NAME>_Tx_buffer[LocalTail++] = %<ControlChar[port]> ; /* Control byte */
MCHP_%<UART_NAME>_Tx_buffer[LocalTail++] = %<u> ;
%break
%case 2
%assign u = LibBlockInputSignalAddr( port, "", lcv, sigIdx)
tmp = tmp - %<NbrDataBytes[port]+1>;			
if (tmp < 0) break;																								
array = (char*) %<u>;
MCHP_%<UART_NAME>_Tx_buffer[LocalTail++] = %<ControlChar[port]> ; /* Control byte */
%foreach ia = NbrDataBytes[port]
MCHP_%<UART_NAME>_Tx_buffer[LocalTail++] = array[%<ia>];
%endforeach												
%break
%endswitch
%if port == (block.NumDataInputPorts-1)
index = 0;
%else
index++;
%endif										
%endroll
%endforeach
}
}
while(tmp >= 1);	/* either buffer is full or we send all datas */	
%endif
if (LocalTail >= (Tx_BUFF_SIZE_%<UART_NAME> ) )
{
%<UART_Tx_SingleBuffer_RequestDMATransfert(TX_DMA_CHANNEL,UART_NAME,block)>
LocalTail = 0;
}
MCHP_%<UART_NAME>_Tx.tail = LocalTail; /* Push back volatile variable */
}
%break
%endswitch
%if TX_IMPLEMENTATION
%assign BlockInputLength = 2
%assign NSend_Input = 0
%assign N_in = ""		
%<UART_ThreadProtection(block,UARTRef,UART_TX_THREAD_PROTECTION,BlockInputLength,NSend_Input,N_in,"Stop")>
%endif
%endfunction
%function Outputs(block, system) Output
%endfunction
