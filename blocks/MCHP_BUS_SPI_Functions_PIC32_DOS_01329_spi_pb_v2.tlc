
%function DataReadRegister(NB,SPIRef,MASTER) void
%return "SPI%<SPIRef>BUF"
%endfunction
%function DataWriteRegister(NB,SPIRef,MASTER) void
%return "SPI%<SPIRef>BUF"
%endfunction
%function WriteDataRegister(SPIRef,MASTER,NB,value) Output
%<DataWriteRegister(NB,SPIRef,MASTER)> = %<value>;
%endfunction
%function ReadDataRegister(SPIRef,MASTER,NB,writeTo) Output
%<writeTo> = %<DataReadRegister(NB,SPIRef,MASTER)>;
%endfunction
%function Declare_SPI_Interrupt(SPIRef,IntPriority,MASTER,UseUserInterrupt,block) Output
/* Implement SPI %<SPIRef> TX Interrupts */		
%<Mchp_Interrupt32(IntPriority,1,UseUserInterrupt,"SPI%<SPIRef>_TX_VECTOR",block)>  
%endfunction
%function Declare_DMA_Interrupt(intRef,IntPriority,MASTER,UseUserInterrupt,block) Output
/* Implement DMA %<intRef> Interrupts for SPI */				
%<Mchp_Interrupt32(IntPriority,1,UseUserInterrupt,"DMA%<intRef>_VECTOR",block)>  
%endfunction
%function SPI_InterruptsConfig(SPIRef,IntPriority) Output
/* Configure SPI%<SPIRef> Tx tnterrupt */
%<MCHP_SFR( "SPI%<SPIRef>TXIP" , IntPriority , "Set SPI%<SPIRef>TX Interrupt Priority" )>
%endfunction
%function Configure_DMA_Rx(DMA_Rx,SPIRef,SPIBUF,MASTER) Output
DMACONSET = 0x8000;	/* Enable DMA Controller */
/* DMA Setup Rx setting which will remains constants */
DCH%<DMA_Rx>CON = 2;	/* DMA Priority, within [0-3] */					
DCH%<DMA_Rx>ECON = (_SPI%<SPIRef>_RX_VECTOR << 8)  + %<MchpHex( (1U << 4) ) >;	/* DMA initiate SPI transfert when Rx buffer is not empty */
DCH%<DMA_Rx>SSIZ = %<NB/8>;	/* Source Size is %<NB/8> within %<SPIBUF> */ 					
DCH%<DMA_Rx>CSIZ = %<NB/8>;	/* %<NB/8> byte per SPI transfert request */									
DCH%<DMA_Rx>SSA = (volatile unsigned int) &%<SPIBUF> & 0x1FFFFFFF;	/* Physical Address for SPI BUF register */		
%endfunction
%function Configure_DMA_Tx(DMA_Tx,SPIRef,SPIBUF,MASTER) Output
DMACONSET = 0x8000;	/* Enable DMA Controller */
DCH%<DMA_Tx>CON = 2;	/* Priority, within [0-3] */					
DCH%<DMA_Tx>ECON = (_SPI%<SPIRef>_TX_VECTOR << 8)  + %<MchpHex( (1U << 4) ) >;	
DCH%<DMA_Tx>DSIZ = %<NB/8>;	/* Destination size is %<NB/8> to %<SPIBUF> */
DCH%<DMA_Tx>CSIZ = %<NB/8>;	/* %<NB/8> byte per SPI transfert request */														
DCH%<DMA_Tx>DSA = (volatile unsigned int) &%<SPIBUF> & 0x1FFFFFFF;	/* Physical Address for SPI BUF register */	
%endfunction
%function SPI_DMA_Rx_InterruptsConfig(DMA_Rx,MASTER) Output
DCH%<DMA_Rx>INTCLR = 0x00FF00FF; 	/* Clear existing event, disable all interrupts */
DCH%<DMA_Rx>INTSET = 0x00090000; 	/* Enable Block Complete interrupt and error interrupts */						
%<MCHP_SFR( "DMA%<DMA_Rx>IP" , IntPriority , "Set DMA interrupt priority" )>				    	
%<MCHP_SFR( "DMA%<DMA_Rx>IF" , 0 , "Clear DMA%<DMA_Rx> Interrupt Flag" )>				
%<MCHP_SFR( "DMA%<DMA_Rx>IE" , 1 , "Enable DMA%<DMA_Rx> Interrupt" )>	
%endfunction
%function EnableAndTrig_DMA_Interrupt(intRef,MASTER) Output
%<MCHP_SFR( "DMA%<intRef>IF" , 1 , "Force Interrupt" )>
%endfunction
%function Clear_DMA_Interrupt_Flag(intRef,MASTER) Output
DCH%<intRef>INTCLR = 0xFF;	
%<MCHP_SFR( "DMA%<intRef>IF" , 0 , "Clear DMA%<intRef> Interrupt Flag" )>  
%endfunction
%function DisableInterrupt_DMA_Tx(DMA_Tx,MASTER) Output
DMA%<DMA_Tx>CONbits.CHEN = 0;  /* Disable DMA Tx */
%endfunction
%function DisableInterrupt_DMA_Rx(DMA_Rx,MASTER) Output
DMA%<DMA_Rx>CONbits.CHEN = 0;  /* Disable DMA Rx */
%endfunction
%function EnableAndTrig_Interrupt(SPIRef,MASTER) Output
%<MCHP_SFR( "SPI%<SPIRef>TXIF" , 1 , "Force Interrupt" )>	
%<MCHP_SFR( "SPI%<SPIRef>TXIE" , 1 , "Force Interrupt" )>
%endfunction
%function DisableInterrupt(SPIRef,MASTER) Output
%<MCHP_SFR( "SPI%<SPIRef>TXIE" , 0 , "Disable Interrupt" )>	
%endfunction
%function Clear_SPI_Interrupt_Flag(SPIRef,MASTER) Output
%endfunction
%function EnableSPI(SPIRef,MASTER) Output
SPI%<SPIRef>STATbits.SPIROV = 0; /* Reset possible receive overflow */
SPI%<SPIRef>CONbits.ON = 1; 	/* Enable SPI */
%endfunction
%function DisableSPI(SPIRef,MASTER,cmt) Output	
SPI%<SPIRef>CONbits.ON = 0;	/* %<cmt> */
%endfunction
%function SPIConfig(SPIRef,Exist_EnhancedSPIBuff,idx,SPISequence,useDMA,MASTER) Output
/* Set-up SPI %<SPIRef> peripheral with Fsck = %<SPISequence[idx+5]>  (%<SPISequence[idx+4]> with  %<SPISequence[idx+5]/(0.01*SPISequence[idx+4]) - 100> % error)  */
SPI%<SPIRef>STAT = 0;				
SPI%<SPIRef>CON2 = 0;	
SPI%<SPIRef>BRG =  %<MchpHex(SPISequence[idx+6])>;	
%if Exist_EnhancedSPIBuff && !useDMA			
SPI%<SPIRef>CON =  %<MchpHex(SPISequence[idx+1] + ( 1U << 16 ) )>; 
%else					
SPI%<SPIRef>CON =  %<MchpHex(SPISequence[idx+1] +  0 )>;
%endif
%endfunction