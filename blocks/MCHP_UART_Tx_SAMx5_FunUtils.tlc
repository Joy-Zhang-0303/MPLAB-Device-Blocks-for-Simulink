
%function UART_Tx_get_UART_NAME(block) void
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%assign UART_NAME = "USART%<UARTRef-1>"
%return UART_NAME
%endfunction	
%function UTXEmpty(block) void
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%return "(0U != (SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_DRE_Msk))"
%endfunction
%function UTXNotEmpty(block) void
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%return "(0U == (SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_DRE_Msk))"
%endfunction
%function UTX_NotCompleted(block) void
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%return "(0U == (SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_TXC_Msk))"
%endfunction
%function UTX_Completed(block) void
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%return "(0U != (SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_INTFLAG & SERCOM_USART_INT_INTFLAG_TXC_Msk))"
%endfunction
%function UART_Tx_WriteRegister(block) void
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%return "SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_DATA"
%endfunction
%function Test_No_DMA_Transfert_F(DMA_DCH,TX_DMA_CHANNEL,UARTRef,block) void
%assign UART_NAME = UART_Tx_get_UART_NAME(block)
%error "Test_No_DMA_Transfert_F Not implemented yet on SAM5x"
%return "( !((XDMAC_REGS->XDMAC_CHID[%<TX_DMA_CHANNEL>].XDMAC_CC & (XDMAC_CC_WRIP_Msk | XDMAC_CC_RDIP_Msk))  ||  ((%<UART_NAME>_REGS->%<REG_NAME>_%<INTERRUPT_STATUS_REG> & %<REG_NAME>_%<INTERRUPT_STATUS_REG>_%<REG_NAME2>TXRDY_Msk) == 0)) )"
%endfunction
%function Enable_Tx_DMA_interrupt(TX_DMA_CHANNEL,comment) Output	
%error "Enable_Tx_DMA_interrupt Not implemented yet on SAM5x"
XDMAC_REGS->XDMAC_GIE |= XDMAC_GIE_IE%<TX_DMA_CHANNEL>(1); /* %<comment> */
%endfunction
%function UART_Tx_SingleBuffer_RequestDMATransfert(TX_DMA_CHANNEL,UART_NAME,block) Output
%assign UART_NAME = UART_Tx_get_UART_NAME(block)
%error "UART_Tx_SingleBuffer_RequestDMATransfert Not implemented yet on SAM5x"
XDMAC_REGS->XDMAC_CHID[%<TX_DMA_CHANNEL>].XDMAC_CSA = (uint32_t)MCHP_%<UART_NAME>_Tx_buffer;   /* Set source address */
XDMAC_REGS->XDMAC_GE |= XDMAC_GE_EN%<TX_DMA_CHANNEL>_Msk;   /* Enable DMA channel%<TX_DMA_CHANNEL> and start data transfer */
%endfunction
%function UART_Tx_DMA_Send_SwitchBuffer(UART_NAME,TX_DMA_CHANNEL,ChipIdN,ChipIdL1) Output
%error "UART_Tx_SingleBuffer_RequestDMATransfert Not implemented yet on SAM5x"
switch (MCHP_%<UART_NAME>_Tx.BufferAB){
case 0:
XDMAC_REGS->XDMAC_CHID[%<TX_DMA_CHANNEL>].XDMAC_CSA = (uint32_t)MCHP_%<UART_NAME>_Tx_bufferA;   /* Set source address */
MCHP_%<UART_NAME>_Tx.BufferAB = 1;
break;
case 1:
XDMAC_REGS->XDMAC_CHID[%<TX_DMA_CHANNEL>].XDMAC_CSA = (uint32_t)MCHP_%<UART_NAME>_Tx_bufferB;   /* Set source address */
MCHP_%<UART_NAME>_Tx.BufferAB = 0;
break;
}
%<ISB()>
%<DSB()>
volatile uint32_t dma_status = XDMAC_REGS->XDMAC_CHID[%<TX_DMA_CHANNEL>].XDMAC_CIS;    /* Clear the DMA Channel interrupt flag */
NVIC_ClearPendingIRQ(XDMAC_IRQn); /* Clear XDMAC pending interrupt flag */
XDMAC_REGS->XDMAC_GE |= XDMAC_GE_EN%<TX_DMA_CHANNEL>_Msk;   /* Enable DMA channel%<TX_DMA_CHANNEL> and start data transfer */
%endfunction
%function UART_Tx_FlushCirculerBuffer(UART_HALF_DUPLEX_MODE,block) Output
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%assign UART_NAME = UART_Tx_get_UART_NAME(block)
%assign TX_INT_PRIORITY = CAST("Number",block.RTWdata.TX_INT_PRIORITY)
%if UART_HALF_DUPLEX_MODE
/* Half duplex: Enable Tx, Disable Rx */
{
uint32_T tmp_reg;                                                       /* Switch to Tx only */
tmp_reg = SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_CTRLB;
tmp_reg &= ~(uint32_T) SERCOM_USART_INT_CTRLB_RXEN_Msk;         /* Disable Rx */
tmp_reg |= SERCOM_USART_INT_CTRLB_TXEN_Msk;                 /* Enable Tx */
SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_CTRLB = tmp_reg; /* Write back UART setting */
}
%endif
%if (LibBlockSampleTime(block) == -1) || (TX_INT_PRIORITY >= 5)
SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_INTENSET = SERCOM_USART_INT_INTENSET_DRE_Msk;   /* Enable UART%<UARTRef-1> Tx interrupt on empty Data register */		
%else
{						
uint_T LocalHead;
SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_INTENCLR = (SERCOM_USART_INT_INTENCLR_DRE_Msk | SERCOM_USART_INT_INTENCLR_TXC_Msk);       /* Disable Tx Interrupt protecting against possible concurrent access */
%<ISB()>    
%<DSB()>
LocalHead = MCHP_%<UART_NAME>_Tx.head;	/* Head is a volatile variable. Use local variable to speed-up execution */					
while ( ( (SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_INTFLAG) & SERCOM_USART_INT_INTFLAG_DRE_Msk ) && (MCHP_%<UART_NAME>_Tx.tail != LocalHead) ) /* while Tx buffer is not full */
{ 									
SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_DATA = MCHP_%<UART_NAME>_Tx.buffer[LocalHead];
LocalHead = (LocalHead + 1) & (Tx_BUFF_SIZE_%<UART_NAME> - 1);
}
MCHP_%<UART_NAME>_Tx.head = LocalHead; /* Push back volatile variable */
%if UART_HALF_DUPLEX_MODE == 1		
SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_INTENSET = SERCOM_USART_INT_INTENSET_DRE_Msk;    /* Enable UART%<UARTRef-1> Tx interrupt on empty Data register */
%else								
if (MCHP_%<UART_NAME>_Tx.tail != LocalHead)		/* If remaining values to send present in the circular buffer */				
SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_INTENSET = SERCOM_USART_INT_INTENSET_DRE_Msk;    /* Enable UART%<UARTRef-1> Tx interrupt on empty Data register */
%endif
}
%endif	
%endfunction