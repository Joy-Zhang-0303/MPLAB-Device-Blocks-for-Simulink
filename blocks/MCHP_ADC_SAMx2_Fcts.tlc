
%function Start_ADC_SAMx2_x5_fct(block, system) Output
%assign isPresent =  CAST("Number",block.RTWdata.isPresent)
%assign isADC0 =  CAST("Number",block.RTWdata.isADC0)
%assign isADC =  CAST("Number",block.RTWdata.isADC)
%assign mConvPerSeq =  CAST("Number",block.RTWdata.mConvPerSeq)
%assign mSeq =  CAST("Number",block.RTWdata.mSeq)
%assign GCLK_FCY =  CAST("Number",block.RTWdata.GCLK_FCY)
%assign GCLK_idx =  CAST("Number",block.RTWdata.GCLK_idx)
%assign PRESCALER =  CAST("Number",block.RTWdata.PRESCALER)
%assign FADC =  CAST("Number",block.RTWdata.FADC)
%assign ADCREF =  MchpVector64(block.RTWdata.ADCREF)
%assign Resolution =  MchpVector64(block.RTWdata.Resolution)
%assign SampleTime_s =  MchpVectorDbl(block.RTWdata.SampleTime_s)
%assign TrigSource =  MchpVector64(block.RTWdata.TrigSource)
%assign UseEventSystem = CAST("Number",block.RTWdata.UseEventSystem)
%assign TrigTimeStep =  MchpVector64(block.RTWdata.TrigTimeStep)
%assign ADC0_AINx =  MchpVector64(block.RTWdata.ADC0_AINx)
%assign ADC1_AINx =  MchpVector64(block.RTWdata.ADC1_AINx)
%assign nSeq =  CAST("Number",block.RTWdata.nSeq)
%assign ADC0_AINx_unique =  MchpVector64(block.RTWdata.ADC0_AINx_unique)
%assign ADC0_AINx_unique_map =  MchpVector64(block.RTWdata.ADC0_AINx_unique_map)
%assign ADC1_AINx_unique =  MchpVector64(block.RTWdata.ADC1_AINx_unique)
%assign ADC1_AINx_unique_map =  MchpVector64(block.RTWdata.ADC1_AINx_unique_map)
%assign ADC0_AINx_unique_i =  MchpVector64(block.RTWdata.ADC0_AINx_unique_i)
%assign ADC1_AINx_unique_i =  MchpVector64(block.RTWdata.ADC1_AINx_unique_i)
%assign ADCxbuff =  MchpVector64(block.RTWdata.ADCxbuff)
%assign SAMPLEN =  MchpVector64(block.RTWdata.SAMPLEN)
%if isADC0
%assign ADC_01 = ["ADC0", "ADC1"]	
%else
%assign ADC_01 = ["ADC", "xxx"]
%endif
%if ::isSAMC2  || ::isPIC32C
%assign SYNCBUSY = "ADC_SYNCBUSY"
%assign SchedulerInterrupt = "TC0"
%elseif ::isSAMD2_DA1 
%assign SYNCBUSY = "ADC_STATUS"
%assign SchedulerInterrupt = "PM"
%endif
/* ========================= ADC Peripheral setup ========================= */
{
const uint32_T * OTP_CAL_Ptr = (uint32_T *) 0x806020; /* NVM Software Calibration Area Mapping (@ 0x806020) */
uint32_T tmp_reg;
%if ADCREF[0] == 1	
%if ::isSAMC2 || ::isPIC32C  
GCLK_REGS->GCLK_PCHCTRL[33] = 0x40;							/* GCLK 0 used by ADC0 */
%elseif ::isSAMD2_DA1 
GCLK_REGS->GCLK_CLKCTRL= GCLK_CLKCTRL_GEN_GCLK0 | GCLK_CLKCTRL_CLKEN_Msk |  GCLK_CLKCTRL_ID_ADC; /* GCLK 0 used by ADC */
%else
%error("Internal error with ADC Clock scheme.")
%endif
%if ::isSAMC2 || ::isPIC32C  
/* ADC_01[0] APB clock */
%<Enable_Peripheral_Clock(ADC_01[0])>
%elseif ::isSAMD2_DA1 	
/* ADC_01[0] APB clock */
%<Enable_Peripheral_Clock(ADC_01[0])>   		
%endif
%endif
%if ADCREF[1] == 1	
GCLK_REGS->GCLK_PCHCTRL[34] = 0x40;/* GCLK 0 used by ADC1 */
/* ADC1 APB clock */
%<Enable_Peripheral_Clock("ADC1")>       	
%endif
%if UseEventSystem 		
/* Event Channel 0 Configuration */
%<Enable_Peripheral_Clock("EVSYS")>	
%if ::isSAMC2 || ::isPIC32C  
EVSYS_REGS->EVSYS_CHANNEL[0] = EVSYS_CHANNEL_EVGEN(0x23) | EVSYS_CHANNEL_PATH_ASYNCHRONOUS | EVSYS_CHANNEL_EDGSEL_RISING_EDGE ;	
GCLK_REGS->GCLK_PCHCTRL[6] = 0x40;         /* EVSYS0 clock used ref is 6  */				
%elseif ::isSAMD2_DA1 
EVSYS_REGS->EVSYS_CHANNEL = EVSYS_CHANNEL_CHANNEL(0) | EVSYS_CHANNEL_EVGEN(0x22) | EVSYS_CHANNEL_PATH_ASYNCHRONOUS | EVSYS_CHANNEL_EDGSEL_RISING_EDGE ;	
GCLK_REGS->GCLK_CLKCTRL = GCLK_CLKCTRL_GEN_GCLK0 | GCLK_CLKCTRL_CLKEN_Msk |  GCLK_CLKCTRL_ID_EVSYS_0; /* GCLK 0 used by EVSYS0 */
%endif
%if ::isSAMC2 || ::isPIC32C  
%assign idx_EVSYS_USER = [28,30]
%elseif ::isSAMD2_DA1 
%assign idx_EVSYS_USER = [23,-1]
%endif
/* link Event Channel 0 to ADC */
%foreach iADC = 2
%if ADCREF[iADC] == 1			
%<ADC_01[iADC]>_REGS->ADC_EVCTRL |= ADC_EVCTRL_STARTEI_Msk;     /* Must be done before the ADC peripheral is activated */
%if ::isSAMC2 || ::isPIC32C  
EVSYS_REGS->EVSYS_USER[%<idx_EVSYS_USER[iADC]>] = EVSYS_USER_CHANNEL(0x1);   /* Event 0 trig %<ADC_01[iADC]> START*/		
%else
EVSYS_REGS->EVSYS_USER = EVSYS_USER_USER(%<idx_EVSYS_USER[iADC]>) | EVSYS_USER_CHANNEL(0x1);   /* Event 0 trig %<ADC_01[iADC]> START*/		
%endif
%endif
%endforeach
%endif
%assign useADC_Interrupt = 0
%if nSeq > 1
%assign useADC_Interrupt = 1
%endif
%foreach idx = SIZE(TrigTimeStep,1)
%if TrigTimeStep[idx] == 1
%assign useADC_Interrupt = 1
%endif
%endforeach
%assign ADC_InterruptRef = -1
%if useADC_Interrupt
%if isADC0
%assign ADC_InterruptRef = 0	
%if (ADCREF[0] == 0) &&  (ADCREF[1] == 1)
%assign ADC_InterruptRef = 1
%endif
%else
%assign ADC_InterruptRef = ""	
%endif
%endif
/* Factory Calibration */
%foreach iADC = 2
%if ADCREF[iADC] == 1	
%if ::isSAMC2 || ::isPIC32C  
%switch iADC	
%case 0
%<ADC_01[iADC]>_REGS->ADC_CALIB = ( ((OTP_CAL_Ptr[0] & 0x7) << 8) + ((OTP_CAL_Ptr[0] & 0x38) >> 3) ); /* %<ADC_01[iADC]> factory Calibration */
%break
%case 1
%<ADC_01[iADC]>_REGS->ADC_CALIB = ( ((OTP_CAL_Ptr[0] & 0x1C0) << 2) + ((OTP_CAL_Ptr[0] & 0xE00) >> 9) ); /* %<ADC_01[iADC]> factory Calibration */
%break
%endswitch
%elseif ::isSAMD2_DA1 
%switch iADC	
%case 0
%<ADC_01[iADC]>_REGS->ADC_CALIB = ( ((OTP_CAL_Ptr[0] & 0xF8000000) >> 27) + ((OTP_CAL_Ptr[1] & 0x7) << 5)  + ((OTP_CAL_Ptr[1] & 0x38) << 5) ); /* %<ADC_01[iADC]> factory Calibration */
%break
%endswitch
%endif
%endif
%endforeach
/* Other ADC Settings */
%foreach iADC = 2
%if ADCREF[iADC] == 1	
%<ADC_01[iADC]>_REGS->ADC_CTRLB = ADC_CTRLB_PRESCALER_DIV%<PRESCALER>; /* ADC clock divider is %<FADC> */
%if ::isSAMC2 || ::isPIC32C  
%<ADC_01[iADC]>_REGS->ADC_REFCTRL = ADC_REFCTRL_REFSEL_INTVCC2 | ADC_REFCTRL_REFCOMP_Msk;	/* Vref is VDDANA */
%elseif ::isSAMD2_DA1 
%<ADC_01[iADC]>_REGS->ADC_REFCTRL = ADC_REFCTRL_REFSEL_INTVCC1 | ADC_REFCTRL_REFCOMP_Msk;	/* Vref is 1.48 * VDDANA */
%endif			
%switch iADC
%case 0
%assign AINx = CAST("Number",ADC0_AINx[0])
%break
%case 1		    		
%assign AINx = CAST("Number",ADC1_AINx[0])
%break
%endswitch	
%if AINx == -1
%<LibBlockReportError(block,"Pin for sequence 0 not set")>
%endif
%<ADC_01[iADC]>_REGS->ADC_SAMPCTRL = ADC_SAMPCTRL_SAMPLEN(%<CAST("Number",SAMPLEN[0])>);  /* Sampling time is (%<CAST("Number",SAMPLEN[0])>+1) / %<FADC> => %<(SAMPLEN[0] + 1) / FADC>(s) */
%if ::isSAMC2 || ::isPIC32C  
%<ADC_01[iADC]>_REGS->ADC_INPUTCTRL = ADC_INPUTCTRL_MUXPOS_AIN%<AINx> | ADC_INPUTCTRL_MUXNEG_GND ; /* positive and negative input pins */
%elseif ::isSAMD2_DA1 
%<ADC_01[iADC]>_REGS->ADC_INPUTCTRL = ADC_INPUTCTRL_MUXPOS_PIN%<AINx> | ADC_INPUTCTRL_MUXNEG_GND ; /* positive and negative input pins */
%endif				
%if ::isSAMC2 || ::isPIC32C  
%<ADC_01[iADC]>_REGS->ADC_CTRLC = ADC_CTRLC_RESSEL_%<CAST("Number",Resolution[0])>BIT | ADC_CTRLC_WINMODE(0);	 /* Resolution & Operation Mode */
%elseif ::isSAMD2_DA1 
%<ADC_01[iADC]>_REGS->ADC_CTRLB |= ADC_CTRLB_RESSEL_%<CAST("Number",Resolution[0])>BIT;	 /* Resolution */
%endif
%endif
%endforeach
%if useADC_Interrupt
/* Interrupt Settings */
NVIC_SetPriority(ADC%<ADC_InterruptRef>_IRQn, 0);
NVIC_EnableIRQ(ADC%<ADC_InterruptRef>_IRQn);		
ADC%<ADC_InterruptRef>_REGS->ADC_INTFLAG = ADC_INTFLAG_Msk; /* Clear all interrupt flags */		
ADC%<ADC_InterruptRef>_REGS->ADC_INTENSET = ADC_INTENSET_RESRDY_Msk;	    /* Enable interrupts */
%endif
%foreach iADC = 2
%if ADCREF[iADC] == 1	
while(%<ADC_01[iADC]>_REGS->%<SYNCBUSY>) ; /* Wait for Sync */
%<ADC_01[iADC]>_REGS->ADC_CTRLA |= ADC_CTRLA_ENABLE_Msk; /* Enable ADC */
%endif
%endforeach
%foreach iADC = 2
%if ADCREF[iADC] == 1			
while(%<ADC_01[iADC]>_REGS->%<SYNCBUSY>) ; /* Wait for Sync */
%endif
%endforeach
%foreach iADC = 2
%if ADCREF[iADC] == 1	
%if (UseEventSystem == 0)
/* Start conversion */
%<ADC_01[iADC]>_REGS->ADC_SWTRIG |= ADC_SWTRIG_START_Msk;
%endif
%endif
%endforeach
%if useADC_Interrupt
%openfile buffer
%foreach iADC = 2
%if ADCREF[iADC] == 1				
extern volatile uint16_T MCHP_%<ADC_01[iADC]>[%<CAST("Number",ADCxbuff[iADC]-1)>];	/* Declare %<ADC_01[iADC]> buffer */
%endif
%endforeach
%closefile buffer
%<LibCacheExtern(buffer)>		
%openfile dspicfun = "MCHP_ADC%<ADC_InterruptRef>_Interrupt.c"
#include "%<LibGetMdlPubHdrBaseName()>.h"
#include "%<LibGetMdlPubHdrBaseName()>_private.h"
%foreach iADC = 2
%if ADCREF[iADC] == 1				
uint16_T volatile MCHP_%<ADC_01[iADC]>[%<CAST("Number",ADCxbuff[iADC]-1)>];	/* Declare %<ADC_01[iADC]> buffer */
%endif
%endforeach
void ADC%<ADC_InterruptRef>_Handler( void )
{
%<MCHP_InterruptProlog()>
%if nSeq > 1
static uint_T iADC_Seq = 0;
%endif
/* Clear interrupt flag */
ADC%<ADC_InterruptRef>_REGS->ADC_INTFLAG = ADC_INTFLAG_RESRDY_Msk;
%assign iSeq = 0	
%if nSeq == 1
%foreach iADC = 2
%if ADCREF[iADC] == 1				
MCHP_%<ADC_01[iADC]>[0] = %<ADC_01[iADC]>_REGS->ADC_RESULT;	/* Store %<ADC_01[iADC]> result */
%endif
%endforeach	
%if TrigTimeStep[iSeq] == 1
/* Trig time step */
%if CompiledModel.FixedStepOpts.SolverMode == "MultiTasking"
NVIC_SetPendingIRQ(%<SchedulerInterrupt>_IRQn); /* Trig Scheduler interrupt  */
%else
%assign ::MCHP_srSchedulerOnInterrupt = 0       
extern volatile uint_T ContinueTimeStep;
ContinueTimeStep |= 1;
%endif				    	
%endif	
%else
switch (iADC_Seq) {
%assign SAMPLEN0 = [-1,-1]
%assign ADC_INPUTCTRL_MUXPOS_AIN0 = [-1,-1]
%assign Resolution0 = [-1,-1]
%foreach iSeq = mSeq
%foreach iConv = mConvPerSeq
%assign iAINx = iConv + iSeq*mConvPerSeq	
%if (ADC0_AINx[iAINx] != -1) || (ADC1_AINx[iAINx] != -1)
%if (ADC0_AINx[iAINx] != -1)			
%assign AINx = CAST("Number",ADC0_AINx[%<iAINx>])
%assign iADC = 0					
%if (Resolution[iAINx] != -1)	
%assign Resolution0[iADC] = Resolution[iAINx]												    			
%endif
%if (SAMPLEN[AINx] != -1)
%assign SAMPLEN0[iADC] = SAMPLEN[iAINx]
%endif
%endif
%if (ADC1_AINx[iAINx] != -1)
%assign iADC = 1			
%assign AINx = CAST("Number",ADC1_AINx[%<iAINx>])    					
%if (Resolution[iAINx] != -1)	
%assign Resolution0[iADC] = Resolution[iAINx]					    			
%endif
%if (SAMPLEN[AINx] != -1)
%assign SAMPLEN0[iADC] = SAMPLEN[iAINx]
%endif
%endif
%endif
%endforeach
%endforeach
%assign Buffer_TrigTimeStep = ""
%assign iCase = 0
%foreach iSeq = mSeq
%assign newSeq = 1
%foreach iConv = mConvPerSeq
%assign iAINx = iConv + iSeq*mConvPerSeq
%if (ADC0_AINx[iAINx] != -1) || (ADC1_AINx[iAINx] != -1)
%if iAINx == 0	    				
%openfile FirstConversionSetup
%endif
%if (ADC0_AINx[iAINx] != -1)			
%assign AINx = CAST("Number",ADC0_AINx[%<iAINx>])
%assign iADC = 0								
%if ::isSAMC2 || ::isPIC32C  
%<ADC_01[iADC]>_REGS->ADC_INPUTCTRL = ADC_INPUTCTRL_MUXPOS_AIN%<AINx> | ADC_INPUTCTRL_MUXNEG_GND ; /* positive and negative input pins */
%elseif ::isSAMD2_DA1 
%<ADC_01[iADC]>_REGS->ADC_INPUTCTRL = ADC_INPUTCTRL_MUXPOS_PIN%<AINx> | ADC_INPUTCTRL_MUXNEG_GND ; /* positive and negative input pins */
%endif	
%if (Resolution[iAINx] != -1)	&& 	Resolution0[iADC] != Resolution[iAINx]
%assign Resolution0[iADC] = Resolution[iAINx]
%if ::isSAMC2 || ::isPIC32C  
%<ADC_01[iADC]>_REGS->ADC_CTRLC = ADC_CTRLC_RESSEL_%<CAST("Number",Resolution[iAINx])>BIT | ADC_CTRLC_WINMODE(0);	 /* Resolution & Operation Mode */
%elseif ::isSAMD2_DA1 
%<ADC_01[iADC]>_REGS->ADC_CTRLB |= ADC_CTRLB_RESSEL_%<CAST("Number",Resolution[0])>BIT | ADC_CTRLB_PRESCALER_DIV%<PRESCALER>; /* Update Resolution */
%endif
%endif
%if (SAMPLEN[iAINx] != -1) && (SAMPLEN0[iADC] != SAMPLEN[iAINx])
%assign SAMPLEN0[iADC] = SAMPLEN[AINx]
%<ADC_01[iADC]>_REGS->ADC_SAMPCTRL = ADC_SAMPCTRL_SAMPLEN(%<CAST("Number",SAMPLEN[iAINx])>);  /* Sampling time is (%<CAST("Number",SAMPLEN[iAINx])>+1) / %<FADC> => %<(SAMPLEN[iAINx] + 1) / FADC>(s) */							
%endif
%endif
%if (ADC1_AINx[iAINx] != -1)
%assign iADC = 1			
%assign AINx = CAST("Number",ADC1_AINx[%<iAINx>])    					
%<ADC_01[iADC]>_REGS->ADC_INPUTCTRL = ADC_INPUTCTRL_MUXPOS_AIN%<AINx> | ADC_INPUTCTRL_MUXNEG_GND ; /* positive and negative input pins */	
%if (Resolution[iAINx] != -1)	&& 	Resolution0[iADC] != Resolution[iAINx]
%assign Resolution0[iADC] = Resolution[iAINx]					    			
%<ADC_01[iADC]>_REGS->ADC_CTRLC = ADC_CTRLC_RESSEL_%<CAST("Number",Resolution[iAINx])>BIT | ADC_CTRLC_WINMODE(0);	 /* Resolution & Operation Mode */
%endif		
%if (SAMPLEN[AINx] != -1) && (SAMPLEN0[iADC] != SAMPLEN[iAINx])
%assign SAMPLEN0[iADC] = SAMPLEN[iAINx]
%<ADC_01[iADC]>_REGS->ADC_SAMPCTRL = ADC_SAMPCTRL_SAMPLEN(%<CAST("Number",SAMPLEN[iAINx])>);  /* Sampling time is (%<CAST("Number",SAMPLEN[iAINx])>+1) / %<FADC> => %<(SAMPLEN[iAINx] + 1) / FADC>(s) */							
%endif
%endif
%switch TrigSource[iAINx]
%case 1
%if ADCREF[1] == 1			    					
ADC1_REGS->ADC_SWTRIG |= ADC_SWTRIG_START_Msk; /* Convert next sample  */
%endif
%if ADCREF[0] == 1			    					
%<ADC_01[0]>_REGS->ADC_SWTRIG |= ADC_SWTRIG_START_Msk; /* Convert next sample  */
%endif
%break
%case 2
/* next ADC Trigger is done through the Event User */
%break		    					
%endswitch		    			
%if iAINx == 0	
iADC_Seq = 0;			    					
%closefile FirstConversionSetup
%else
iADC_Seq ++;
%<Buffer_TrigTimeStep>
break;
%endif
%if newSeq
case %<iCase>:	/* SEQUENCE %<iSeq> - Conversion %<iConv> */
%else
case %<iCase>:	/* Conversion %<iConv> */
%endif
%assign newSeq = 0
%assign iCase = iCase + 1
%if (ADC0_AINx[iAINx] != -1)			
MCHP_%<ADC_01[0]>[%<CAST("Number",ADC0_AINx_unique_map[iAINx]-1)>] = %<ADC_01[0]>_REGS->ADC_RESULT;	/* Store %<ADC_01[0]> result */
%endif
%if (ADC1_AINx[iAINx] != -1)			
MCHP_ADC1[%<CAST("Number",ADC1_AINx_unique_map[iAINx]-1)>] = ADC1_REGS->ADC_RESULT;	/* Store ADC1 result */
%endif
%openfile Buffer_TrigTimeStep
%if TrigTimeStep[iAINx] == 1		    				
/* Trig time step */
%if CompiledModel.FixedStepOpts.SolverMode == "MultiTasking"
NVIC_SetPendingIRQ(%<SchedulerInterrupt>_IRQn); /* Trig Scheduler interrupt  */
%else
%assign ::MCHP_srSchedulerOnInterrupt = 0       
extern volatile uint_T ContinueTimeStep;
ContinueTimeStep |= 1;
%endif		
%endif				
%closefile Buffer_TrigTimeStep			
%endif
%endforeach
%endforeach
%<Buffer_TrigTimeStep>						
%<FirstConversionSetup>
} /* end switch */	 	    			
%endif
%<MCHP_InterruptEpilog()>
} 	
%closefile dspicfun
%endif
}
%endfunction
%function Outputs_ADC_SAMx2_x5_fct(block, system) Output
%assign isPresent =  CAST("Number",block.RTWdata.isPresent)
%assign isADC0 =  CAST("Number",block.RTWdata.isADC0)
%assign isADC =  CAST("Number",block.RTWdata.isADC)
%assign mConvPerSeq =  CAST("Number",block.RTWdata.mConvPerSeq)
%assign mSeq =  CAST("Number",block.RTWdata.mSeq)
%assign GCLK_FCY =  CAST("Number",block.RTWdata.GCLK_FCY)
%assign GCLK_idx =  CAST("Number",block.RTWdata.GCLK_idx)
%assign PRESCALER =  CAST("Number",block.RTWdata.PRESCALER)
%assign FADC =  CAST("Number",block.RTWdata.FADC)
%assign ADCREF =  MchpVector64(block.RTWdata.ADCREF)
%assign Resolution =  MchpVector64(block.RTWdata.Resolution)
%assign SampleTime_s =  MchpVectorDbl(block.RTWdata.SampleTime_s)
%assign TrigSource =  MchpVector64(block.RTWdata.TrigSource)
%assign TrigTimeStep =  MchpVector64(block.RTWdata.TrigTimeStep)
%assign ADC0_AINx =  MchpVector64(block.RTWdata.ADC0_AINx)
%assign ADC1_AINx =  MchpVector64(block.RTWdata.ADC1_AINx)
%assign nSeq =  CAST("Number",block.RTWdata.nSeq)
%assign ADC0_AINx_unique =  MchpVector64(block.RTWdata.ADC0_AINx_unique)
%assign ADC0_AINx_unique_map =  MchpVector64(block.RTWdata.ADC0_AINx_unique_map)
%assign ADC1_AINx_unique =  MchpVector64(block.RTWdata.ADC1_AINx_unique)
%assign ADC1_AINx_unique_map =  MchpVector64(block.RTWdata.ADC1_AINx_unique_map)
%assign ADC0_AINx_unique_i =  MchpVector64(block.RTWdata.ADC0_AINx_unique_i)
%assign ADC1_AINx_unique_i =  MchpVector64(block.RTWdata.ADC1_AINx_unique_i)
%assign ADCxbuff =  MchpVector64(block.RTWdata.ADCxbuff)
%assign SAMPLEN =  MchpVector64(block.RTWdata.SAMPLEN)
%if isADC0
%assign ADC_01 = ["ADC0", "ADC1"]
%else
%assign ADC_01 = ["ADC", "xxx"]
%endif
%assign useADC_Interrupt = 0
%assign ADC_InterruptRef = -1
%if nSeq > 1
%assign useADC_Interrupt = 1
%endif
%foreach idx = SIZE(TrigTimeStep,1)
%if TrigTimeStep[idx] == 1
%assign useADC_Interrupt = 1
%endif
%endforeach
%if useADC_Interrupt
%assign ADC_InterruptRef = 0	
%if (ADCREF[0] == 0) &&  (ADCREF[1] == 1)
%assign ADC_InterruptRef = 1
%endif
%endif
%assign IndexOutput = 0
%if useADC_Interrupt == 1
%foreach iSeq = mConvPerSeq * mSeq
%if ADC0_AINx_unique_i[iSeq] > 0
%assign iADC = 0
%if LibBlockOutputSignalConnected(IndexOutput)
%assign u = LibBlockOutputSignal(IndexOutput, "", "",0)		
%<u> = 	MCHP_%<ADC_01[iADC]>[%<CAST("Number",ADC0_AINx_unique_i[iSeq]-1)>];	/* Read %<ADC_01[iADC]> output buffer */		
%endif
%assign IndexOutput = IndexOutput + 1	
%endif
%if ADC1_AINx_unique_i[iSeq] > 0
%assign iADC = 1
%if LibBlockOutputSignalConnected(IndexOutput)
%assign u = LibBlockOutputSignal(IndexOutput, "", "",0)		
%<u> = 	MCHP_%<ADC_01[iADC]>[%<CAST("Number",ADC1_AINx_unique_i[iSeq]-1)>];	/* Read %<ADC_01[iADC]> output buffer */		
%endif
%assign IndexOutput = IndexOutput + 1				
%endif
%endforeach	
%else
%foreach iADC = 2
%if ADCREF[iADC] == 1				
%<ADC_01[iADC]>_REGS->ADC_INTFLAG = ADC_INTFLAG_RESRDY_Msk;
%if LibBlockOutputSignalConnected(IndexOutput)
%assign u = LibBlockOutputSignal(IndexOutput, "", "",0)
%<u> = 	%<ADC_01[iADC]>_REGS->ADC_RESULT;	/* Read %<ADC_01[iADC]> output */
%endif
%assign IndexOutput = IndexOutput + 1	
%endif
%endforeach		
%endif
%if (TrigSource[0] == 0)	
/* Start next conversion */
%foreach iADC = 2	
%if (ADCREF[iADC] == 1)
%<ADC_01[iADC]>_REGS->ADC_SWTRIG |= ADC_SWTRIG_START_Msk; /* Trig conversion after block result read */
%endif
%endforeach
%endif
%endfunction
