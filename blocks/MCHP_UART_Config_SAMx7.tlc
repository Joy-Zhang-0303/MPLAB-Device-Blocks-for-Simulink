%include "MCHP_UART_Rx_SAMx7_FunUtils.tlc"
%include "MCHP_UART_Tx_SAMx7_FunUtils.tlc"
%function UART_Config_SetBaudRateParity(block,system) Output
%assign Peripheral_Type = CAST("String",block.RTWdata.UART_PeripheralType)
%assign PCER_idx = CAST("String",block.RTWdata.PCER_idx)
%assign Peripheral_ID = CAST("String",block.RTWdata.Peripheral_ID)
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%assign nUSART = CAST("Number",block.RTWdata.nUSART)
%switch ::ChipIdL1
%case "SAME"
%case "SAMS"
%case "SAMV"
%if UARTRef > nUSART
%assign Per_Type = "UART"
%assign REG_NAME = "UART"
%assign REG_NAME2 = ""
%assign INTERRUPT_STATUS_REG = "SR"
%assign UART_Index = (UARTRef-1) - nUSART
%else
%assign Per_Type = "USART"
%assign REG_NAME = "US"
%assign REG_NAME2 = "USART_"
%assign INTERRUPT_STATUS_REG = "CSR"
%assign UART_Index = UARTRef-1
%endif
%assign UART_NAME = "%<Per_Type>%<UART_Index>"
%break
%case "SAMRH"
%assign Per_Type = "USART"
%assign REG_NAME = "FLEX_US"
%assign REG_NAME2 = ""
%assign INTERRUPT_STATUS_REG = "CSR"
%assign UART_Index = UARTRef-1
%assign UART_NAME = "FLEXCOM%<UART_Index>"
%break
%default
%error("Internal error with UART")
%endswitch
%assign TX_IMPLEMENTATION = MchpVector(RTWGenSettings.UART_TX_IMPLEMENTATION)
%assign TX_IMPLEMENTATION = TX_IMPLEMENTATION[UARTRef-1]		
%assign RX_IMPLEMENTATION = MchpVector(RTWGenSettings.UART_RX_IMPLEMENTATION)
%assign RX_IMPLEMENTATION = RX_IMPLEMENTATION[UARTRef-1]		
%assign CD = CAST("Number",block.RTWdata.CD)
%assign FP = CAST("Number",block.RTWdata.FP)
%assign OVER = CAST("Number",block.RTWdata.OVER)
%assign DesiredBaud = CAST("String",block.RTWdata.DesiredBaud)
%assign Error = CAST("String",block.RTWdata.Error)
%assign Peripheral_Interrupt_Priority = CAST("Number",block.RTWdata.INT_PRIORITY)
%assign Peripheral_Number_Of_Stop_Bits = CAST("Number",block.RTWdata.NBSTOP)
%assign Peripheral_Parity_Value = CAST("Number",block.RTWdata.PAR)
%assign Peripheral_Has_Rx_Enabled = CAST("Number",block.RTWdata.RXEN)
%assign Peripheral_Has_Tx_Enabled = CAST("Number",block.RTWdata.TXEN)
%assign Peripheral_IRQ_Priority = CAST("Number",block.RTWdata.INT_PRIORITY)
%assign Peripheral_Uses_Interrupt = ( RX_IMPLEMENTATION >= 2 || TX_IMPLEMENTATION == 2 )
%assign Peripheral_Rx_Interrupt_Enabled = ( RX_IMPLEMENTATION >= 2)     
%assign Peripheral_Tx_Interrupt_Enabled = ( TX_IMPLEMENTATION == 2 )    
%assign Peripheral_Uses_DMA = ( RX_IMPLEMENTATION >= 3 || TX_IMPLEMENTATION >= 3 )
%assign Peripheral_Uses_RxDMA = ( RX_IMPLEMENTATION >= 3 ) 
%assign Peripheral_Uses_TxDMA = ( TX_IMPLEMENTATION >= 3 ) 
%assign UART_TX_DMACHANNEL = MchpVector(RTWGenSettings.UART_TX_DMACHANNEL)
%assign TX_DMA_CHANNEL = UART_TX_DMACHANNEL[UARTRef-1]		
%assign UART_RX_DMACHANNEL = MchpVector(RTWGenSettings.UART_RX_DMACHANNEL)
%assign RX_DMA_CHANNEL = UART_RX_DMACHANNEL[UARTRef-1]		
%assign XDMAC_Tx_PERID = CAST("Vector",[7 ,9, 11, 20, 22, 24, 26, 28])
%assign XDMAC_UART_TX_PERID = XDMAC_Tx_PERID[UARTRef-1]
%assign XDMAC_Rx_PERID = CAST("Vector",[8 ,10, 12, 21, 23, 25, 27, 29])
%assign XDMAC_UART_RX_PERID = XDMAC_Rx_PERID[UARTRef-1]
%assign Peripheral_Source_Clock = 0
%assign Peripheral_Rx_Timeout_Value  = 1000
/* ========================= %<UART_NAME>(PID%<Peripheral_ID>) Peripheral setup ========================= */
/* Baud rate: %<DesiredBaud> (error %<Error>%), CD = %<CD>, FP = %<FP>, OVER = %<OVER> */
%assign ::MCHP_Clock_PMC_PCR[Peripheral_ID] = 1
%<UART_NAME>_REGS->%<REG_NAME>_IDR = 0xFFFFFFFF;  /* Disable all %<UART_NAME> interrupts*/
%<UART_NAME>_REGS->%<REG_NAME>_CR = %<REG_NAME>_CR_%<REG_NAME2>RSTSTA_Msk; /* Reset %<UART_NAME> channel Status Bits*/
{
uint32_T tmp_reg;
%if ISEQUAL(Peripheral_Type, "USART")
tmp_reg = %<REG_NAME>_MR_%<REG_NAME2>USCLKS(%<Peripheral_Source_Clock>);   /* %<UART_NAME> Source Clock: %<Peripheral_Source_Clock> */
tmp_reg |= %<REG_NAME>_MR_%<REG_NAME2>CHRL(3UL);                                                /* Character length is 8 bits */
tmp_reg |= %<REG_NAME>_MR_%<REG_NAME2>PAR(%<Peripheral_Parity_Value>);    /* Parity */
%if Peripheral_Number_Of_Stop_Bits > 0
tmp_reg |= %<REG_NAME>_MR_%<REG_NAME2>NBSTOP(%<Peripheral_Number_Of_Stop_Bits>); /* Number of Stop Bits */
%endif
%if OVER == 1
tmp_reg |= %<REG_NAME>_MR_%<REG_NAME2>OVER_Msk;     /* Oversampling reduced to 8x */
%else 
tmp_reg   |=  %<REG_NAME>_MR_%<REG_NAME2>FILTER_Msk; /* 16x Oversampling) - Activate 3 sample majority filter */
%endif
%<UART_NAME>_REGS->%<REG_NAME>_MR = tmp_reg; /* Write UART Mode register */
tmp_reg = %<REG_NAME>_BRGR_CD(%<CD>);                                          /* Clock Divider (CD): %<CD> */
tmp_reg |= %<REG_NAME>_BRGR_FP(%<FP>);                                          /* Baud Rate Fractional Part (FP): %<FP> */
%<UART_NAME>_REGS->%<REG_NAME>_BRGR = tmp_reg; /* Write UART Baud rate */
%if Peripheral_Uses_RxDMA
%<UART_NAME>_REGS->%<REG_NAME>_RTOR |= %<REG_NAME>_RTOR_TO(%<Peripheral_Rx_Timeout_Value>);   /* Enable Receiver Timeout: timeout delay period = bit period * RTOR_TO value */	
%endif
%else
tmp_reg = UART_MR_PAR(%<Peripheral_Parity_Value>);          /* Parity Type: No parity */
tmp_reg |=  UART_MR_FILTER_Msk;
%<UART_NAME>_REGS->UART_MR = tmp_reg;       /* Write UART Mode register */
%<UART_NAME>_REGS->UART_BRGR = %<REG_NAME>_BRGR_CD(%<CD>);     /* Clock Divider (CD): %<CD> */
%endif
tmp_reg = 0;
%if %<Peripheral_Has_Rx_Enabled>
tmp_reg |= %<REG_NAME>_CR_%<REG_NAME2>RXEN_Msk;      /* Enable RX */
%endif
%if %<Peripheral_Has_Tx_Enabled>
tmp_reg |= %<REG_NAME>_CR_%<REG_NAME2>TXEN_Msk;      /* Enable TX */
%endif
%<UART_NAME>_REGS->%<REG_NAME>_CR = tmp_reg; /* Write UART Control Register - Enable UART */
%if Peripheral_Uses_Interrupt
NVIC_ClearPendingIRQ(%<UART_NAME>_IRQn);                                   /* Clear %<UART_NAME> pending interrupt flags */
NVIC_SetPriority(%<UART_NAME>_IRQn,%<Peripheral_IRQ_Priority>);            /* Set %<UART_NAME>_IRQn interrupt priority */
NVIC_EnableIRQ(%<UART_NAME>_IRQn);                                         /* Enable NVIC line for %<UART_NAME> */
%endif
%if (RX_IMPLEMENTATION == 2)  
%<UART_NAME>_REGS->%<REG_NAME>_IER = %<REG_NAME>_IER_%<REG_NAME2>RXRDY_Msk;       /* enable RXRDY Interrupt */
%endif
%if (TX_IMPLEMENTATION == 2)  
%endif
} 
%if (Peripheral_Uses_TxDMA || Peripheral_Uses_RxDMA)
%openfile buffer
#if (defined __GNUC__) || defined(__CC_ARM)
#define COMPILER_WORD_ALIGNED    __attribute__((__aligned__(4)))
#elif (defined __ICCARM__)
#define COMPILER_WORD_ALIGNED    COMPILER_PRAGMA(data_alignment = 4)
#endif
/* XDMA_MBR_UBC */
#define   XDMAC_UBC_NDE            (0x1U << 24)
#define   XDMAC_UBC_NDE_FETCH_DIS  (0x0U << 24)
#define   XDMAC_UBC_NDE_FETCH_EN   (0x1U << 24)
#define   XDMAC_UBC_NSEN           (0x1U << 25)
#define   XDMAC_UBC_NSEN_UNCHANGED (0x0U << 25)
#define   XDMAC_UBC_NSEN_UPDATED   (0x1U << 25)
#define   XDMAC_UBC_NDEN           (0x1U << 26)
#define   XDMAC_UBC_NDEN_UNCHANGED (0x0U << 26)
#define   XDMAC_UBC_NDEN_UPDATED   (0x1U << 26)
#define   XDMAC_UBC_NVIEW_Pos       27U
#define   XDMAC_UBC_NVIEW_Msk      (0x3U << XDMAC_UBC_NVIEW_Pos)
#define   XDMAC_UBC_NVIEW_NDV0     (0x0U << XDMAC_UBC_NVIEW_Pos)
#define   XDMAC_UBC_NVIEW_NDV1     (0x1U << XDMAC_UBC_NVIEW_Pos)
#define   XDMAC_UBC_NVIEW_NDV2     (0x2U << XDMAC_UBC_NVIEW_Pos)
#define   XDMAC_UBC_NVIEW_NDV3     (0x3U << XDMAC_UBC_NVIEW_Pos)
#define   XDMAC_UBC_UBLEN_Pos 0
#define   XDMAC_UBC_UBLEN_Msk (0xffffffu << XDMAC_UBC_UBLEN_Pos)
#define   XDMAC_UBC_UBLEN(value) ((XDMAC_UBC_UBLEN_Msk & ((value) << XDMAC_UBC_UBLEN_Pos)))
/** XDMA config register for channel */
typedef struct {
/** Microblock Control Member. */
uint32_t mbr_ubc;
/** Source Address Member. */
uint32_t mbr_sa;
/** Destination Address Member. */
uint32_t mbr_da;
/** Configuration Register. */
uint32_t mbr_cfg;
/** Block Control Member. */
uint32_t mbr_bc;
/** Data Stride Member. */
uint32_t mbr_ds;
/** Source Microblock Stride Member. */
uint32_t mbr_sus;
/** Destination Microblock Stride Member. */
uint32_t mbr_dus;
} xdmac_channel_config_t;
/**
* \brief Structure for storing parameters for DMA view0 that can be
* performed by the DMA Master transfer.
*/
typedef struct {
/** Next Descriptor Address number. */
uint32_t mbr_nda;
/** Microblock Control Member. */
uint32_t mbr_ubc;
/** Destination Address Member. */
uint32_t mbr_da;
} lld_view0;
/**
* \brief Structure for storing parameters for DMA view1 that can be
* performed by the DMA Master transfer.
*/
typedef struct {
/** Next Descriptor Address number. */
uint32_t mbr_nda;
/** Microblock Control Member. */
uint32_t mbr_ubc;
/** Source Address Member. */
uint32_t mbr_sa;
/** Destination Address Member. */
uint32_t mbr_da;
} lld_view1;
/**
* \brief Structure for storing parameters for DMA view2 that can be
* performed by the DMA Master transfer.
*/
typedef struct {
/** Next Descriptor Address number. */
uint32_t mbr_nda;
/** Microblock Control Member. */
uint32_t mbr_ubc;
/** Source Address Member. */
uint32_t mbr_sa;
/** Destination Address Member. */
uint32_t mbr_da;
/** Configuration Register. */
uint32_t mbr_cfg;
} lld_view2;
/**
* \brief Structure for storing parameters for DMA view3 that can be
* performed by the DMA Master transfer.
*/
typedef struct {
/** Next Descriptor Address number. */
uint32_t mbr_nda;
/** Microblock Control Member. */
uint32_t mbr_ubc;
/** Source Address Member. */
uint32_t mbr_sa;
/** Destination Address Member. */
uint32_t mbr_da;
/** Configuration Register. */
uint32_t mbr_cfg;
/** Block Control Member. */
uint32_t mbr_bc;
/** Data Stride Member. */
uint32_t mbr_ds;
/** Source Microblock Stride Member. */
uint32_t mbr_sus;
/** Destination Microblock Stride Member. */
uint32_t mbr_dus;
} lld_view3;
%if (Peripheral_Uses_TxDMA)
/* XDMAC channel configuration structures for TX */
static xdmac_channel_config_t xdmac_tx_cfg;
/* XDMAC channels used for Tx*/
#define XDMAC_TX_CH %<TX_DMA_CHANNEL>
/* HW Interface Number (XDMAC_CC.PERID) */
#define %<UART_NAME>_XDMAC_TX_CH_NUM %<XDMAC_UART_TX_PERID>
%endif
%if(Peripheral_Uses_RxDMA)
/* XDMAC channel configuration structures for RX */
static xdmac_channel_config_t xdmac_rx_cfg;
/* Linked list descriptors */
COMPILER_WORD_ALIGNED
static lld_view0 lld_0[3];
/* XDMAC channels used for Rx */
#define XDMAC_RX_CH %<RX_DMA_CHANNEL>
/* HW Interface Number (XDMAC_CC.PERID) */
#define %<UART_NAME>_XDMAC_RX_CH_NUM %<XDMAC_UART_RX_PERID>
%endif
%closefile buffer
%<LibCacheExtern(buffer)>
%endif
%endfunction
%function UART_Config_WriteInitialisationOutputStream(block,sytem) Output
%error("Initialisation function not declared for SAMx7 chip")
%endfunction
