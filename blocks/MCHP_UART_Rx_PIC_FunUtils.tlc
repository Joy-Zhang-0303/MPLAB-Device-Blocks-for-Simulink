
%function URXNotEmpty(block) void
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%if ::DOS_03076_uart_protocol_upb_v1_16bit
%assign URXNotEmpty = "(0U == U%<UARTRef>" +  "STAHbits.URXBE)"	
%else
%assign URXNotEmpty = "(0U != U%<UARTRef>" + "STAbits.URXDA)"		
%endif	 	
%return "%<URXNotEmpty>"
%endfunction
%function URXEmpty(block) void
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%if ::DOS_03076_uart_protocol_upb_v1_16bit
%assign URXEmpty = "(0U != U%<UARTRef>" +  "STAHbits.URXBE)"	
%else
%assign URXEmpty = "(0U == U%<UARTRef>" + "STAbits.URXDA)"		
%endif	 	
%return "%<URXEmpty>"
%endfunction
%function UART_Rx_ReadRegister(block) void
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%return "((uint8_T) U%<UARTRef>RXREG)"
%endfunction
%function UART_Rx_TestAndClearErrors(block) Output
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
if ( U%<UARTRef>STAbits.OERR )
U%<UARTRef>STAbits.OERR = 0;	/* Clear UART Rx Overload Error */			 	
%endfunction
%function UART_Rx_CircularBuffer_flushBuffer(block) Output
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%assign UART_NAME = "UART%<UARTRef>"
%assign UART_HALF_DUPLEX_MODE = MchpVector(RTWGenSettings.UART_HALF_DUPLEX_MODE)
%assign UART_HALF_DUPLEX_MODE = UART_HALF_DUPLEX_MODE[UARTRef-1]	
%if UART_HALF_DUPLEX_MODE == 1
if (U%<UARTRef>STAbits.UTXEN == 0) {	/* Do not flush when Tx is enabled in Half duplex mode */
%endif
%if LibBlockSampleTime(block) == -1	|| ::MCHP_UART_RX_INT_PRIORITY[UARTRef-1] < 2 
/* SET U%<UARTRef>RXIF bit to 1 Flush internal UART buffer through the interrupt */
if %<URXNotEmpty(block)>
{   	
%<MCHP_SFR(  "U%<UARTRef>RXIF"  , 1 				   , "Flush internal UART buffer forcing the interrupt")>
}
%else
if %<URXNotEmpty(block)> { /* Flush internal UART buffer */
%assign RX_BufferPtrType = CAST( "String","uint_T")
%<RX_BufferPtrType> Tmp; 					
int cpu_ipl_switchVar;
%<SET_AND_SAVE_CPU_IPL("cpu_ipl_switchVar",::MCHP_UART_RX_INT_PRIORITY[UARTRef-1],"mimic Rx interrupt, disable Tx & thread switching interrupts")>;			
{
uint_T a;
register uint_T LocalTail = MCHP_%<UART_NAME>_Rx.tail;				
Tmp = ~(LocalTail - MCHP_%<UART_NAME>_Rx.head);		/* head - tail - 1 */ 
Tmp &= (Rx_BUFF_SIZE_%<UART_NAME> - 1);     /* Tmp =  (head - tail - 1) modulo buffersize Rx_BUFF_SIZE_%<UART_NAME>)	<==> Rx_BUFF_SIZE_%<UART_NAME> - (head - tail) - 1*/ 		 				
%if ::isdsPIC		
%<MCHP_SFR(  "U%<UARTRef>RXIF"  , 0 				   , "Reset interrupt")>
%endif
while %<URXNotEmpty(block)> {					
if (0U != Tmp) {	
Tmp--;
MCHP_%<UART_NAME>_Rx.buffer[LocalTail++] = (uint8_T) U%<UARTRef>RXREG;
LocalTail = (LocalTail) & (Rx_BUFF_SIZE_%<UART_NAME> - 1);
} else {	 				
do a = U%<UARTRef>RXREG;
while %<URXNotEmpty(block)>;
break;
}
}
%if ::isPIC32		
%<MCHP_SFR(  "U%<UARTRef>RXIF"  , 0 				   , "Reset interrupt")>
%endif
MCHP_%<UART_NAME>_Rx.tail = LocalTail;	/* push back volatile variable */
}	
%<RESTORE_CPU_IPL("cpu_ipl_switchVar","stop mimic UART RX interrupt IPL level")>
}
%endif
%if UART_HALF_DUPLEX_MODE == 1
}
%endif	
%endfunction
