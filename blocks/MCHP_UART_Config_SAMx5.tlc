%include "MCHP_UART_Rx_SAMx5_FunUtils.tlc"
%include "MCHP_UART_Tx_SAMx5_FunUtils.tlc"
%function UART_Config_SetBaudRateParity(block,system) Output
%assign Peripheral_ID = CAST("String",block.RTWdata.Peripheral_ID)
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%assign nUSART = CAST("Number",block.RTWdata.nUSART)
%assign UART_NAME = UART_Rx_get_UART_NAME(block)
%assign TX_IMPLEMENTATION = MchpVector(RTWGenSettings.UART_TX_IMPLEMENTATION)
%assign TX_IMPLEMENTATION = TX_IMPLEMENTATION[UARTRef-1]		
%assign RX_IMPLEMENTATION = MchpVector(RTWGenSettings.UART_RX_IMPLEMENTATION)
%assign RX_IMPLEMENTATION = RX_IMPLEMENTATION[UARTRef-1]		
%assign INTERRUPT_Tx_name = "SERCOM%<UARTRef-1>_0"	
%assign INTERRUPT_Tx_name1 = "SERCOM%<UARTRef-1>_1"	
%assign INTERRUPT_Rx_name = "SERCOM%<UARTRef-1>_2"	
%assign INVDATA = CAST("Number",block.RTWdata.INVDATA)
%assign FracArith = CAST("Number",block.RTWdata.FracArith)
%assign FP = CAST("Number",block.RTWdata.FP)
%assign BAUDREG = CAST("Number",block.RTWdata.BAUDREG)	
%assign BAUDREG_FP = CAST("Number",block.RTWdata.BAUDREG_FP)
%assign DesiredBaud = CAST("String",block.RTWdata.DesiredBaud)
%assign Error = CAST("String",block.RTWdata.Error)
%assign AchievedBaud = CAST("Real",block.RTWdata.AchievedBaud)
%assign GCLK_ref = CAST("Number",block.RTWdata.GCLK_ref)
%assign GCLK_val = CAST("Real",block.RTWdata.GCLK_val)
%assign TX_INT_PRIORITY = CAST("Number",block.RTWdata.TX_INT_PRIORITY)
%assign RX_INT_PRIORITY = CAST("Number",block.RTWdata.RX_INT_PRIORITY)
%assign NBSTOP = CAST("Number",block.RTWdata.NBSTOP)
%assign PMOD = CAST("Number",block.RTWdata.PMOD)	
%assign FORM = CAST("Number",block.RTWdata.FORM)	
%assign RXEN = CAST("Number",block.RTWdata.RXEN)
%assign TXEN = CAST("Number",block.RTWdata.TXEN)
%assign UART_HALF_DUPLEX_MODE = MchpVector(RTWGenSettings.UART_HALF_DUPLEX_MODE)
%assign UART_HALF_DUPLEX_MODE = UART_HALF_DUPLEX_MODE[UARTRef-1]	
%assign PAD_Tx = CAST("Number",block.RTWdata.PAD_Tx)
%assign PAD_Rx = CAST("Number",block.RTWdata.PAD_Rx)
%assign Peripheral_Uses_Interrupt = ( RX_IMPLEMENTATION >= 2 || TX_IMPLEMENTATION == 2 )
%assign Peripheral_Rx_Interrupt_Enabled = ( RX_IMPLEMENTATION >= 2)     
%assign Peripheral_Tx_Interrupt_Enabled = ( TX_IMPLEMENTATION == 2 )    
%assign Peripheral_Uses_DMA = ( RX_IMPLEMENTATION >= 3 || TX_IMPLEMENTATION >= 3 )
%assign Peripheral_Uses_RxDMA = ( RX_IMPLEMENTATION >= 3 ) 
%assign Peripheral_Uses_TxDMA = ( TX_IMPLEMENTATION >= 3 ) 
%assign UART_TX_DMACHANNEL = MchpVector(RTWGenSettings.UART_TX_DMACHANNEL)
%assign TX_DMA_CHANNEL = UART_TX_DMACHANNEL[UARTRef-1]		
%assign UART_RX_DMACHANNEL = MchpVector(RTWGenSettings.UART_RX_DMACHANNEL)
%assign RX_DMA_CHANNEL = UART_RX_DMACHANNEL[UARTRef-1]		
%assign XDMAC_Tx_PERID = CAST("Vector",[7 ,9, 11, 20, 22, 24, 26, 28])
%assign XDMAC_UART_TX_PERID = XDMAC_Tx_PERID[UARTRef-1]
%assign XDMAC_Rx_PERID = CAST("Vector",[8 ,10, 12, 21, 23, 25, 27, 29])
%assign XDMAC_UART_RX_PERID = XDMAC_Rx_PERID[UARTRef-1]
%assign Peripheral_Source_Clock = 0
%assign Peripheral_Rx_Timeout_Value  = 1000
/* ========================= SERCOM UART %<UARTRef-1> (PID%<Peripheral_ID>) Peripheral setup ========================= */
/* Baud rate: %<DesiredBaud> (%<Error>%) => %<AchievedBaud> */	
{
uint32_T tmp_reg;
/* %<UART_NAME> APB clock */
%<Enable_Peripheral_Clock("SERCOM%<UARTRef-1>")>
/* %<UART_NAME> CTRL B */
%if NBSTOP == 2
tmp_reg = SERCOM_USART_INT_CTRLB_SBMODE_2_BIT;	/* 2 stop bits */
%else
tmp_reg = SERCOM_USART_INT_CTRLB_SBMODE_1_BIT;	/* 1 stop bits */
%endif
%if TXEN	
%if UART_HALF_DUPLEX_MODE == 0
tmp_reg |= SERCOM_USART_INT_CTRLB_TXEN_Msk;	/* Enable Tx */
%endif
%endif
%if RXEN		
tmp_reg |= SERCOM_USART_INT_CTRLB_RXEN_Msk;	/* Enable Rx */
%endif
%switch PMOD
%case 0
tmp_reg |= SERCOM_USART_INT_CTRLB_PMODE_EVEN;	/* Even Parity */	
%break
%case 1
tmp_reg |= SERCOM_USART_INT_CTRLB_PMODE_ODD;	/* Odd Parity */	
%break						
%endswitch		
SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_CTRLB = tmp_reg; /* USART%<UARTRef-1> CTRLB  */
%switch FracArith
%case 0
/* Arithmetic baud rate: F_baud = %<AchievedBaud> = GCLK%<GCLK_ref>/S*(1-BAUD/65536.0) */
/* with GCLK%<GCLK_ref>=%<GCLK_val>, S=%<FP> and BAUD = %<BAUDREG>  ==> %<AchievedBaud> */ 
SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_BAUD = %<MchpHex(BAUDREG)>; /* Set Baud rate */
%break
%case 1
/* Fractional baud rate: F_baud = %<AchievedBaud> = GCLK%<GCLK_ref>/(S*(BAUD + FP/8)) */			
/* with GCLK%<GCLK_ref>=%<GCLK_val>, S=%<FP>, BAUD = %<BAUDREG> and FP = %<BAUDREG_FP> ==> %<GCLK_val/(FP*(BAUDREG+BAUDREG_FP/8.0))> */
SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_BAUD = %<MchpHex(BAUDREG)> + (%<MchpHex(BAUDREG_FP)> << 13) ; /* Baud rate + fractional part */
%break
%endswitch	
/* %<UART_NAME> Sync CTRL B */
while((SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_SYNCBUSY) & SERCOM_USART_INT_SYNCBUSY_CTRLB_Msk) ; /* SYNCBUSY */
/* %<UART_NAME> CTRL A, Enabled  */
tmp_reg = SERCOM_USART_INT_CTRLA_MODE(SERCOM_USART_INT_CTRLA_MODE_USART_INT_CLK_Val); /* SERCOM %<UARTRef-1> is USART with internal clock */
tmp_reg |= SERCOM_USART_INT_CTRLA_DORD_Msk; /* UART standard is LSB first */
%if INVDATA
tmp_reg |= SERCOM_USART_INT_CTRLA_TXINV_Msk; /* Invert Tx Logic */
tmp_reg |= SERCOM_USART_INT_CTRLA_RXINV_Msk; /* Invert Rx Logic */
%endif
%switch FracArith
%case 0
tmp_reg |= SERCOM_USART_INT_CTRLA_SAMPR_%<FP>X_ARITHMETIC;	/* %<FP>x oversampling, Arithmetic Baud Rate */
%break
%case 1 				
tmp_reg |= SERCOM_USART_INT_CTRLA_SAMPR_%<FP>X_FRACTIONAL; /* %<FP>x oversampling, Arithmetic Baud Rate */	
%break
%default
%error("UART SERCOM %<UARTRef> parameter Arithmetic or Fractional Baud rate setting not recognized.")
%endswitch
%if TXEN
tmp_reg |= SERCOM_USART_INT_CTRLA_TXPO_PAD%<PAD_Tx>;	/* Tx Pinout PAD (optional RTS/CTS) */
%endif
%if RXEN
tmp_reg |= SERCOM_USART_INT_CTRLA_RXPO_PAD%<PAD_Rx>;	/* Rx Pinout PAD */
%endif
%switch FORM
%case 0
tmp_reg |= SERCOM_USART_INT_CTRLA_FORM_USART_FRAME_NO_PARITY; /* No Parity */
%break
%case 1
tmp_reg |= SERCOM_USART_INT_CTRLA_FORM_USART_FRAME_WITH_PARITY; /* Enable Parity */
%break
%default
%error("UART SERCOM %<UARTRef> parameter FORM not set.")
%endswitch			
tmp_reg |= SERCOM_USART_INT_CTRLA_ENABLE_Msk;	/* Enable SERCOM %<UARTRef-1> */
tmp_reg |= SERCOM_USART_INT_CTRLA_RUNSTDBY_Msk; /* Run in Stdby mode */
SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_CTRLA = tmp_reg; /* USART CTRLA - enable %<UARTRef-1> */
while((SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_SYNCBUSY) & (SERCOM_USART_INT_SYNCBUSY_SWRST_Msk | SERCOM_USART_INT_SYNCBUSY_ENABLE_Msk)) ; /* SYNCBUSY */
%if ::isSAMx5
%if Peripheral_Rx_Interrupt_Enabled	
/* Set %<UART_NAME> Rx Interrupt */	
tmp_reg = %<UART_Rx_ReadRegister(block)>; 							/* Clear %<UART_NAME> Rx pending interrupt flags */
NVIC_SetPriority(%<INTERRUPT_Rx_name>_IRQn,%<RX_INT_PRIORITY>);    	/* Set %<UART_NAME> Rx interrupt priority */
NVIC_EnableIRQ(%<INTERRUPT_Rx_name>_IRQn);                          /* Enable NVIC line for %<UART_NAME> Rx */
SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_INTENSET = SERCOM_USART_INT_INTENSET_RXC_Msk; /* Enable %<UART_NAME> Rx interrupt receive complete */
%endif
%if Peripheral_Tx_Interrupt_Enabled		
/* Set %<UART_NAME> Tx Interrupt */		    	
NVIC_SetPriority(%<INTERRUPT_Tx_name>_IRQn,%<TX_INT_PRIORITY>);            /* Set %<UART_NAME> Tx interrupt priority */
NVIC_EnableIRQ(%<INTERRUPT_Tx_name>_IRQn);                                 /* Enable NVIC line for %<UART_NAME> Tx */
NVIC_SetPriority(%<INTERRUPT_Tx_name1>_IRQn,%<TX_INT_PRIORITY>);            /* Set %<UART_NAME> Tx interrupt priority */
NVIC_EnableIRQ(%<INTERRUPT_Tx_name1>_IRQn);                                 /* Enable NVIC line for %<UART_NAME> Tx */	
%endif
%else 
%if Peripheral_Tx_Interrupt_Enabled	
%if Peripheral_Rx_Interrupt_Enabled
%if RX_INT_PRIORITY != TX_INT_PRIORITY
%warning("UART %<UARTRef-1> should have same interrupt for Rx and Tx. Using Tx priority by default.")
%endif
tmp_reg = %<UART_Rx_ReadRegister(block)>; 								/* Clear %<UART_NAME> Rx pending interrupt flags */
NVIC_SetPriority(SERCOM%<UARTRef-1>_IRQn,%<TX_INT_PRIORITY>);            /* Set %<UART_NAME> Rx-Tx interrupt priority */
NVIC_EnableIRQ(SERCOM%<UARTRef-1>_IRQn);                                 /* Enable NVIC line for %<UART_NAME> Rx-Tx */	
SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_INTENSET = SERCOM_USART_INT_INTENSET_RXC_Msk; /* Enable %<UART_NAME> Rx interrupt receive complete */
%else
NVIC_SetPriority(SERCOM%<UARTRef-1>_IRQn,%<TX_INT_PRIORITY>);            /* Set %<UART_NAME> Tx interrupt priority */
NVIC_EnableIRQ(SERCOM%<UARTRef-1>_IRQn);                                 /* Enable NVIC line for %<UART_NAME> Tx */	 	
%endif
%elseif Peripheral_Rx_Interrupt_Enabled				
tmp_reg = %<UART_Rx_ReadRegister(block)>; 								/* Clear %<UART_NAME> Rx pending interrupt flags */  	
NVIC_SetPriority(SERCOM%<UARTRef-1>_IRQn,%<RX_INT_PRIORITY>);            /* Set %<UART_NAME> Rx interrupt priority */
NVIC_EnableIRQ(SERCOM%<UARTRef-1>_IRQn);                                 /* Enable NVIC line for %<UART_NAME> Rx */	 	
SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_INTENSET = SERCOM_USART_INT_INTENSET_RXC_Msk; /* Enable %<UART_NAME> Rx interrupt receive complete */
%endif
%endif
}
%endfunction
%function UART_Config_WriteInitialisationOutputStream(block,sytem) Output
%assign Peripheral_ID = CAST("String",block.RTWdata.Peripheral_ID)
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%assign nUSART = CAST("Number",block.RTWdata.nUSART)
%assign UART_NAME = UART_Rx_get_UART_NAME(block)
%assign TX_IMPLEMENTATION = MchpVector(RTWGenSettings.UART_TX_IMPLEMENTATION)
%assign TX_IMPLEMENTATION = TX_IMPLEMENTATION[UARTRef-1]		
%assign RX_IMPLEMENTATION = MchpVector(RTWGenSettings.UART_RX_IMPLEMENTATION)
%assign RX_IMPLEMENTATION = RX_IMPLEMENTATION[UARTRef-1]		
%assign INVDATA = CAST("Number",block.RTWdata.INVDATA)
%assign DesiredBaud_InitSeq = CAST("String",block.RTWdata.DesiredBaud_InitSeq)
%assign Error_InitSeq = CAST("String",block.RTWdata.Error_InitSeq)
%assign AchievedBaud_InitSeq = CAST("Real",block.RTWdata.AchievedBaud_InitSeq)
%assign FracArith_InitSeq  = CAST("Number",block.RTWdata.FracArith_InitSeq )
%assign FP_InitSeq = CAST("Number",block.RTWdata.FP_InitSeq)
%assign BAUDREG_InitSeq = CAST("Number",block.RTWdata.BAUDREG_InitSeq)	
%assign BAUDREG_FP_InitSeq = CAST("Number",block.RTWdata.BAUDREG_FP_InitSeq)
%assign GCLK_ref_InitSeq = CAST("Number",block.RTWdata.GCLK_ref_InitSeq)
%assign GCLK_val_InitSeq = CAST("Real",block.RTWdata.GCLK_val_InitSeq)
%assign TX_INT_PRIORITY = CAST("Number",block.RTWdata.TX_INT_PRIORITY)
%assign RX_INT_PRIORITY = CAST("Number",block.RTWdata.RX_INT_PRIORITY)
%assign NBSTOP = CAST("Number",block.RTWdata.NBSTOP)
%assign PMOD = CAST("Number",block.RTWdata.PMOD)	
%assign FORM = CAST("Number",block.RTWdata.FORM)	
%assign RXEN = CAST("Number",block.RTWdata.RXEN)
%assign TXEN = CAST("Number",block.RTWdata.TXEN)
%assign UART_HALF_DUPLEX_MODE = MchpVector(RTWGenSettings.UART_HALF_DUPLEX_MODE)
%assign UART_HALF_DUPLEX_MODE = UART_HALF_DUPLEX_MODE[UARTRef-1]	
%assign PAD_Tx = CAST("Number",block.RTWdata.PAD_Tx)
%assign PAD_Rx = CAST("Number",block.RTWdata.PAD_Rx)
%assign Peripheral_Uses_Interrupt = ( RX_IMPLEMENTATION >= 2 || TX_IMPLEMENTATION == 2 )
%assign Peripheral_Rx_Interrupt_Enabled = ( RX_IMPLEMENTATION >= 2)     
%assign Peripheral_Tx_Interrupt_Enabled = ( TX_IMPLEMENTATION == 2 )    
%assign Peripheral_Uses_DMA = ( RX_IMPLEMENTATION >= 3 || TX_IMPLEMENTATION >= 3 )
%assign Peripheral_Uses_RxDMA = ( RX_IMPLEMENTATION >= 3 ) 
%assign Peripheral_Uses_TxDMA = ( TX_IMPLEMENTATION >= 3 ) 
%assign UART_TX_DMACHANNEL = MchpVector(RTWGenSettings.UART_TX_DMACHANNEL)
%assign TX_DMA_CHANNEL = UART_TX_DMACHANNEL[UARTRef-1]		
%assign UART_RX_DMACHANNEL = MchpVector(RTWGenSettings.UART_RX_DMACHANNEL)
%assign RX_DMA_CHANNEL = UART_RX_DMACHANNEL[UARTRef-1]		
%assign XDMAC_Tx_PERID = CAST("Vector",[7 ,9, 11, 20, 22, 24, 26, 28])
%assign XDMAC_UART_TX_PERID = XDMAC_Tx_PERID[UARTRef-1]
%assign XDMAC_Rx_PERID = CAST("Vector",[8 ,10, 12, 21, 23, 25, 27, 29])
%assign XDMAC_UART_RX_PERID = XDMAC_Rx_PERID[UARTRef-1]
%assign InitSequence = MchpVector(block.RTWdata.InitSequence)
%assign InitSequence_str = CAST("String",block.RTWdata.InitSequence_str)
%assign InitSequenceLength = %<SIZE(InitSequence,1)>
%assign InitBreakPos = MchpVector(block.RTWdata.InitBreakPos)
%assign InitBreakValue = MchpVector(block.RTWdata.InitBreakValue)
%assign InitBreakLength = %<SIZE(InitBreakPos,1)>
/* ========================= SERCOM UART %<UARTRef-1> (PID%<Peripheral_ID>) Peripheral setup ========================= */
/* ========================= FOR INITIAL SEQUENCE ==================================================================== */
/* Baud rate: %<DesiredBaud_InitSeq> (%<Error_InitSeq>%) => %<AchievedBaud_InitSeq> */	
{
const uint8_T InitSequence[%<InitSequenceLength>] = %<InitSequence_str>;
uint32_T tmp_reg;
/* %<UART_NAME> APB clock */
%<Enable_Peripheral_Clock("SERCOM%<UARTRef-1>")>
/* %<UART_NAME> CTRL B */
%if NBSTOP == 2
tmp_reg = SERCOM_USART_INT_CTRLB_SBMODE_2_BIT;	/* 2 stop bits */
%else
tmp_reg = SERCOM_USART_INT_CTRLB_SBMODE_1_BIT;	/* 1 stop bits */
%endif
%if TXEN	
%if UART_HALF_DUPLEX_MODE == 0
tmp_reg |= SERCOM_USART_INT_CTRLB_TXEN_Msk;	/* Enable Tx */
%endif
%endif
%if RXEN		
tmp_reg |= SERCOM_USART_INT_CTRLB_RXEN_Msk;	/* Enable Rx */
%endif
%switch PMOD
%case 0
tmp_reg |= SERCOM_USART_INT_CTRLB_PMODE_EVEN;	/* Even Parity */	
%break
%case 1
tmp_reg |= SERCOM_USART_INT_CTRLB_PMODE_ODD;	/* Odd Parity */	
%break						
%endswitch		
SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_CTRLB = tmp_reg; /* USART%<UARTRef-1> CTRLB  */
%switch FracArith_InitSeq
%case 0
/* Arithmetic baud rate: F_baud = %<AchievedBaud_InitSeq> = GCLK%<GCLK_ref_InitSeq>/S*(1-BAUD/65536.0) */
/* with GCLK%<GCLK_ref_InitSeq>=%<GCLK_val_InitSeq>, S=%<FP_InitSeq> and BAUD = %<BAUDREG_InitSeq>  ==> %<AchievedBaud_InitSeq> */ 
SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_BAUD = %<MchpHex(BAUDREG_InitSeq)>; /* Set Baud rate */
%break
%case 1
/* Fractional baud rate: F_baud = %<AchievedBaud_InitSeq> = GCLK%<GCLK_ref_InitSeq>/(S*(BAUD + FP_InitSeq/8)) */			
/* with GCLK%<GCLK_ref_InitSeq>=%<GCLK_val_InitSeq>, S=%<FP_InitSeq>, BAUD = %<BAUDREG_InitSeq> and FP_InitSeq = %<BAUDREG_FP_InitSeq> ==> %<GCLK_val_InitSeq/(FP_InitSeq*(BAUDREG_InitSeq+BAUDREG_FP_InitSeq/8.0))> */
SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_BAUD = %<MchpHex(BAUDREG_InitSeq)> + (%<MchpHex(BAUDREG_FP_InitSeq)> << 13) ; /* Baud rate + fractional part */
%break
%endswitch	
/* %<UART_NAME> Sync CTRL B */
while((SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_SYNCBUSY) & SERCOM_USART_INT_SYNCBUSY_CTRLB_Msk) ; /* SYNCBUSY */
/* %<UART_NAME> CTRL A, Enabled  */
tmp_reg = SERCOM_USART_INT_CTRLA_MODE(SERCOM_USART_INT_CTRLA_MODE_USART_INT_CLK_Val); /* SERCOM %<UARTRef-1> is USART with internal clock */
tmp_reg |= SERCOM_USART_INT_CTRLA_DORD_Msk; /* UART standard is LSB first */
%if INVDATA
tmp_reg |= SERCOM_USART_INT_CTRLA_TXINV_Msk; /* Invert Tx Logic */
tmp_reg |= SERCOM_USART_INT_CTRLA_RXINV_Msk; /* Invert Rx Logic */
%endif
%switch FracArith_InitSeq
%case 0
tmp_reg |= SERCOM_USART_INT_CTRLA_SAMPR_%<FP_InitSeq>X_ARITHMETIC;	/* %<FP_InitSeq>x oversampling, Arithmetic Baud Rate */
%break
%case 1 				
tmp_reg |= SERCOM_USART_INT_CTRLA_SAMPR_%<FP_InitSeq>X_FRACTIONAL; /* %<FP_InitSeq>x oversampling, Arithmetic Baud Rate */	
%break
%default
%error("UART SERCOM %<UARTRef> parameter Arithmetic or Fractional Baud rate setting not recognized.")
%endswitch
%if TXEN
tmp_reg |= SERCOM_USART_INT_CTRLA_TXPO_PAD%<PAD_Tx>;	/* Tx Pinout PAD (optional RTS/CTS) */
%endif
%if RXEN
tmp_reg |= SERCOM_USART_INT_CTRLA_RXPO_PAD%<PAD_Rx>;	/* Rx Pinout PAD */
%endif
%switch FORM
%case 0
tmp_reg |= SERCOM_USART_INT_CTRLA_FORM_USART_FRAME_NO_PARITY; /* No Parity */
%break
%case 1
tmp_reg |= SERCOM_USART_INT_CTRLA_FORM_USART_FRAME_WITH_PARITY; /* Enable Parity */
%break
%default
%error("UART SERCOM %<UARTRef> parameter FORM not set.")
%endswitch			
tmp_reg |= SERCOM_USART_INT_CTRLA_ENABLE_Msk;	/* Enable SERCOM %<UARTRef-1> */
tmp_reg |= SERCOM_USART_INT_CTRLA_RUNSTDBY_Msk; /* Run in Stdby mode */
SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_CTRLA = tmp_reg; /* USART CTRLA - enable %<UARTRef-1> */
while((SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_SYNCBUSY) & (SERCOM_USART_INT_SYNCBUSY_SWRST_Msk | SERCOM_USART_INT_SYNCBUSY_ENABLE_Msk)) ; /* SYNCBUSY */
/* UART ready to send Init sequence */
%foreach s = (InitBreakLength)		
/* Delay function not implemented on this chip chip*/
%warning("Delay not implemented for UART Initialisation sequence")
%if %<s> == %<InitBreakLength-1>  
%assign SequenceLength = InitSequenceLength+1 - InitBreakPos[s]	
%else
%assign SequenceLength = InitBreakPos[%<s+1>] - InitBreakPos[s]
%endif
%if SequenceLength != 0
%if SequenceLength > 1
{
uint_T i1;		
for (i1 = %<InitBreakPos[s]-1>; i1 < %< InitBreakPos[s]-1 + SequenceLength> ; i1++) {
%assign u = "i1"
%else
%assign u = %<InitBreakPos[s]-1>
%endif
while %<UTXNotEmpty(block)>;	/* Wait for one empty space within buffer UART */	
%<UART_Tx_WriteRegister(block)> = InitSequence[%<u>];
%if SequenceLength > 1
}	
}
%endif
while %<UTX_NotCompleted(block)>;	/* Wait for all value to be sent */	
%endif
%endforeach
SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_CTRLA = 0;	/* Then switch off UART */
while((SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_SYNCBUSY) & (SERCOM_USART_INT_SYNCBUSY_SWRST_Msk | SERCOM_USART_INT_SYNCBUSY_ENABLE_Msk)) ; /* SYNCBUSY */
}
%endfunction
