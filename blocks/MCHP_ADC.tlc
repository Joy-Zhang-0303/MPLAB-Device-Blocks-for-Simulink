%implements  MCHP_ADC  "C"
%include "MCHP_Functions.tlc"		
%include "MCHP_Scheduler.tlc"
%function Start(block, system) Output
%assign ChipIdL1 = CAST("String",RTWGenSettings.ChipIdL1)
%assign ChipIdL2 = CAST("String",RTWGenSettings.ChipIdL2)
%assign ChipIdL3 = CAST("String",RTWGenSettings.ChipIdL3)
%assign ChipIdN =  MchpVector(RTWGenSettings.ChipIdN)
%assign DMACHANNEL = CAST("Number",block.RTWdata.DMACHANNEL)
%assign DMA_CNT = CAST("Number",block.RTWdata.DMA_CNT)	
%assign DMAREQ_TAB = CAST("Vector",[-1 ,13, 21])			
%assign ADCRefNum = CAST("Number",block.RTWdata.ADCRef)
%assign LengthADxCSS = CAST("Number",block.RTWdata.LengthADxCSS)
%assign ADCFlags = MchpVector(RTWdata.ADCFlags)
%if ADCFlags[0] == 0
%assign ADCRef = ""		
%else
%assign ADCRef = ADCRefNum
%endif
%assign ADxCON = MchpVector(block.RTWdata.ADxCON)
%assign ADxCSS_HL = CAST("Unsigned",block.RTWdata.ADxCSS_HL)
%assign ADxCSS_simple_Or_HL = CAST("Number",block.RTWdata.ADxCSS_simple_Or_HL)
%assign ANtype_or = CAST("Number",block.RTWdata.ANtype_or)
%assign ADxCHS0 = CAST("Number",block.RTWdata.ADxCHS0)
%assign ADxCHS123 = CAST("Number",block.RTWdata.ADxCHS123)
%assign TimeStep_Timer = CAST("Number",RTWGenSettings.TimeStep_Timer)
%assign TimeStep_SyncADC = CAST("Number",RTWGenSettings.TimeStep_SyncADC)
%assign  NConversionTotal = CAST("Number",RTWGenSettings.NConversionTotal)
%assign ADC_PingPong =  CAST("Number",RTWGenSettings.ADC_PingPong)
%assign Continuous_PingPong =  CAST("Number",RTWdata.Continuous_PingPong)
%assign nSampleHold = CAST("Number",block.RTWdata.nSampleHold)
%assign TrigAfterEachConversion = CAST("Number",block.RTWdata.TrigAfterEachConversion)
%assign ADxCHS0_ADxCSS = MchpVector(block.RTWdata.ADxCHS0_ADxCSS)
%assign NConv = CAST("Number",block.RTWdata.NConv)
%if (DMACHANNEL == -1) && (TrigAfterEachConversion == 1)		
%assign NConvSizeMem = nSampleHold + LengthADxCSS - 1		
%else
%assign NConvSizeMem = NConv
%endif
%if DMACHANNEL != -1
%assign MEMORY_DMA_QUALIFIER = MchpDMA_MemoryQualifier()
%assign MEMORY_DMA_ATTRIBUTE = MchpDMA_MemoryAttribute(NConvSizeMem)
%else
%assign MEMORY_DMA_QUALIFIER = ""
%assign MEMORY_DMA_ATTRIBUTE = ""
%endif
%assign DMA_CNTmax = CAST("Number",block.RTWdata.DMA_CNTmax)
%assign BUFF_CNTmax = CAST("Number",block.RTWdata.BUFF_CNTmax)
%if DMACHANNEL == -1  
%if NConv > BUFF_CNTmax
%<LibBlockReportError(block,"Number of conversion requested %<NConv> by the ADC block is above the limit %<ADCRef> of interrupt based implementation. Try to use a DMA implementation if chip allows it.")>
%endif
%else 
%if NConv > DMA_CNTmax
%<LibBlockReportError(block,"Number of conversion requested %<NConv> by the ADC block is above the limit %<DMA_CNTmax> of the DMA implementation.")>
%endif
%endif
%openfile buffer
%if DMACHANNEL != -1 
volatile extern %<MEMORY_DMA_QUALIFIER> uint16_T  ADC%<ADCRef>BuffChannelA[%<NConvSizeMem>];
%if (ADC_PingPong == 1)
volatile extern %<MEMORY_DMA_QUALIFIER> uint16_T ADC%<ADCRef>BuffChannelB[%<NConvSizeMem>];
%endif
%if (ADC_PingPong == 1) && (Continuous_PingPong == 0)
volatile extern %<MEMORY_DMA_QUALIFIER> uint16_T* ADC%<ADCRef>BuffChannelPtr;
%else
volatile extern uint16_T MCHP_DMAPPS_duplicate;
%endif
%else	
%if (ADC_PingPong == 1) || (TimeStep_SyncADC != -1)
volatile extern uint16_T ADC%<ADCRef>BuffChannelA[%<NConvSizeMem>];
%endif
%endif
%if TrigAfterEachConversion == 1
volatile extern uint16_T ADCSeqState;
%endif
%closefile buffer
%<LibCacheExtern(buffer)>
/* MCHP_ADC Block for ADC %<ADCRef>: %<Name>/Initialize */
%if ADxCSS_HL != 0  
%if ADxCSS_simple_Or_HL == 0
AD%<ADCRef>CSSL = %<MchpHex(ADxCSS_HL)>;	/* Scan mode */ 	
%else
AD%<ADCRef>CSSL = %<MchpHex(ADxCSS_HL & 65535)>;	/* Scan mode */
%if (ADCRefNum == 1) 
AD%<ADCRef>CSSH = %<MchpHex(ADxCSS_HL \>\> 16)>;
%endif
%endif
%endif
%if (ANtype_or == 2) || (ChipIdN[0] == 30)	
AD%<ADCRef>CHS = %<MchpHex(ADxCHS0)>;
%else
AD%<ADCRef>CHS0 = %<MchpHex(ADxCHS0)>;
%endif
%if %<ADxCHS123> != -1
AD%<ADCRef>CHS123 = %<MchpHex(ADxCHS123)>;
%endif
%foreach idx = SIZE(ADxCON,1)
%assign idxInv = %<SIZE(ADxCON,1) - idx -1>
%if ADxCON[idxInv] != -1
%if (idxInv == 0) && (TimeStep_Timer == -1) && (TimeStep_SyncADC != -1) && ( (ADxCON[idxInv] & 32768) == 32768)		
/* ADC is used to trig the model Time-step. AD%<ADCRef>CON%<idxInv + 1> will be set after the setup-code */
%openfile LocalStartup_TrigTimeStepInstruction
%<::Startup_TrigTimeStepInstruction>\
AD%<ADCRef>CON%<idxInv + 1> = %<MchpHex(ADxCON[idxInv])>;	/* ADC trig the model Time-step */ 
%closefile LocalStartup_TrigTimeStepInstruction
%assign ::Startup_TrigTimeStepInstruction = LocalStartup_TrigTimeStepInstruction
%else
AD%<ADCRef>CON%<idxInv + 1> = %<MchpHex(ADxCON[idxInv])>;	
%endif
%endif
%endforeach
%assign InterruptPriority = 2
%if DMACHANNEL != -1
DMA%<DMACHANNEL>CNT = %<DMA_CNT>;	/* %<DMA_CNT+1> DMA Requests */ 
DMA%<DMACHANNEL>REQ = %<MchpHex(DMAREQ_TAB[ADCRefNum])>;	/* Configure with ADC %<ADCRefNum> */ 
DMA%<DMACHANNEL>PAD = (volatile unsigned int) &ADC%<ADCRef>BUF0;
%switch ChipIdL1
%case "HJ"
%case "FJ"
DMA%<DMACHANNEL>STA = (unsigned int) (%<MEMORY_DMA_QUALIFIER> uint16_T*) &ADC%<ADCRef>BuffChannelA ;
%if (ADC_PingPong == 1) && (Continuous_PingPong == 1)	
DMA%<DMACHANNEL>STB = (unsigned int) (%<MEMORY_DMA_QUALIFIER> uint16_T*) &ADC%<ADCRef>BuffChannelB ;
%endif
%break
%case "EP"
%case "EV"
%if ISEQUAL(MEMORY_DMA_QUALIFIER,"__eds__")
DMA%<DMACHANNEL>STAL = __builtin_edsoffset(ADC%<ADCRef>BuffChannelA);
%else
DMA%<DMACHANNEL>STAL = (unsigned int) (%<MEMORY_DMA_QUALIFIER> uint16_T*) &ADC%<ADCRef>BuffChannelA ;
%endif
DMA%<DMACHANNEL>STAH = 0x0000;
%if (ADC_PingPong == 1) && (Continuous_PingPong == 1)	
%if ISEQUAL(MEMORY_DMA_QUALIFIER,"__eds__")
DMA%<DMACHANNEL>STBL = __builtin_edsoffset(ADC%<ADCRef>BuffChannelB);
%else
DMA%<DMACHANNEL>STBL = (unsigned int) (%<MEMORY_DMA_QUALIFIER> uint16_T*) &ADC%<ADCRef>BuffChannelB ;
%endif
DMA%<DMACHANNEL>STBH = 0x0000 ;
%endif
%break
%endswitch
_DMA%<DMACHANNEL>IF = 0;
_DMA%<DMACHANNEL>IE = 1; /* Enable DMA Interrupt */
_DMA%<DMACHANNEL>IP = %<InterruptPriority>; 
%if (ADC_PingPong == 1) && (Continuous_PingPong == 1)	
DMA%<DMACHANNEL>CON = 0x8002 ;	/* Activate DMA, Continuous Ping Pong Mode */
%else
DMA%<DMACHANNEL>CON = 0x8000 ;	/* Activate DMA, Single transfert Mode */
%endif
%else	
_AD%<ADCRef>IP = %<InterruptPriority>; /*Interrupt Priority : %<InterruptPriority>*/
_AD%<ADCRef>IF = 0;
%if (ADC_PingPong == 1) || (TimeStep_SyncADC != -1)		
_AD%<ADCRef>IE = 1;	 /* Enable ADC Interrupt */
%endif
%endif
%openfile dspicfun = "MCHP_ADC%<ADCRef>_Interrupt.c"
#include "%<LibGetMdlPubHdrBaseName()>.h"
#include "%<LibGetMdlPubHdrBaseName()>_private.h"
/* ADC - Interrupt: %<Name> */
%if (TimeStep_SyncADC != -1)
%assign AUTO_PSV = "__auto_psv__"	
%else
%assign AUTO_PSV = Mchp_No_auto_psv()		
%endif
%if DMACHANNEL != -1 
%<MEMORY_DMA_QUALIFIER> volatile uint16_T ADC%<ADCRef>BuffChannelA[%<NConvSizeMem>] %<MEMORY_DMA_ATTRIBUTE>;
%if (ADC_PingPong == 1)
%<MEMORY_DMA_QUALIFIER>  volatile uint16_T ADC%<ADCRef>BuffChannelB[%<NConvSizeMem>] %<MEMORY_DMA_ATTRIBUTE>;
%endif
%if (ADC_PingPong == 1) && (Continuous_PingPong == 0)
volatile %<MEMORY_DMA_QUALIFIER> uint16_T* ADC%<ADCRef>BuffChannelPtr = (%<MEMORY_DMA_QUALIFIER> uint16_T*) &ADC%<ADCRef>BuffChannelB; /* Initialize with next buffer to write. First buffer read is A */
%else
volatile uint16_T MCHP_DMAPPS_duplicate = 0; /* DMAPPS is updated after the first byte/world in the new block gets transferred by the DMA */
%endif
%else 
%if (ADC_PingPong == 1) || (TimeStep_SyncADC != -1)
volatile uint16_T ADC%<ADCRef>BuffChannelA[%<NConvSizeMem>];
%endif
%endif
%if TrigAfterEachConversion == 1
volatile uint16_T ADCSeqState = 0;
%endif
%if  ( (TimeStep_Timer != -1) && (TimeStep_SyncADC == 1) )
%assign TimeStep_Timer = CAST("Number",RTWGenSettings.TimeStep_Timer)
%openfile LocalStartup_TrigTimeStepInstruction
%<::Startup_TrigTimeStepInstruction>\		 		
%<MCHP_SFR(  "T%<TimeStep_Timer>IF"  , 0 				   , "Clear Timer %<TimeStep_Timer> Interrupt flag" )>  
%<MCHP_SFR(  "T%<TimeStep_Timer>IE"  , 1 				   , "Enable Timer %<TimeStep_Timer> model Step Interrupt" )>  
%closefile LocalStartup_TrigTimeStepInstruction
%assign ::Startup_TrigTimeStepInstruction = LocalStartup_TrigTimeStepInstruction
%<Mchp_Interrupt16(InterruptPriority,AUTO_PSV,"T%<TimeStep_Timer>Interrupt",block)>
{
%<MCHP_ProfileMCU("enter")>
AD%<ADCRef>CON1 = %<MchpHex( ((ADxCON[0] & 65295) + 224 ) )>;	/* Force bits 4-7 for automatic sampling */ 
%if DMACHANNEL != -1
%if (ADC_PingPong == 1) && (Continuous_PingPong == 0)
DMA%<DMACHANNEL>CONbits.CHEN = 1;	/* Re-Enable DMA */
%endif
%endif
%<MCHP_SFR(  "T%<TimeStep_Timer>IF"  , 0 				   , "Disable Interrupt" )>  
%<MCHP_ProfileMCU("exitUpdate")>
}
%endif
%if DMACHANNEL != -1
%<Mchp_Interrupt16(InterruptPriority,AUTO_PSV,"DMA%<DMACHANNEL>Interrupt",block)>
{
%<MCHP_ProfileMCU("enter")>
%if (ADC_PingPong == 1) && (Continuous_PingPong == 1)	
%switch ChipIdL1
%case "EP"	
%case "EV"
%assign DMAPPS_DMACS1 = "DMAPPS"
%break
%default
%assign DMAPPS_DMACS1 = "DMACS1"
%break
%endswitch
MCHP_DMAPPS_duplicate = %<DMAPPS_DMACS1>; /* Copy %<DMAPPS_DMACS1> because it is updated only after the first byte/world in the new block gets transferred by the DMA. Interrupt must be handle early enough to copy %<DMAPPS_DMACS1> before that update occurs. */
%elseif (ADC_PingPong == 1) && (Continuous_PingPong == 0)	 
DMA%<DMACHANNEL>CONbits.CHEN = 0;	/* Disable DMA (clear DMA counter)*/
%switch ChipIdL1
%case "HJ"
%case "FJ"
DMA%<DMACHANNEL>STA = (uint16_T) (%<MEMORY_DMA_QUALIFIER> uint16_T*)  ADC%<ADCRef>BuffChannelPtr ; 	/* Set up Next Buffer to fill in */
%break
%case "EP"
%case "EV"
DMA%<DMACHANNEL>STAL = (uint16_T) (%<MEMORY_DMA_QUALIFIER> uint16_T*)  ADC%<ADCRef>BuffChannelPtr ; 	/* Set up Next Buffer to fill in */  
%break
%endswitch
if (ADC%<ADCRef>BuffChannelPtr == (%<MEMORY_DMA_QUALIFIER> uint16_T*) &ADC%<ADCRef>BuffChannelB)
ADC%<ADCRef>BuffChannelPtr = (%<MEMORY_DMA_QUALIFIER> uint16_T*) &ADC%<ADCRef>BuffChannelA;		/* Switch Buffer for next reading */
else
ADC%<ADCRef>BuffChannelPtr = (%<MEMORY_DMA_QUALIFIER> uint16_T*) &ADC%<ADCRef>BuffChannelB;		/* Switch Buffer for next reading */
%if (TrigAfterEachConversion != 1) && (TimeStep_Timer != -1) && (TimeStep_SyncADC == 1) 
AD%<ADCRef>CON1 &= %<MchpHex(32767)>;	/* Must cancel current sampling */ 
%endif
%if TrigAfterEachConversion == 1
DMA%<DMACHANNEL>CON = 0x8000 ;	/* Re-Activate DMA for Single transfert */				
%endif
%endif
%if TimeStep_SyncADC == -1	
_DMA%<DMACHANNEL>IF = 0;
%else 
%with CompiledModel	
%<MCHP_Scheduler("DMA",DMACHANNEL,ChipIdN)>
%endwith
%endif
%<MCHP_ProfileMCU("exitUpdate")>
}
%elseif (ADC_PingPong == 1) || (TimeStep_SyncADC != -1)	
%switch ChipIdL1
%case "EP"
%case "EV"
%<Mchp_Interrupt16(InterruptPriority,AUTO_PSV,"AD%<ADCRef>Interrupt",block)> 		
%break
%default
%<Mchp_Interrupt16(InterruptPriority,AUTO_PSV,"ADC%<ADCRef>Interrupt",block)>
%break
%endswitch
{
%if TimeStep_SyncADC == -1	
_AD%<ADCRef>IF = 0;
%endif
%<MCHP_ProfileMCU("enter")>
%if ADC_PingPong == 1
%if TrigAfterEachConversion != 1	
%foreach i = NConv
ADC%<ADCRef>BuffChannelA[%<i>] = ADC%<ADCRef>BUF%<FEVAL("dec2hex",i)>; /* Copy value from ADC buffer  */	
%endforeach
%else
%assign MemIdx = 0
%assign idxCHS0 = 0
switch (ADCSeqState) {
case 0:
%assign SwitchCaseIdx = 1
%foreach i = NConv
%if MemIdx >= nSampleHold	
%if (ANtype_or == 2) || (ChipIdN[0] == 30)	
AD%<ADCRef>CHS = %<MchpHex(ADxCHS0_ADxCSS[SwitchCaseIdx])>;	/* Prepare to convert AN%<ADxCHS0_ADxCSS[SwitchCaseIdx]> through CH0 */
%else
AD%<ADCRef>CHS0 = %<MchpHex(ADxCHS0_ADxCSS[SwitchCaseIdx])>; /* Prepare to convert AN%<ADxCHS0_ADxCSS[SwitchCaseIdx]> through CH0 */
%endif
%assign MemIdx = 0			
break;
case %<SwitchCaseIdx>:
%assign SwitchCaseIdx = SwitchCaseIdx + 1
%endif
%if MemIdx == 0	
ADC%<ADCRef>BuffChannelA[%<idxCHS0>] = ADC%<ADCRef>BUF%<FEVAL("dec2hex",MemIdx)>; /* Copy value from ADC buffer  */	
%assign idxCHS0 = idxCHS0 + 1
%else
ADC%<ADCRef>BuffChannelA[%<MemIdx + LengthADxCSS - 1 >] = ADC%<ADCRef>BUF%<FEVAL("dec2hex",MemIdx)>; /* Copy value from ADC buffer  */	
%endif
%assign MemIdx = MemIdx + 1
%endforeach
%if (ANtype_or == 2) || (ChipIdN[0] == 30)	
AD%<ADCRef>CHS = %<MchpHex(ADxCHS0_ADxCSS[0])>;	/* Prepare to convert AN%<ADxCHS0_ADxCSS[0]> through CH0 */
%else
AD%<ADCRef>CHS0 = %<MchpHex(ADxCHS0_ADxCSS[0])>; /* Prepare to convert AN%<ADxCHS0_ADxCSS[0]> through CH0 */
%endif
break;
} /* switch case*/
%endif
%endif
%if TimeStep_SyncADC != -1	
%if  (TimeStep_SyncADC != -1) && (TimeStep_Timer != -1) && (TimeStep_SyncADC == 1) 
AD%<ADCRef>CON1 &= %<MchpHex(32767)>;	/* Must cancel current sampling */ 
%endif
%with CompiledModel	
%<MCHP_Scheduler("AD",ADCRef,ChipIdN)>
%endwith
%endif
%<MCHP_ProfileMCU("exitUpdate")>
}
%endif
%closefile dspicfun
%endfunction
%function Outputs(block, system) Output
%assign ADCFlags = MchpVector(RTWdata.ADCFlags)
%assign NConv = CAST("Number",block.RTWdata.NConv)
%assign LengthADxCSS = CAST("Number",block.RTWdata.LengthADxCSS)
%assign nSampleHold = CAST("Number",block.RTWdata.nSampleHold)
%assign nSeq = CAST("Number",block.RTWdata.nSeq)
%assign seqRepeat = CAST("Number",block.RTWdata.seqRepeat)
%assign ChipIdL1 = CAST("String",RTWGenSettings.ChipIdL1)
%assign ChipIdL2 = CAST("String",RTWGenSettings.ChipIdL2)
%assign ChipIdL3 = CAST("String",RTWGenSettings.ChipIdL3)
%assign ChipIdN =  MchpVector(RTWGenSettings.ChipIdN)
%assign DMACHANNEL = CAST("Number",block.RTWdata.DMACHANNEL)
%assign TrigAfterEachConversion = CAST("Number",block.RTWdata.TrigAfterEachConversion)
%if DMACHANNEL != -1
%assign MEMORY_DMA_QUALIFIER = MchpDMA_MemoryQualifier()
%else
%assign MEMORY_DMA_QUALIFIER = ""
%endif
%assign ADCRefNum = CAST("Number",block.RTWdata.ADCRef)
%if ADCFlags[0] == 0
%assign ADCRef = ""		
%else
%assign ADCRef = ADCRefNum
%endif
%assign ADC_PingPong =  CAST("Number",RTWGenSettings.ADC_PingPong)
%assign Continuous_PingPong =  CAST("Number",RTWdata.Continuous_PingPong)
%assign NConv = CAST("Number",block.RTWdata.NConv)
/* MCHP_ADC Block for ADC %<ADCRef>: %<Name>/Output */
%if (DMACHANNEL != -1) && (Continuous_PingPong == 1)
%<MEMORY_DMA_QUALIFIER> uint16_T* ADC%<ADCRef>BuffChannelPtr;	/* Local Variable when Continuous_PingPong, otherwise it's a glboal one */
if ((MCHP_DMAPPS_duplicate & %< 1U << DMACHANNEL>) != 0) /* Check which is last buffer written and read from this one */ 
ADC%<ADCRef>BuffChannelPtr = (%<MEMORY_DMA_QUALIFIER> uint16_T*) &ADC%<ADCRef>BuffChannelB;
else
ADC%<ADCRef>BuffChannelPtr = (%<MEMORY_DMA_QUALIFIER> uint16_T*) &ADC%<ADCRef>BuffChannelA;
%endif
%if TrigAfterEachConversion == 1	
{
switch (ADCSeqState) {
%endif
%assign ADCBUFidx = 0
%foreach iSeqRepeat = seqRepeat
%assign portCH123 = 0
%foreach iADxCSS = LengthADxCSS 								 
%if TrigAfterEachConversion == 1
case %<iADxCSS>:
%endif
%if TrigAfterEachConversion == 1
%assign y = LibBlockOutputSignal(iADxCSS, "", "", 0)	
%else
%assign y = LibBlockOutputSignal(iADxCSS, "", "", iSeqRepeat)	
%endif
%if (DMACHANNEL == -1) && (ADC_PingPong == 0) 
%<y> = ADC%<ADCRef>BUF%<buffindex(ADCFlags[1],ADCBUFidx)>; /* read result directly from ADC internal Buffer ADC%<ADCRef>BUF%<buffindex(ADCFlags[1],ADCBUFidx)> */	
%elseif (DMACHANNEL == -1) && (ADC_PingPong == 1)	
%<y> = ADC%<ADCRef>BuffChannelA[%<ADCBUFidx>];		
%elseif (DMACHANNEL != -1) && (ADC_PingPong == 0)
%<y> = ADC%<ADCRef>BuffChannelA[%<ADCBUFidx>];		
%else
%<y> = ADC%<ADCRef>BuffChannelPtr[%<ADCBUFidx>];		
%endif
%if (TrigAfterEachConversion == 1) && (DMACHANNEL == -1) && (ADC_PingPong == 1)	
%assign ADCBUFidx = LengthADxCSS
%else
%assign ADCBUFidx = ADCBUFidx + 1
%endif
%switch  nSampleHold
%case 2
%case 4
%foreach i = (nSampleHold-1)
%if TrigAfterEachConversion == 1
%assign y = LibBlockOutputSignal(LengthADxCSS + i, "", "", 0)		
%else
%assign y = LibBlockOutputSignal(LengthADxCSS + i, "", "", (LengthADxCSS * iSeqRepeat) + portCH123)
%endif
%if (DMACHANNEL == -1) && (ADC_PingPong == 0) 
%<y> = ADC%<ADCRef>BUF%<buffindex(ADCFlags[1],ADCBUFidx)>; /* read result directly from ADC internal Buffer ADC%<ADCRef>BUF%<buffindex(ADCFlags[1],ADCBUFidx)> */	
%elseif (DMACHANNEL == -1) && (ADC_PingPong == 1)	
%<y> = ADC%<ADCRef>BuffChannelA[%<ADCBUFidx>];		
%elseif (DMACHANNEL != -1) && (ADC_PingPong == 0)
%<y> = ADC%<ADCRef>BuffChannelA[%<ADCBUFidx>];		
%else
%<y> = ADC%<ADCRef>BuffChannelPtr[%<ADCBUFidx>];		
%endif
%assign ADCBUFidx = ADCBUFidx + 1
%endforeach
%assign portCH123 = portCH123 + 1	
%break
%endswitch
%if TrigAfterEachConversion == 1
%if (iSeqRepeat == seqRepeat-1) && (iADxCSS == LengthADxCSS-1) && (nSeq == 1)
ADCSeqState = 0;
%else
ADCSeqState = ADCSeqState+1;
%endif
break;
%if (TrigAfterEachConversion == 1) && (DMACHANNEL == -1) && (ADC_PingPong == 1)	
%assign ADCBUFidx = portCH123 
%else
%assign ADCBUFidx = 0		
%endif
%endif
%if (nSeq == 2)
%foreach i = (nSampleHold)
%if TrigAfterEachConversion == 1
%assign y = LibBlockOutputSignal(LengthADxCSS + (nSampleHold-1) + i, "", "", 0) 	
%else
%assign y = LibBlockOutputSignal(LengthADxCSS + (nSampleHold-1) + i, "", "", (LengthADxCSS * iSeqRepeat) + portCH123)
%endif
%if (DMACHANNEL == -1) && (ADC_PingPong == 0) 
%<y> = ADC%<ADCRef>BUF%<buffindex(ADCFlags[1],ADCBUFidx)>; /* read result directly from ADC internal Buffer ADC%<ADCRef>BUF%<buffindex(ADCFlags[1],ADCBUFidx)> */	
%elseif (DMACHANNEL == -1) && (ADC_PingPong == 1)	
%<y> = ADC%<ADCRef>BuffChannelA[%<ADCBUFidx>];		
%elseif (DMACHANNEL != -1) && (ADC_PingPong == 0)
%<y> = ADC%<ADCRef>BuffChannelA[%<ADCBUFidx>];		
%else
%<y> = ADC%<ADCRef>BuffChannelPtr[%<ADCBUFidx>];		
%endif
%assign ADCBUFidx = ADCBUFidx + 1
%endforeach
%assign portCH123 = portCH123 + 1	
%if TrigAfterEachConversion == 1
%if (iSeqRepeat == seqRepeat-1) && (iADxCSS == LengthADxCSS-1)
ADCSeqState = 0;
%else
ADCSeqState = ADCSeqState+1;
%endif
break;
%assign ADCBUFidx = 0		
%endif
%endif 
%endforeach 
%endforeach 
%if TrigAfterEachConversion == 1
}
}
%endif
%endfunction
%function buffindex(decOrHex,ADCBUFidx) Output
%if decOrHex == 0
%<FEVAL("dec2hex",ADCBUFidx)>\		
%else
%<ADCBUFidx>\
%endif
%endfunction
%function Update(block, system) Output
%endfunction
