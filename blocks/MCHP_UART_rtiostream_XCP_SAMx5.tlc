%include "MCHP_UART_Rx_SAMx5_FunUtils.tlc"
%include "MCHP_UART_Tx_SAMx5_FunUtils.tlc"
%function UART_rtiostream(block, system) void
%if ExtMode  		
%warning("Ext mode detected ")	
%if EXISTS(ExtModeXCP) && (ExtModeXCP != 0)
%<LibAddToModelSources("xcp_frame_serial")> 
%<LibAddToModelSources("xcp_ext_param_default_serial")> 
%warning("Adding XCP rtiostream")	
%<write_xcp_platform_custom()>
%else 
%<LibAddToModelSources("rtiostream_interface")> 
%warning("Adding Classical rtiostream")	
%endif
%endif	
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%assign nUSART = CAST("Number",block.RTWdata.nUSART)
%assign UART_NAME = UART_Rx_get_UART_NAME(block)
%assign TX_IMPLEMENTATION = MchpVector(RTWGenSettings.UART_TX_IMPLEMENTATION)
%assign TX_IMPLEMENTATION = TX_IMPLEMENTATION[UARTRef-1]		
%assign RX_IMPLEMENTATION = MchpVector(RTWGenSettings.UART_RX_IMPLEMENTATION)
%assign RX_IMPLEMENTATION = RX_IMPLEMENTATION[UARTRef-1]		
%assign UART_HALF_DUPLEX_MODE = MchpVector(RTWGenSettings.UART_HALF_DUPLEX_MODE)
%assign UART_HALF_DUPLEX_MODE = UART_HALF_DUPLEX_MODE[UARTRef-1]	
%include "MCHP_rtiostream.tlc"  			
%openfile rtiostreamFile_c = "rtiostream.c"				
/* Customized function for MCHP microcontrollers */
#include "%<LibGetMdlPubHdrBaseName()>.h"
#include "%<LibGetMdlPubHdrBaseName()>_private.h"
#include "rtiostream.h"
/* Initialize Serial */
int rtIOStreamOpen(int argc, void *argv[])
{
/* Could send an initial message for handshaking*/
return RTIOSTREAM_NO_ERROR;
}
/* Read data from serial */
int rtIOStreamRecv(
int      streamID,  // A handle to the stream that was returned by a previous call to rtIOStreamOpen.
void   * dst,       // A pointer to the start of the buffer where received data must be copied.
size_t   size, 	    // Size of data to copy into the buffer. For byte-addressable architectures,
// size is measured in bytes. Some DSP architectures are not byte-addressable.
// In these cases, size is measured in number of WORDs, where sizeof(WORD) == 1.
size_t * sizeRecvd) // The number of units of data received and copied into the buffer dst (zero if no data was copied).
{
uint8_T *ptr = (uint8_T *)dst; // Initialize ptr is a pointer to the buffer of chars.
*sizeRecvd=0U; 		// Initialize the number of received chars to zero.
%if UART_HALF_DUPLEX_MODE
%assign errmsg = "UART%<UARTRef> is configured for Half duplex mode. This mode is not compatible with either External Mode nor Processor in the Loop (PIL)."
%<LibBlockReportError(block,errmsg)>
%error(errmsg)				
%endif
%switch RX_IMPLEMENTATION
%case 0	
%error("RX is not implemented, please select one implementation method in the UART %<UARTRef> configuration block.")
%break
%case 1	
%warning("UART Rx without using a circular buffer for PIL / Ext-Mode will cause 'Not Enough Memory' issues. Considere using a circular buffer.")	
while ((*sizeRecvd < size) && %<URXNotEmpty(block)>)
{
*ptr++ = %<UART_Rx_ReadRegister(block)>;      /* Read one received byte  */	
(*sizeRecvd)++; 		 // Increase the number of received chars.
}			
%<UART_Rx_TestAndClearErrors(block)>
return RTIOSTREAM_NO_ERROR;
%break
%case 2 
%<UART_Rx_CircularBuffer_flushBuffer(block)>
while ((*sizeRecvd < size) && (MCHP_%<UART_NAME>_Rx.tail != MCHP_%<UART_NAME>_Rx.head)) 	/* Circular buffer not empty ? */
{
*ptr++ = (uint8_T) MCHP_%<UART_NAME>_Rx.buffer[MCHP_%<UART_NAME>_Rx.head];				/* Read received values from buffer */
MCHP_%<UART_NAME>_Rx.head = (MCHP_%<UART_NAME>_Rx.head+1) & (Rx_BUFF_SIZE_%<UART_NAME>-1);
(*sizeRecvd)++; 		 /* Increase the number of received chars */
}		
%<UART_Rx_TestAndClearErrors(block)>
return RTIOSTREAM_NO_ERROR;
%break		
%default
%error("implementation method not supported for UART Ext-Mode or PIL mode. Considere using a Circular Buffer implementation for UART")
return RTIOSTREAM_ERROR;
%endswitch	
}
/* Write data to serial */
int rtIOStreamSend(
int          streamID,
const void * src,
size_t       size,
size_t     * sizeSent)
{
uint8_T *ptr = (uint8_T *)src;	/* Initialize ptr is a pointer to the buffer of chars */
*sizeSent=0U;	/* Initialize the number of sent chars to zero */
%switch TX_IMPLEMENTATION
%case 0	
%error("TX is not implemented, please select one implementation method in the UART %<UARTRef> configuration block.")
%break
%case 1	
while ((*sizeSent < size) && %<UTXEmpty(block)> ) {
%<UART_Tx_WriteRegister(block)> = *ptr++;       /* Simplest UART Tx implementation: copy byte into the buffer */				
(*sizeSent)++;	
}
return RTIOSTREAM_NO_ERROR;					
%break
%case  2	
uint_T Tmp;	
uint_T LocalTail;
LocalTail = MCHP_%<UART_NAME>_Tx.tail;	/* Tail is a volatile variable. Use local variable to speed-up execution */	
/* Compute free space */
Tmp = ~(LocalTail - MCHP_%<UART_NAME>_Tx.head);
Tmp = Tmp & (Tx_BUFF_SIZE_%<UART_NAME> - 1);							/* Modulo Buffer Size */
if ( (size < Tx_BUFF_SIZE_%<UART_NAME>)  && (Tmp <= size) )	/* Send the packet or nothing if packet size fit the buffer */ 
return RTIOSTREAM_NO_ERROR;
while (( (*sizeSent) < size) && (Tmp != 0) )
{
MCHP_%<UART_NAME>_Tx.buffer[LocalTail] = *ptr++;
LocalTail = (LocalTail + 1) & (Tx_BUFF_SIZE_%<UART_NAME> - 1);
Tmp--;
(*sizeSent)++;
}
MCHP_%<UART_NAME>_Tx.tail = LocalTail; /* Push back volatile variable */
%<UART_Tx_FlushCirculerBuffer(UART_HALF_DUPLEX_MODE,block)>		
return RTIOSTREAM_NO_ERROR;			
%break
%case 3 
%case 4	
%error ***UART Tx Set to use DMA is not compatible with the PIL or Ext-Mode setting
return RTIOSTREAM_ERROR;
%break
%endswitch
}
int rtIOStreamClose(int streamID)
{
return RTIOSTREAM_NO_ERROR;
}
%closefile rtiostreamFile_c
%endfunction	
%function write_xcp_platform_custom() void
%openfile xcp_platform_custom_h = "xcp_platform_custom.h"
#ifndef XCP_PLATFORM_CUSTOM_H
#define XCP_PLATFORM_CUSTOM_H
#include <xc.h>
/* XCP_ADDRESS_GET */
#include <stdint.h>
#define XCP_ADDRESS_GET(addressExtension, address)  (uint8_T*) ((uintptr_t) address)
/* XCP_MUTEX */
#define XCP_MUTEX_DEFINE(lock)
#define XCP_MUTEX_INIT(lock)
#define XCP_MUTEX_LOCK(lock)      __disable_irq();
#define XCP_MUTEX_UNLOCK(lock)    __enable_irq();
#define XCP_PRINTF // save lots of memory but generates many warnings for unused parameters
/* XCP_SLEEP */
#define XCP_SLEEP(seconds,microseconds)
#endif
%closefile xcp_platform_custom_h
%endfunction