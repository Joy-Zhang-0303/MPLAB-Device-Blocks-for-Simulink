
%function UART_Tx_get_UART_NAME(block) void
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%assign nUSART = CAST("Number",block.RTWdata.nUSART)	
%switch ::ChipIdL1
%case "SAME"
%case "SAMS"
%case "SAMV"
%if UARTRef > nUSART
%assign Per_Type = "UART"
%assign REG_NAME = "UART"
%assign REG_NAME2 = ""
%assign INTERRUPT_STATUS_REG = "SR"
%assign UART_Index = (UARTRef-1) - nUSART
%else
%assign Per_Type = "USART"
%assign REG_NAME = "US"
%assign REG_NAME2 = "USART_"
%assign INTERRUPT_STATUS_REG = "CSR"
%assign UART_Index = UARTRef-1
%endif
%assign UART_NAME = "%<Per_Type>%<UART_Index>"
%break
%case "SAMRH"
%assign Per_Type = "USART"
%assign REG_NAME = "FLEX_US"
%assign REG_NAME2 = ""
%assign INTERRUPT_STATUS_REG = "CSR"
%assign UART_Index = UARTRef-1
%assign UART_NAME = "FLEXCOM%<UART_Index>"
%break
%default
%error("Internal error with UART")
%endswitch
%return UART_NAME
%endfunction	
%function UTXEmpty(block) void
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%assign nUSART = CAST("Number",block.RTWdata.nUSART)
%switch ::ChipIdL1
%case "SAME"
%case "SAMS"
%case "SAMV"
%if UARTRef > nUSART
%assign Per_Type = "UART"
%assign REG_NAME = "UART"
%assign REG_NAME2 = ""
%assign INTERRUPT_STATUS_REG = "SR"
%assign UART_Index = (UARTRef-1) - nUSART
%else
%assign Per_Type = "USART"
%assign REG_NAME = "US"
%assign REG_NAME2 = "USART_"
%assign INTERRUPT_STATUS_REG = "CSR"
%assign UART_Index = UARTRef-1
%endif
%assign UART_NAME = "%<Per_Type>%<UART_Index>"
%break
%case "SAMRH"
%assign Per_Type = "USART"
%assign REG_NAME = "FLEX_US"
%assign REG_NAME2 = ""
%assign INTERRUPT_STATUS_REG = "CSR"
%assign UART_Index = UARTRef-1
%assign UART_NAME = "FLEXCOM%<UART_Index>"
%break
%default
%error("Internal error with UART")
%endswitch
%return "(0U != (%<UART_NAME>_REGS->%<REG_NAME>_%<INTERRUPT_STATUS_REG> & %<REG_NAME>_%<INTERRUPT_STATUS_REG>_%<REG_NAME2>TXRDY_Msk))"
%endfunction
%function UTXNotEmpty(block) void
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%assign nUSART = CAST("Number",block.RTWdata.nUSART)
%switch ::ChipIdL1
%case "SAME"
%case "SAMS"
%case "SAMV"
%if UARTRef > nUSART
%assign Per_Type = "UART"
%assign REG_NAME = "UART"
%assign REG_NAME2 = ""
%assign INTERRUPT_STATUS_REG = "SR"
%assign UART_Index = (UARTRef-1) - nUSART
%else
%assign Per_Type = "USART"
%assign REG_NAME = "US"
%assign REG_NAME2 = "USART_"
%assign INTERRUPT_STATUS_REG = "CSR"
%assign UART_Index = UARTRef-1
%endif
%assign UART_NAME = "%<Per_Type>%<UART_Index>"
%break
%case "SAMRH"
%assign Per_Type = "USART"
%assign REG_NAME = "FLEX_US"
%assign REG_NAME2 = ""
%assign INTERRUPT_STATUS_REG = "CSR"
%assign UART_Index = UARTRef-1
%assign UART_NAME = "FLEXCOM%<UART_Index>"
%break
%default
%error("Internal error with UART")
%endswitch
%return "(0U == (%<UART_NAME>_REGS->%<REG_NAME>_%<INTERRUPT_STATUS_REG> & %<REG_NAME>_%<INTERRUPT_STATUS_REG>_%<REG_NAME2>TXRDY_Msk))"
%endfunction
%function UTX_NotCompleted(block) void
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%assign nUSART = CAST("Number",block.RTWdata.nUSART)
%switch ::ChipIdL1
%case "SAME"
%case "SAMS"
%case "SAMV"
%if UARTRef > nUSART
%assign Per_Type = "UART"
%assign REG_NAME = "UART"
%assign REG_NAME2 = ""
%assign INTERRUPT_STATUS_REG = "SR"
%assign UART_Index = (UARTRef-1) - nUSART
%else
%assign Per_Type = "USART"
%assign REG_NAME = "US"
%assign REG_NAME2 = "USART_"
%assign INTERRUPT_STATUS_REG = "CSR"
%assign UART_Index = UARTRef-1
%endif
%assign UART_NAME = "%<Per_Type>%<UART_Index>"
%break
%case "SAMRH"
%assign Per_Type = "USART"
%assign REG_NAME = "FLEX_US"
%assign REG_NAME2 = ""
%assign INTERRUPT_STATUS_REG = "CSR"
%assign UART_Index = UARTRef-1
%assign UART_NAME = "FLEXCOM%<UART_Index>"
%break
%default
%error("Internal error with UART")
%endswitch
%return "(0U == (%<UART_NAME>_REGS->%<REG_NAME>_%<INTERRUPT_STATUS_REG> & %<REG_NAME>_%<INTERRUPT_STATUS_REG>_%<REG_NAME2>TXEMPTY_Msk))"
%endfunction
%function UTX_Completed(block) void
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%assign nUSART = CAST("Number",block.RTWdata.nUSART)
%switch ::ChipIdL1
%case "SAME"
%case "SAMS"
%case "SAMV"
%if UARTRef > nUSART
%assign Per_Type = "UART"
%assign REG_NAME = "UART"
%assign REG_NAME2 = ""
%assign INTERRUPT_STATUS_REG = "SR"
%assign UART_Index = (UARTRef-1) - nUSART
%else
%assign Per_Type = "USART"
%assign REG_NAME = "US"
%assign REG_NAME2 = "USART_"
%assign INTERRUPT_STATUS_REG = "CSR"
%assign UART_Index = UARTRef-1
%endif
%assign UART_NAME = "%<Per_Type>%<UART_Index>"
%break
%case "SAMRH"
%assign Per_Type = "USART"
%assign REG_NAME = "FLEX_US"
%assign REG_NAME2 = ""
%assign INTERRUPT_STATUS_REG = "CSR"
%assign UART_Index = UARTRef-1
%assign UART_NAME = "FLEXCOM%<UART_Index>"
%break
%default
%error("Internal error with UART")
%endswitch
%return "(0U != (%<UART_NAME>_REGS->%<REG_NAME>_%<INTERRUPT_STATUS_REG> & %<REG_NAME>_%<INTERRUPT_STATUS_REG>_%<REG_NAME2>TXEMPTY_Msk))"
%endfunction
%function UART_Tx_WriteRegister(block) void
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%assign nUSART = CAST("Number",block.RTWdata.nUSART)
%switch ::ChipIdL1
%case "SAME"
%case "SAMS"
%case "SAMV"
%if UARTRef > nUSART
%assign Per_Type = "UART"
%assign REG_NAME = "UART"
%assign REG_NAME2 = ""
%assign INTERRUPT_STATUS_REG = "SR"
%assign UART_Index = (UARTRef-1) - nUSART
%else
%assign Per_Type = "USART"
%assign REG_NAME = "US"
%assign REG_NAME2 = "USART_"
%assign INTERRUPT_STATUS_REG = "CSR"
%assign UART_Index = UARTRef-1
%endif
%assign UART_NAME = "%<Per_Type>%<UART_Index>"
%break
%case "SAMRH"
%assign Per_Type = "USART"
%assign REG_NAME = "FLEX_US"
%assign REG_NAME2 = ""
%assign INTERRUPT_STATUS_REG = "CSR"
%assign UART_Index = UARTRef-1
%assign UART_NAME = "FLEXCOM%<UART_Index>"
%break
%default
%error("Internal error with UART")
%endswitch
%return "%<UART_NAME>_REGS->%<REG_NAME>_THR"
%endfunction
%function Test_No_DMA_Transfert_F(DMA_DCH,TX_DMA_CHANNEL,UARTRef,block) void
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%assign nUSART = CAST("Number",block.RTWdata.nUSART)
%switch ::ChipIdL1
%case "SAME"
%case "SAMS"
%case "SAMV"
%if UARTRef > nUSART
%assign Per_Type = "UART"
%assign REG_NAME = "UART"
%assign REG_NAME2 = ""
%assign INTERRUPT_STATUS_REG = "SR"
%assign UART_Index = (UARTRef-1) - nUSART
%else
%assign Per_Type = "USART"
%assign REG_NAME = "US"
%assign REG_NAME2 = "USART_"
%assign INTERRUPT_STATUS_REG = "CSR"
%assign UART_Index = UARTRef-1
%endif
%assign UART_NAME = "%<Per_Type>%<UART_Index>"
%break
%case "SAMRH"
%assign Per_Type = "USART"
%assign REG_NAME = "FLEX_US"
%assign REG_NAME2 = ""
%assign INTERRUPT_STATUS_REG = "CSR"
%assign UART_Index = UARTRef-1
%assign UART_NAME = "FLEXCOM%<UART_Index>"
%break
%default
%error("Internal error with UART")
%endswitch
%return "( !((XDMAC_REGS->XDMAC_CHID[%<TX_DMA_CHANNEL>].XDMAC_CC & (XDMAC_CC_WRIP_Msk | XDMAC_CC_RDIP_Msk))  ||  ((%<UART_NAME>_REGS->%<REG_NAME>_%<INTERRUPT_STATUS_REG> & %<REG_NAME>_%<INTERRUPT_STATUS_REG>_%<REG_NAME2>TXRDY_Msk) == 0)) )"
%endfunction
%function Enable_Tx_DMA_interrupt(TX_DMA_CHANNEL,comment) Output	
XDMAC_REGS->XDMAC_GIE |= XDMAC_GIE_IE%<TX_DMA_CHANNEL>(1); /* %<comment> */
%endfunction
%function UART_Tx_SingleBuffer_RequestDMATransfert(TX_DMA_CHANNEL,UART_NAME,block) Output
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%assign nUSART = CAST("Number",block.RTWdata.nUSART)
%switch ::ChipIdL1
%case "SAME"
%case "SAMS"
%case "SAMV"
%if UARTRef > nUSART
%assign Per_Type = "UART"
%assign REG_NAME = "UART"
%assign REG_NAME2 = ""
%assign INTERRUPT_STATUS_REG = "SR"
%assign UART_Index = (UARTRef-1) - nUSART
%else
%assign Per_Type = "USART"
%assign REG_NAME = "US"
%assign REG_NAME2 = "USART_"
%assign INTERRUPT_STATUS_REG = "CSR"
%assign UART_Index = UARTRef-1
%endif
%assign UART_NAME = "%<Per_Type>%<UART_Index>"
%break
%case "SAMRH"
%assign Per_Type = "USART"
%assign REG_NAME = "FLEX_US"
%assign REG_NAME2 = ""
%assign INTERRUPT_STATUS_REG = "CSR"
%assign UART_Index = UARTRef-1
%assign UART_NAME = "FLEXCOM%<UART_Index>"
%break
%default
%error("Internal error with UART")
%endswitch
XDMAC_REGS->XDMAC_CHID[%<TX_DMA_CHANNEL>].XDMAC_CSA = (uint32_t)MCHP_%<UART_NAME>_Tx_buffer;   /* Set source address */
SCB_CleanDCache_by_Addr( (uint32_t*) ((uint32_t)MCHP_%<UART_NAME>_Tx_buffer & 0xFFFFFFE0)  ,Tx_BUFF_SIZE_%<UART_NAME>);
XDMAC_REGS->XDMAC_GE |= XDMAC_GE_EN%<TX_DMA_CHANNEL>_Msk;   /* Enable DMA channel%<TX_DMA_CHANNEL> and start data transfer */
%endfunction
%function UART_Tx_DMA_Send_SwitchBuffer(UART_NAME,TX_DMA_CHANNEL,ChipIdN,ChipIdL1) Output
uint32_t dma_status = XDMAC_REGS->XDMAC_CHID[%<TX_DMA_CHANNEL>].XDMAC_CIS;    /* Clear the DMA Channel interrupt flag */
NVIC_ClearPendingIRQ(XDMAC_IRQn); /* Clear XDMAC pending interrupt flag */
switch (MCHP_%<UART_NAME>_Tx.BufferAB){
case 0:
XDMAC_REGS->XDMAC_CHID[%<TX_DMA_CHANNEL>].XDMAC_CSA = (uint32_t)MCHP_%<UART_NAME>_Tx_bufferA;   /* Set source address */
MCHP_%<UART_NAME>_Tx.BufferAB = 1;
SCB_CleanDCache_by_Addr( (uint32_t*) ((uint32_t)MCHP_%<UART_NAME>_Tx_bufferA & 0xFFFFFFE0)  ,Tx_BUFF_SIZE_%<UART_NAME>);
break;
case 1:
XDMAC_REGS->XDMAC_CHID[%<TX_DMA_CHANNEL>].XDMAC_CSA = (uint32_t)MCHP_%<UART_NAME>_Tx_bufferB;   /* Set source address */
MCHP_%<UART_NAME>_Tx.BufferAB = 0;
SCB_CleanDCache_by_Addr( (uint32_t*) ((uint32_t)MCHP_%<UART_NAME>_Tx_bufferB & 0xFFFFFFE0)  ,Tx_BUFF_SIZE_%<UART_NAME>);
break;
}
XDMAC_REGS->XDMAC_GE |= XDMAC_GE_EN%<TX_DMA_CHANNEL>_Msk;   /* Enable DMA channel%<TX_DMA_CHANNEL> and start data transfer */
%endfunction
%function UART_Tx_FlushCirculerBuffer(UART_HALF_DUPLEX_MODE,block) Output
%assign TX_INT_PRIORITY = 3
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%assign nUSART = CAST("Number",block.RTWdata.nUSART)	
%switch ::ChipIdL1
%case "SAME"
%case "SAMS"
%case "SAMV"
%if UARTRef > nUSART
%assign Per_Type = "UART"
%assign REG_NAME = "UART"
%assign REG_NAME2 = ""
%assign INTERRUPT_STATUS_REG = "SR"
%assign UART_Index = (UARTRef-1) - nUSART
%else
%assign Per_Type = "USART"
%assign REG_NAME = "US"
%assign REG_NAME2 = "USART_"
%assign INTERRUPT_STATUS_REG = "CSR"
%assign UART_Index = UARTRef-1
%endif
%assign UART_NAME = "%<Per_Type>%<UART_Index>"
%break
%case "SAMRH"
%assign Per_Type = "USART"
%assign REG_NAME = "FLEX_US"
%assign REG_NAME2 = ""
%assign INTERRUPT_STATUS_REG = "CSR"
%assign UART_Index = UARTRef-1
%assign UART_NAME = "FLEXCOM%<UART_Index>"
%break
%default
%error("Internal error with UART")
%endswitch
%if UART_HALF_DUPLEX_MODE		
%<UART_NAME>_REGS->%<REG_NAME>_CR = (%<UART_NAME>_REGS->%<REG_NAME>_CR & (~%<REG_NAME>_CR_%<REG_NAME2>>TXEN_Msk)) | %<REG_NAME>_CR_%<REG_NAME2>>TXEN(1);      /* Enable TX */
%endif
%if (LibBlockSampleTime(block) == -1) || (TX_INT_PRIORITY >= 5)
if (%<UART_NAME>_REGS->%<REG_NAME>_%<INTERRUPT_STATUS_REG> & %<REG_NAME>_%<INTERRUPT_STATUS_REG>_%<REG_NAME2>TXRDY_Msk){
%<UART_NAME>_REGS->%<REG_NAME>_IER = %<REG_NAME>_IER_%<REG_NAME2>TXRDY_Msk;       /* Tx Buffer is empty, enable Interrupt */
}
%else
{						
uint_T LocalHead;
%<UART_NAME>_REGS->%<REG_NAME>_IDR = %<REG_NAME>_IDR_%<REG_NAME2>TXRDY_Msk;       /* Disable Tx Interrupt protecting against possible concurrent access */
%<ISB()>    
%<DSB()>
LocalHead = MCHP_%<UART_NAME>_Tx.head;	/* Head is a volatile variable. Use local variable to speed-up execution */					
while ( (%<UART_NAME>_REGS->%<REG_NAME>_%<INTERRUPT_STATUS_REG> & %<REG_NAME>_%<INTERRUPT_STATUS_REG>_%<REG_NAME2>TXRDY_Msk) && (MCHP_%<UART_NAME>_Tx.tail != LocalHead) ) /* while Tx buffer is not full */
{ 									
%<UART_NAME>_REGS->%<REG_NAME>_THR = (%<UART_NAME>_REGS->%<REG_NAME>_THR & (~%<REG_NAME>_THR_TXCHR_Msk)) | %<REG_NAME>_THR_TXCHR(MCHP_%<UART_NAME>_Tx.buffer[LocalHead]);
LocalHead = (LocalHead + 1) & (Tx_BUFF_SIZE_%<UART_NAME> - 1);
}
MCHP_%<UART_NAME>_Tx.head = LocalHead; /* Push back volatile variable */
%if UART_HALF_DUPLEX_MODE == 1		
%<UART_NAME>_REGS->%<REG_NAME>_IER = %<REG_NAME>_IER_%<REG_NAME2>TXRDY_Msk;       /* TXRDY Interrupt Enable */
%else								
if (MCHP_%<UART_NAME>_Tx.tail != LocalHead)		/* If remaining values to send present in the circular buffer */
{
%<UART_NAME>_REGS->%<REG_NAME>_IER = %<REG_NAME>_IER_%<REG_NAME2>TXRDY_Msk;       /* TXRDY Interrupt Enable */
}																			
%endif
}
%endif	
%endfunction