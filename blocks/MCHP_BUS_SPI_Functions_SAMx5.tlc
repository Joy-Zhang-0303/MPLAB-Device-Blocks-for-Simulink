
%function DataReadRegister(NB,SPIRef,MASTER) void
%assign MS = "S"	
%if MASTER
%assign MS = "M"			
%endif		
%return "SERCOM%<SPIRef>_REGS->SPI%<MS>.SERCOM_DATA"
%endfunction
%function DataWriteRegister(NB,SPIRef,MASTER) void
%assign MS = "S"	
%if MASTER
%assign MS = "M"			
%endif		
%return "SERCOM%<SPIRef>_REGS->SPI%<MS>.SERCOM_DATA"
%endfunction
%function WriteDataRegister(SPIRef,MASTER,NB,value) Output
%assign MS = "S"	
%if MASTER
%assign MS = "M"			
%endif		
%switch NB	
%case 8	
%<DataWriteRegister(NB,SPIRef,MASTER)> = %<value>;
%break
%case 16	
%<DataWriteRegister(NB,SPIRef,MASTER)> = __REVSH(%<value>); /* Write 16 bit value swap high and low bytes */
%break
%case 32	
%<DataWriteRegister(NB,SPIRef,MASTER)> = __REV(%<value>); /* Write 32 bit value swap high and low bytes */
%break
%endswitch
%endfunction
%function ReadDataRegister(SPIRef,MASTER,NB,writeTo) Output
%assign MS = "S"	
%if MASTER
%assign MS = "M"			
%endif		
%switch NB	
%case 8	
%<writeTo> = %<DataReadRegister(NB,SPIRef,MASTER)>;
%break
%case 16	
%<writeTo> = __REVSH(%<DataReadRegister(NB,SPIRef,MASTER)>); /* Read 16 bit value swap high and low bytes */
%break
%case 32	
%<writeTo> = __REV(%<DataReadRegister(NB,SPIRef,MASTER)>); /* Write 32 bit value swap high and low bytes */
%break
%endswitch
%endfunction
%function Declare_SPI_Interrupt(SPIRef,IntPriority,MASTER,UseUserInterrupt,block) Output
%if (::MCHP_modsrc_Name.SERCOM.x[SPIRef].nvect >= 2)
%assign INTERRUPT_Tx_name = ::MCHP_modsrc_Name.SERCOM.x[SPIRef].vector[1] 
%else
%assign INTERRUPT_Tx_name = ::MCHP_modsrc_Name.SERCOM.x[SPIRef].vector 
%endif
/* Interrupt SERCOM %<SPIRef> 1: when SPI Data Register is Empty */
void %<INTERRUPT_Tx_name>_Handler(void)
%endfunction
%function Declare_DMA_Interrupt(intRef,IntPriority,MASTER,UseUserInterrupt,block) Output
%error("Function SPI-DMA not implemented on SAMx5, SAMx2 chip")
%endfunction
%function SPI_InterruptsConfig(SPIRef,IntPriority) Output
%if (::MCHP_modsrc_Name.SERCOM.x[SPIRef].nvect >= 2)
%assign INTERRUPT_Tx_name = ::MCHP_modsrc_Name.SERCOM.x[SPIRef].vector[1] 
%else
%assign INTERRUPT_Tx_name = ::MCHP_modsrc_Name.SERCOM.x[SPIRef].vector 
%endif   	
/* Configure SPI%<SPIRef> Tx Interrupt */
NVIC_SetPriority(%<INTERRUPT_Tx_name>_IRQn,%<IntPriority>);		/* Set SPI%<SPIRef> Transmit Complete Interrupt Priority */
NVIC_EnableIRQ(%<INTERRUPT_Tx_name>_IRQn);    		/* Enable NVIC line for SPI%<SPIRef> TXC */			
%endfunction
%function Configure_DMA_Rx(DMA_Rx,SPIRef,SPIBUF,MASTER) Output
%error("Function SPI-DMA not implemented on SAMx5, SAMx2 chip")
%endfunction
%function Configure_DMA_Tx(DMA_Tx,SPIRef,SPIBUF,MASTER) Output
%error("Function SPI-DMA not implemented on SAMx5, SAMx2 chip")
%endfunction
%function SPI_DMA_Rx_InterruptsConfig(DMA_Rx,MASTER) Output
%error("Function SPI-DMA not implemented on SAMx5, SAMx2 chip")
%endfunction
%function EnableAndTrig_DMA_Interrupt(intRef,MASTER) Output
%error("Function SPI-DMA not implemented on SAMx5, SAMx2 chip")
%endfunction
%function Clear_DMA_Interrupt_Flag(intRef,MASTER) Output
%error("Function SPI-DMA not implemented on SAMx5, SAMx2 chip")
%endfunction
%function DisableInterrupt_DMA_Tx(DMA_Tx,MASTER) Output
%endfunction
%function DisableInterrupt_DMA_Rx(DMA_Rx,MASTER) Output
%endfunction
%function EnableAndTrig_Interrupt(SPIRef,MASTER) Output
%assign MS = "S"	
%if MASTER
%assign MS = "M"			
%endif	
%if (::MCHP_modsrc_Name.SERCOM.x[SPIRef].nvect >= 2)
%assign INTERRUPT_Tx_name = ::MCHP_modsrc_Name.SERCOM.x[SPIRef].vector[1] 
%else
%assign INTERRUPT_Tx_name = ::MCHP_modsrc_Name.SERCOM.x[SPIRef].vector 
%endif
NVIC_SetPendingIRQ(%<INTERRUPT_Tx_name>_IRQn);
SERCOM%<SPIRef>_REGS->SPI%<MS>.SERCOM_INTENSET = SERCOM_SPI%<MS>_INTENSET_TXC_Msk;    /* Enable SPI%<SPIRef> interrupt Transmit Complete */
%endfunction
%function DisableInterrupt(SPIRef,MASTER) Output
%assign MS = "S"	
%if MASTER
%assign MS = "M"			
%endif	
%endfunction
%function Clear_SPI_Interrupt_Flag(SPIRef,MASTER) Output
%assign MS = "S"	
%if MASTER
%assign MS = "M"			
%endif	
SERCOM%<SPIRef>_REGS->SPI%<MS>.SERCOM_INTFLAG = SERCOM_SPI%<MS>_INTFLAG_TXC_Msk;    /* Clear SPI%<SPIRef> Tx interrupt Flag */	
%endfunction
%function EnableSPI(SPIRef,MASTER) Output
%assign MS = "S"	
%if MASTER
%assign MS = "M"			
%endif		
SERCOM%<SPIRef>_REGS->SPI%<MS>.SERCOM_INTFLAG = 0xFF; /* Reset possible error flags */	
SERCOM%<SPIRef>_REGS->SPI%<MS>.SERCOM_CTRLA |= SERCOM_SPI%<MS>_CTRLA_ENABLE_Msk; /* Enable SPI */
%endfunction
%function DisableSPI(SPIRef,MASTER,cmt) Output
%assign MS = "S"	
%if MASTER
%assign MS = "M"			
%endif		
SERCOM%<SPIRef>_REGS->SPI%<MS>.SERCOM_CTRLA &=  ~SERCOM_SPI%<MS>_CTRLA_ENABLE_Msk; /* %<cmt> */		
%endfunction
%function SPIConfig(SPIRef,Exist_EnhancedSPIBuff,idx,SPISequence,useDMA,MASTER) Output
/* Set-up SPI %<SPIRef> peripheral with Fsck = %<SPISequence[idx+5]>  (%<SPISequence[idx+4]> with  %<SPISequence[idx+5]/(0.01*SPISequence[idx+4]) - 100> % error)  */
/* ========================= SERCOM SPI %<SPIRef> Peripheral setup ========================= */	
{
uint32_T tmp_reg;
%assign AchievedBaud = SPISequence[idx+5]
%assign GCLK_ref = CAST("Number",SPISequence[idx+7])
%assign GCLK_val = CAST("Number",SPISequence[idx+8])
%assign MS = "S"	
%if MASTER
%assign MS = "M"			
%endif		
/* SERCOM%<SPIRef> (SPI%<MS>)  APB clock */		
%<Enable_Peripheral_Clock("SERCOM%<SPIRef>")>		
/* with GCLK%<GCLK_ref>=%<GCLK_val>, Fsck = GCLK%<GCLK_ref>/(BAUD + 1) */
%assign BAUDREG = SPISequence[idx+6]		
SERCOM%<SPIRef>_REGS->SPI%<MS>.SERCOM_BAUD = %<CAST("Number",BAUDREG)>; /* Set BaudRate Fsck = %<SPISequence[idx+5]>*/
%assign tmp = CAST("Number",SPISequence[idx+1])	
%assign SPI_Enabled = 1 & (tmp >> 15)	
%assign SPI_Mode = 3 & (tmp >> 13)	
%assign SPI_DisableSDO = 1 & (tmp >> 12)	
%assign SPI_Mode16 = 3 & (tmp >> 10)	
%assign SPI_SamplePhase = 1 & (tmp >> 9)
%assign SPI_SSEnable = 1 & (tmp >> 7)
%assign SPI_Master = 1 & (tmp >> 5)
%assign SPI_PIN_SDO_PAD = 3 & (tmp >> 2)
%assign SPI_PIN_SDI_PAD = 3 & tmp
/* SPI CTRL B */
tmp_reg = SERCOM_SPI%<MS>_CTRLB_RXEN_Msk; /* Enable SPI RX*/
%if MASTER == 1
%else				
tmp_reg |= SERCOM_SPI%<MS>_CTRLB_SSDE_Msk; /*  Slave Select Low Detect Enable  */
%endif
SERCOM%<SPIRef>_REGS->SPI%<MS>.SERCOM_CTRLB = tmp_reg; /* SPI%<SPIRef> CTRLB */
%if ISEQUAL(::MCHP_modsrc_Name.SERCOM.version,"5.0.0")
/* SPI CTRL C */	
SERCOM%<SPIRef>_REGS->SPI%<MS>.SERCOM_CTRLC = SERCOM_SPI%<MS>_CTRLC_DATA32B_Msk; /* 32 bit */
%switch SPI_Mode16
%case 0
SERCOM%<SPIRef>_REGS->SPI%<MS>.SERCOM_LENGTH = 1 + 0x100; /* 8 bit length */
%break
%case 1
SERCOM%<SPIRef>_REGS->SPI%<MS>.SERCOM_LENGTH = 2 + 0x100; /* 16 bit length */
%break
%case 2
SERCOM%<SPIRef>_REGS->SPI%<MS>.SERCOM_LENGTH = 4 + 0x100; /* 32 bit length */
%break
%endswitch
%endif
while ((SERCOM%<SPIRef>_REGS->SPI%<MS>.SERCOM_SYNCBUSY) != 0); /* SYNCBUSY */ 	
/* SPI CTRL A */
%if MASTER				
tmp_reg = SERCOM_SPI%<MS>_CTRLA_MODE(3);	/* SERCOM%<SPIRef> is SPI Master */
%else				
tmp_reg = SERCOM_SPI%<MS>_CTRLA_MODE(2);	/* SERCOM%<SPIRef> is SPI Slave */
%endif			
%switch SPI_Mode
%case 0
tmp_reg |= SERCOM_SPI%<MS>_CTRLA_CPOL(0);	/* Clock Polarity */				
tmp_reg |= SERCOM_SPI%<MS>_CTRLA_CPHA(0);	/* Clock Phase (Mode %<SPI_Mode>) */									
%break
%case 1
tmp_reg |= SERCOM_SPI%<MS>_CTRLA_CPOL(0);	/* Clock Polarity */				
tmp_reg |= SERCOM_SPI%<MS>_CTRLA_CPHA(1);	/* Clock Phase (Mode %<SPI_Mode>) */									
%break					
%case 2
tmp_reg |= SERCOM_SPI%<MS>_CTRLA_CPOL(1);	/* Clock Polarity */				
tmp_reg |= SERCOM_SPI%<MS>_CTRLA_CPHA(0);	/* Clock Phase (Mode %<SPI_Mode>) */									
%break
%case 3
tmp_reg |= SERCOM_SPI%<MS>_CTRLA_CPOL(1);	/* Clock Polarity */				
tmp_reg |= SERCOM_SPI%<MS>_CTRLA_CPHA(1);	/* Clock Phase (Mode %<SPI_Mode>) */									
%break
%endswitch
tmp_reg |= SERCOM_SPI%<MS>_CTRLA_DIPO_PAD%<SPI_PIN_SDI_PAD>; /* Data In PAD Pinout */
tmp_reg |= SERCOM_SPI%<MS>_CTRLA_DOPO_PAD%<SPI_PIN_SDO_PAD>; /* Data Out, SCK and SS PAD Pinout */
tmp_reg |= SERCOM_SPI%<MS>_CTRLA_RUNSTDBY_Msk; /* Run in Standby */			
tmp_reg |= SERCOM_SPI%<MS>_CTRLA_ENABLE_Msk; /* Enable */
SERCOM%<SPIRef>_REGS->SPI%<MS>.SERCOM_CTRLA = tmp_reg; /* SPI%<SPIRef> CTRLA & Enable */
while ((SERCOM%<SPIRef>_REGS->SPI%<MS>.SERCOM_SYNCBUSY) != 0); /* SYNCBUSY */ 			
}
%endfunction
