%function MCHP_taskCheckOverrun_Exit(taskID) void
%openfile taskCheck
if (taskCounter.Task%<taskID> == 0) { 		/* no task execution dropped: overrun on lower rate task will slow down higher rate task. Keep task Synchronisation */
%assign SampleTimePeriod = LibGetSampleTimePeriodAndOffset(taskID,0)
%assign SampleTimePeriod_ticks = FcnComputeTaskTickLimit(taskID)	
%if SampleTimePeriod_ticks <= 65535
taskCounter.Task%<taskID> = (uint_T) %<SampleTimePeriod_ticks>;	/* %<SampleTimePeriod>s periodic task. Max value is %<CAST("Number",SampleTimePeriod_ticks)> */ 
%else
taskCounter.Task%<taskID> = (uint32_T) %<SampleTimePeriod_ticks>; /* %<SampleTimePeriod>s periodic task. Max value is %<CAST("Number",SampleTimePeriod_ticks)> */ 
%endif	
if (Overrun.Flags%<taskID>) {
%if (%<::MASTER_BusyFlag> != -1)
%<Mchp_asm_Adec("BusyFlagRecursion")> 
%endif
%<MCHP_ProfileMCU("exit")>
%<MCHP_MCUOverload(taskID)>
return;
}
event.Flags%<taskID> = 1U;
}
%closefile taskCheck
%return taskCheck
%endfunction
%function MCHP_taskCheckOverrun_Continue(taskID) void
%openfile taskCheck
%openfile overload
%<MCHP_MCUOverload(taskID)>
%closefile overload
if (taskCounter.Task%<taskID> == 0) {  /* task dropped on overload */	
%assign SampleTimePeriod = LibGetSampleTimePeriodAndOffset(taskID,0)
%assign SampleTimePeriod_ticks = FcnComputeTaskTickLimit(taskID)	
%if SampleTimePeriod_ticks <= 65535
taskCounter.Task%<taskID> = (uint_T) %<SampleTimePeriod_ticks>;	/* %<SampleTimePeriod>s periodic task. Max value is %<CAST("Number",SampleTimePeriod_ticks)> */ 
%else
taskCounter.Task%<taskID> = (uint32_T) %<SampleTimePeriod_ticks>; /* %<SampleTimePeriod>s periodic task. Max value is %<CAST("Number",SampleTimePeriod_ticks)> */ 
%endif	       	
event.Flags%<taskID> = 1U;	/* Flag tag to be executed */
%if !WHITE_SPACE(overload)
if (Overrun.Flags%<taskID>)
{
%<overload>
}
%endif
}
%closefile taskCheck
%return taskCheck
%endfunction
%function MCHP_mrScheduler(InterruptPrefix,InterruptNumber,ChipIdN) void
%openfile mrScheduler
%assign ::MASTER_BusyFlag = CAST("Number",RTWGenSettings.MASTER_BusyFlag)
%assign MASTER_BusyFlagPin = CAST("Number",%<::MASTER_BusyFlag % 16>)
%assign MASTER_BusyFlagLetter = STRINGOF([%<::MASTER_BusyFlag / 16 + 65>])
%assign MCHP_NEAR_MEM = Mchp_NEAR_MEM()
%assign tid01Eq = LibGetTID01EQ()
{
%if (MASTER_BusyFlag != -1)
extern volatile uint_T BusyFlagRecursion %<MCHP_NEAR_MEM>;		
%endif
%if (LibNumSynchronousSampleTimes()-1) > 0
struct {
%foreach i = (LibNumSynchronousSampleTimes()-1)			
unsigned int Flags%<i+1> : 1;
%endforeach
} static volatile Overrun %<Mchp_NEAR_MEM()>;
%endif
%if (LibNumSynchronousSampleTimes()-1) > 0
struct {
%foreach i = (LibNumSynchronousSampleTimes()-1)				
unsigned int Flags%<i+1> : 1;
%endforeach
} static volatile event %<Mchp_NEAR_MEM()>;
%endif
%if SuppressMultiTaskScheduler
%if (LibNumSynchronousSampleTimes()-1) > 0	
struct {
%foreach iTID = (LibNumSynchronousSampleTimes()-1)				
%assign SampleTimePeriod = LibGetSampleTimePeriodAndOffset(iTID+1,0)
%assign SampleTimePeriod_ticks = FcnComputeTaskTickLimit(iTID+1)	
%if SampleTimePeriod_ticks > 4294967295.0
%error("Ratio between the slowest period task and the bare model rate is higher than 4294967295 and do not fit in a 32 bit integer. Slowest rate possible is: %<4294967295 * LibGetSampleTimePeriodAndOffset(0,0)>s")
%endif
%if SampleTimePeriod_ticks <= 65535
uint_T Task%<iTID+1>;	/* %<SampleTimePeriod>s periodic task. Max value is %<CAST("Number",SampleTimePeriod_ticks)> */ 
%else
uint32_T Task%<iTID+1>;	/* %<SampleTimePeriod>s periodic task. Max value is %<CAST("Number",SampleTimePeriod_ticks)> (ensure 32 bit) */
%endif
%endforeach
} static volatile taskCounter %<Mchp_NEAR_MEM()> = {
%assign comma = ""
%foreach iTID = (LibNumSynchronousSampleTimes()-1)  	
%assign SampleTimePeriod_ticks = FcnComputeTaskTickLimit(iTID+1)
%assign OffsetForDecrementing = %<SampleTimePeriod_ticks - FcnComputeTaskTickOffset(iTID+1) +1> 
%if OffsetForDecrementing > SampleTimePeriod_ticks	
%assign OffsetForDecrementing = OffsetForDecrementing - SampleTimePeriod_ticks	
%endif
%<comma> .Task%<iTID+1> = %<OffsetForDecrementing> /* Offset is %<FcnComputeTaskTickOffset(iTID+1)> (-%<SampleTimePeriod_ticks> + 1 modulo [%<SampleTimePeriod_ticks> for pre decrement) */
%assign comma = ","
%endforeach		 		
};	    			 	
%endif
%endif
%<MCHP_RemoveCauseOfInterrupt(InterruptPrefix,InterruptNumber,ChipIdN)>
%<MCHP_SFR(  "%<InterruptPrefix>%<InterruptNumber>IF"  , 0 				   , "Re-enable interrupt" )> 
%if ::isPIC32
%endif
%if (%<::MASTER_BusyFlag> != -1)
/* Set busy flag */
%<Mchp_asm_Ainc("BusyFlagRecursion")> 
%<MCHP_SetOutputBit(MASTER_BusyFlag,1,"Set Busy Flag PIN")>			
%endif
%<MCHP_GetModelInput(0)>
/* Check subrate overrun, set rates that need to run this time step*/
%foreach i = NumSynchronousSampleTimes-1			
taskCounter.Task%<i+1>--;	/* Decrement task internal counter */
%switch MCHP_SchedulerTaskOverload
%case "Queue"
%case "Skip"
%<MCHP_taskCheckOverrun_Continue(i+1)>
%break
%case "Delay"
%<MCHP_taskCheckOverrun_Exit(i+1)>
%break
%default
%error Scheduler Option %<MCHP_SchedulerTaskOverload> not recognized.
%endswitch
%endforeach
%if ExtMode
if (0==(%<ERTStopCheck()>)) {
rtExtModeShutdown(%<NumSynchronousSampleTimes>);
}
%endif
%<::MCHP_TimeStep_BeforeExecution>
/* ---------- Handle model base rate Task 0 ---------- */
%<MCHP_ProfileTaskStart(0)>
%<MCHP_ProfileMCU_Compute(0)>
%<LibCallModelStep(0)>
%switch MCHP_SchedulerTaskOverload
%case "Skip"
%<MCHP_ProfileTaskStop(0)>
if ( %< MCHP_SFR_direct("%<InterruptPrefix>%<InterruptNumber>IF") > ){
%<MCHP_MCUOverload(0)>
%<MCHP_RemoveCauseOfInterrupt(InterruptPrefix,InterruptNumber,ChipIdN)>
%<MCHP_SFR(  "%<InterruptPrefix>%<InterruptNumber>IF"  , 0 				   , "Skip next task0 when Overloaded" )> 
}
%break
%case "Queue"
%case "Delay"
%<MCHP_ProfileTaskStop(0)>
if ( %< MCHP_SFR_direct("%<InterruptPrefix>%<InterruptNumber>IF") > ){
%if (%<::MASTER_BusyFlag> != -1)
%<Mchp_asm_Adec("BusyFlagRecursion")> 
%endif
%<MCHP_ProfileMCU("exit")>
%<MCHP_MCUOverload(0)>
return; /* Will re-enter into the interrupt */ 
}
%break
%default
%error Scheduler Option %<MCHP_SchedulerTaskOverload> not recognized.
%endswitch
/* Re-Enable Interrupt. IPL value is 2 at this point */
%<Mchp_asm_EnableSchedulerInterrupt()>
/* Step the model for any subrate */
%foreach i = %<LibNumSynchronousSampleTimes()-1>			
/* ---------- Handle Task %<i+1> ---------- */		
%<MCHP_taskExecute(i+1,0)>
%endforeach
/* Disable Interrupt. IPL value is 1 at this point */
%<Mchp_asm_DisableSchedulerInterrupt()>
%if (%<::MASTER_BusyFlag> != -1)
/* Release busy flag */
%<Mchp_asm_Adec("BusyFlagRecursion")> 
if (BusyFlagRecursion == 0)
%<MCHP_SetOutputBit(MASTER_BusyFlag,0,"Release Busy Flag PIN")>	
%endif
}
%closefile mrScheduler
%return mrScheduler
%endfunction
%function MCHP_Scheduler_EXIT() Output
return;
%endfunction