%include "MCHP_Functions.tlc"
%function MchpStartup(ConfigChipOnly) void
%openfile tmpFcnOsc
%assign MIPS = CAST("Real",RTWGenSettings.MIPS)    
%assign MIPS_DESIRED = CAST("Real",RTWGenSettings.MIPS_DESIRED)    
%assign QUARTZ = CAST("Real",RTWGenSettings.QUARTZ)
%assign MCLK_CPUDIV = CAST("Number",RTWGenSettings.MCLK_CPUDIV) 
%assign MCLK_BUPDIV = CAST("Number",RTWGenSettings.MCLK_BUPDIV) 
%assign MCLK_HSDIV = CAST("Number",RTWGenSettings.MCLK_HSDIV) 
%assign CPU_SRC = CAST("Number",RTWGenSettings.CPU_SRC) 
%assign NVM_WAIT_STATE = CAST("Number",RTWGenSettings.NVM_WAIT_STATE) 
%assign OSCULP32K_CONFIG = CAST("Number",RTWGenSettings.OSCULP32K_CONFIG) 
%assign OSCULP32K_CALIB_ENABLE = CAST("Number",RTWGenSettings.OSCULP32K_CALIB_ENABLE) 
%assign OSCULP32K_CALIB = CAST("Number",RTWGenSettings.OSCULP32K_CALIB) 
%assign DPLL1_CONFIG = CAST("Number",RTWGenSettings.DPLL1_CONFIG) 
%assign DPLL1_INFO_Fin  = CAST("Number",RTWGenSettings.DPLL1_INFO_Fin)
%assign DPLL1_INFO_PLLout  = CAST("Number",RTWGenSettings.DPLL1_INFO_PLLout)
%assign DPLL1_GCLK = CAST("Number",RTWGenSettings.DPLL1_GCLK) 
%assign DPLL1_ENABLE = CAST("Number",RTWGenSettings.DPLL1_ENABLE) 
%assign DPLL1_ONDEMAND = CAST("Number",RTWGenSettings.DPLL1_ONDEMAND) 
%assign DPLL1_RUNSTDBY = CAST("Number",RTWGenSettings.DPLL1_RUNSTDBY) 
%assign DPLL1_LDRFRAC = CAST("Number",RTWGenSettings.DPLL1_LDRFRAC) 
%assign DPLL1_LDR = CAST("Number",RTWGenSettings.DPLL1_LDR) 
%assign DPLL1_DIV = CAST("Number",RTWGenSettings.DPLL1_DIV) 
%assign DPLL1_DCOEN = CAST("Number",RTWGenSettings.DPLL1_DCOEN) 
%assign DPLL1_DCOFILTER = CAST("Number",RTWGenSettings.DPLL1_DCOFILTER) 
%assign DPLL1_LBYPASS = CAST("Number",RTWGenSettings.DPLL1_LBYPASS) 
%assign DPLL1_LTIME = CAST("Number",RTWGenSettings.DPLL1_LTIME) 
%assign DPLL1_REFCLK = CAST("Number",RTWGenSettings.DPLL1_REFCLK) 
%assign DPLL1_WUF = CAST("Number",RTWGenSettings.DPLL1_WUF) 
%assign DPLL1_FILTER = CAST("Number",RTWGenSettings.DPLL1_FILTER) 
/* ------------- Configure Oscillator -------------------------- */
/* Targetted frequency is %<MIPS_DESIRED> */
%if MIPS != MIPS_DESIRED
/* Reached frequency: %<MIPS> */
%endif
%assign DFLL_CONFIG = CAST("Number",RTWGenSettings.DFLL_CONFIG) 
%assign DFLL_GCLK = CAST("Number",RTWGenSettings.DFLL_GCLK) 
%assign DFLL_ENABLE = CAST("Number",RTWGenSettings.DFLL_ENABLE) 
%assign DFLL_ONDEMAND = CAST("Number",RTWGenSettings.DFLL_ONDEMAND) 
%assign DFLL_RUNSTDBY = CAST("Number",RTWGenSettings.DFLL_RUNSTDBY) 
%assign DFLL_USBCRM = CAST("Number",RTWGenSettings.DFLL_USBCRM) 
%assign DFLL_WAITLOCK = CAST("Number",RTWGenSettings.DFLL_WAITLOCK) 
%assign DFLL_BPLCKC = CAST("Number",RTWGenSettings.DFLL_BPLCKC) 
%assign DFLL_QLDIS = CAST("Number",RTWGenSettings.DFLL_QLDIS) 
%assign DFLL_CCDIS = CAST("Number",RTWGenSettings.DFLL_CCDIS) 
%assign DFLL_LLAW = CAST("Number",RTWGenSettings.DFLL_LLAW) 
%assign DFLL_STABLE = CAST("Number",RTWGenSettings.DFLL_STABLE) 
%assign DFLL_MODE = CAST("Number",RTWGenSettings.DFLL_MODE) 
%assign DFLL_CSTEP = CAST("Number",RTWGenSettings.DFLL_CSTEP) 
%assign DFLL_FSTEP = CAST("Number",RTWGenSettings.DFLL_FSTEP) 
%assign DFLL_MUL = CAST("Number",RTWGenSettings.DFLL_MUL) 
%assign DFLL_OVERWRITE_CALIBRATION = CAST("Number",RTWGenSettings.DFLL_OVERWRITE_CALIBRATION) 
%assign DFLL_COARSE = CAST("Number",RTWGenSettings.DFLL_COARSE) 
%assign DFLL_FINE = CAST("Number",RTWGenSettings.DFLL_FINE) 
%if DFLL_CONFIG
/* DFLL48Mhz initialized by default on startup */
%if 0
#if CONF_DFLL_CONFIG == 1
hri_gclk_write_GENCTRL_SRC_bf(GCLK, 0, GCLK_GENCTRL_SRC_OSCULP32K);
while (hri_gclk_get_SYNCBUSY_GENCTRL0_bit(GCLK))
;
uint8_t tmp_REG;
hri_oscctrl_write_DFLLCTRLA_reg(hw, 0);
#if CONF_DFLL_USBCRM != 1 && CONF_DFLL_MODE != 0
hri_gclk_write_PCHCTRL_reg(
GCLK, OSCCTRL_GCLK_ID_DFLL48, (1 << GCLK_PCHCTRL_CHEN_Pos) | GCLK_PCHCTRL_GEN(CONF_DFLL_GCLK));
#endif
hri_oscctrl_write_DFLLMUL_reg(hw,
OSCCTRL_DFLLMUL_CSTEP(CONF_DFLL_CSTEP) | OSCCTRL_DFLLMUL_FSTEP(CONF_DFLL_FSTEP)
| OSCCTRL_DFLLMUL_MUL(CONF_DFLL_MUL));
while (hri_oscctrl_get_DFLLSYNC_DFLLMUL_bit(hw))
;
hri_oscctrl_write_DFLLCTRLB_reg(hw, 0);
while (hri_oscctrl_get_DFLLSYNC_DFLLCTRLB_bit(hw))
;
tmp_REG = (CONF_DFLL_RUNSTDBY << OSCCTRL_DFLLCTRLA_RUNSTDBY_Pos) | OSCCTRL_DFLLCTRLA_ENABLE;
hri_oscctrl_write_DFLLCTRLA_reg(hw, tmp_REG);
while (hri_oscctrl_get_DFLLSYNC_ENABLE_bit(hw))
;
#if CONF_DFLL_OVERWRITE_CALIBRATION == 1
hri_oscctrl_write_DFLLVAL_reg(hw, OSCCTRL_DFLLVAL_COARSE(CONF_DFLL_COARSE) | OSCCTRL_DFLLVAL_FINE(CONF_DFLL_FINE));
#endif
hri_oscctrl_write_DFLLVAL_reg(hw, hri_oscctrl_read_DFLLVAL_reg(hw));
while (hri_oscctrl_get_DFLLSYNC_DFLLVAL_bit(hw))
;
tmp_REG = (CONF_DFLL_WAITLOCK << OSCCTRL_DFLLCTRLB_WAITLOCK_Pos) | (CONF_DFLL_BPLCKC << OSCCTRL_DFLLCTRLB_BPLCKC_Pos)
| (CONF_DFLL_QLDIS << OSCCTRL_DFLLCTRLB_QLDIS_Pos) | (CONF_DFLL_CCDIS << OSCCTRL_DFLLCTRLB_CCDIS_Pos)
| (CONF_DFLL_USBCRM << OSCCTRL_DFLLCTRLB_USBCRM_Pos) | (CONF_DFLL_LLAW << OSCCTRL_DFLLCTRLB_LLAW_Pos)
| (CONF_DFLL_STABLE << OSCCTRL_DFLLCTRLB_STABLE_Pos) | (CONF_DFLL_MODE << OSCCTRL_DFLLCTRLB_MODE_Pos) | 0;
hri_oscctrl_write_DFLLCTRLB_reg(hw, tmp_REG);
while (hri_oscctrl_get_DFLLSYNC_DFLLCTRLB_bit(hw))
;
#endif
%endif
%endif
%assign XOSC32K_CONFIG = CAST("Number",RTWGenSettings.XOSC32K_CONFIG) 
%assign XOSC32K_ENABLE = CAST("Number",RTWGenSettings.XOSC32K_ENABLE) 
%assign XOSC32K_STARTUP = CAST("Number",RTWGenSettings.XOSC32K_STARTUP) 
%assign XOSC32K_ONDEMAND = CAST("Number",RTWGenSettings.XOSC32K_ONDEMAND) 
%assign XOSC32K_RUNSTDBY = CAST("Number",RTWGenSettings.XOSC32K_RUNSTDBY) 
%assign XOSC32K_EN1K = CAST("Number",RTWGenSettings.XOSC32K_EN1K) 
%assign XOSC32K_EN32K = CAST("Number",RTWGenSettings.XOSC32K_EN32K) 
%assign XOSC32K_SWBEN = CAST("Number",RTWGenSettings.XOSC32K_SWBEN) 
%assign XOSC32K_CFDEN = CAST("Number",RTWGenSettings.XOSC32K_CFDEN) 
%assign XOSC32K_CFDEO = CAST("Number",RTWGenSettings.XOSC32K_CFDEO) 
%assign XOSC32K_XTALEN = CAST("Number",RTWGenSettings.XOSC32K_XTALEN) 
%assign XOSC32K_CGM = CAST("Number",RTWGenSettings.XOSC32K_CGM) 
{
uint_T tmp_REG; /* Temp Configuration register */
%if XOSC32K_CONFIG
/* ---- Configure 32Khz Oscillator source ---- */
tmp_REG = OSC32KCTRL_XOSC32K_ENABLE(%<XOSC32K_ENABLE>); /* Enable */
%if XOSC32K_XTALEN
tmp_REG |= OSC32KCTRL_XOSC32K_XTALEN_Msk; /* Use external 32.768kHz Oscillator */ 	
%endif
%if XOSC32K_ONDEMAND
tmp_REG |= OSC32KCTRL_XOSC32K_ONDEMAND_Msk; /* Run on demand */
%endif	
%if XOSC32K_RUNSTDBY
tmp_REG |= OSC32KCTRL_XOSC32K_RUNSTDBY_Msk; /* Run in standby mode */
%endif	
%if XOSC32K_EN1K
tmp_REG |= OSC32KCTRL_XOSC32K_EN1K_Msk; /* enable 1kHz */
%endif	
%if XOSC32K_EN32K
tmp_REG |= OSC32KCTRL_XOSC32K_EN32K_Msk; /* Enable 32kHz */
%endif	
%if XOSC32K_SWBEN
tmp_REG |= OSC32KCTRL_XOSC32K_SWBEN_Msk; /* Clock switch back enabled */
%endif	
%if XOSC32K_CFDEN
tmp_REG |= OSC32KCTRL_XOSC32K_CFDEN_Msk; /* Clock Failure Detector */
%endif	
%if XOSC32K_CFDEO
tmp_REG |= OSC32KCTRL_XOSC32K_CFDEO_Msk; /* Clock Failure Detector event out */
%endif	
%if XOSC32K_STARTUP
tmp_REG |= OSC32KCTRL_XOSC32K_STARTUP(%<XOSC32K_STARTUP>); /* Startup value pow of 2 * 62.6ms (62.6ms * %<1 << XOSC32K_STARTUP>ms */			
%endif
%if XOSC32K_CGM
tmp_REG |= OSC32KCTRL_XOSC32K_CGM(%<XOSC32K_CGM>); /* Normal (1-XT) mode or High Spoeed (HS-2)  */
%endif
OSC32KCTRL_REGS->OSC32KCTRL_XOSC32K = tmp_REG; /* Write config */
while(!((OSC32KCTRL_REGS->OSC32KCTRL_STATUS & OSC32KCTRL_STATUS_XOSC32KRDY_Msk) == OSC32KCTRL_STATUS_XOSC32KRDY_Msk)) ; /* Wait for stabilisation */
%endif
%assign XOSC0_CONFIG = CAST("Number",RTWGenSettings.XOSC0_CONFIG) 
%assign XOSC0_FREQUENCY = CAST("Real",RTWGenSettings.XOSC0_FREQUENCY) 
%assign XOSC0_ENABLE = CAST("Number",RTWGenSettings.XOSC0_ENABLE) 
%assign XOSC0_STARTUP = CAST("Number",RTWGenSettings.XOSC0_STARTUP) 
%assign XOSC0_SWBEN = CAST("Number",RTWGenSettings.XOSC0_SWBEN) 
%assign XOSC0_CFDEN = CAST("Number",RTWGenSettings.XOSC0_CFDEN) 
%assign XOSC0_ENALC = CAST("Number",RTWGenSettings.XOSC0_ENALC) 
%assign XOSC0_LOWBUFGAIN = CAST("Number",RTWGenSettings.XOSC0_LOWBUFGAIN) 
%assign XOSC0_ONDEMAND = CAST("Number",RTWGenSettings.XOSC0_ONDEMAND) 
%assign XOSC0_RUNSTDBY = CAST("Number",RTWGenSettings.XOSC0_RUNSTDBY) 
%assign XOSC0_XTALEN = CAST("Number",RTWGenSettings.XOSC0_XTALEN) 
%assign XOSC0_IPTAT = CAST("Number",RTWGenSettings.XOSC0_IPTAT) 
%assign XOSC0_IMULT = CAST("Number",RTWGenSettings.XOSC0_IMULT) 
%assign XOSC0_CFDPRESC = CAST("Number",RTWGenSettings.XOSC0_CFDPRESC) 
%if XOSC0_CONFIG
%if XOSC0_XTALEN
/* ---- Configure XOSC0 Crystal Oscillator source (%<XOSC0_FREQUENCY>Hz) on X0IN X0OUT---- */
%else
/* ---- Configure XOSC0 Clock source (%<XOSC0_FREQUENCY>Hz) on X0IN ---- */
%endif
tmp_REG = OSCCTRL_XOSCCTRL_ENABLE(%<XOSC0_ENABLE>); 	/* Enable */
%if XOSC0_STARTUP > 0
tmp_REG |= OSCCTRL_XOSCCTRL_STARTUP(%<XOSC0_STARTUP>); /* [31ms, 61, 122 ... 1s] from 0 to 16 */
%endif
%if XOSC0_SWBEN > 0
tmp_REG |= OSCCTRL_XOSCCTRL_SWBEN_Msk; /* Clock Switch back enabled or not */
%endif
%if XOSC0_CFDEN > 0
tmp_REG |= OSCCTRL_XOSCCTRL_CFDEN_Msk; /* clock failure detector enabled  */
%endif
%if XOSC0_ENALC > 0
tmp_REG |= OSCCTRL_XOSCCTRL_ENALC_Msk; /* Automatic loop control */
%endif
%if XOSC0_LOWBUFGAIN > 0
tmp_REG |= OSCCTRL_XOSCCTRL_LOWBUFGAIN_Msk; /* Low Buffer Gain is enabled or not (value 1 mulitply by a factor 2 the amplitude) */
%endif
%if XOSC0_ONDEMAND > 0
tmp_REG |= OSCCTRL_XOSCCTRL_ONDEMAND_Msk; /* on demand  enabled */
%endif
%if XOSC0_RUNSTDBY > 0
tmp_REG |= OSCCTRL_XOSCCTRL_RUNSTDBY_Msk; /* run in standby mode */
%endif
%if XOSC0_XTALEN > 0
tmp_REG |= OSCCTRL_XOSCCTRL_XTALEN_Msk; /* Crystal connected to XIN/XOUT */
%endif
%if XOSC0_IPTAT > 0
tmp_REG |= OSCCTRL_XOSCCTRL_IPTAT(%<XOSC0_IPTAT>); /* always 3, except for frequency lower than 8Mhz? */
%endif
%if XOSC0_IMULT > 0
tmp_REG |= OSCCTRL_XOSCCTRL_IMULT(%<XOSC0_IMULT>); /* adjust current, see table */
%endif
%if XOSC0_CFDPRESC > 0
tmp_REG |= OSCCTRL_XOSCCTRL_CFDPRESC(%<XOSC0_CFDPRESC>); /* Clock failure detector prescaler */
%endif
OSCCTRL_REGS->OSCCTRL_XOSCCTRL[0] = tmp_REG; /* Write config XOSCCTRL0 */
while ((OSCCTRL_REGS->OSCCTRL_STATUS & OSCCTRL_STATUS_XOSCRDY0_Msk) != OSCCTRL_STATUS_XOSCRDY0_Msk ); /* Wait for Oscillator ready bit */	
%endif
%assign XOSC1_CONFIG = CAST("Number",RTWGenSettings.XOSC1_CONFIG) 
%assign XOSC1_FREQUENCY = CAST("Number",RTWGenSettings.XOSC1_FREQUENCY) 
%assign XOSC1_ENABLE = CAST("Number",RTWGenSettings.XOSC1_ENABLE) 
%assign XOSC1_STARTUP = CAST("Number",RTWGenSettings.XOSC1_STARTUP) 
%assign XOSC1_SWBEN = CAST("Number",RTWGenSettings.XOSC1_SWBEN) 
%assign XOSC1_CFDEN = CAST("Number",RTWGenSettings.XOSC1_CFDEN) 
%assign XOSC1_ENALC = CAST("Number",RTWGenSettings.XOSC1_ENALC) 
%assign XOSC1_LOWBUFGAIN = CAST("Number",RTWGenSettings.XOSC1_LOWBUFGAIN) 
%assign XOSC1_ONDEMAND = CAST("Number",RTWGenSettings.XOSC1_ONDEMAND) 
%assign XOSC1_RUNSTDBY = CAST("Number",RTWGenSettings.XOSC1_RUNSTDBY) 
%assign XOSC1_XTALEN = CAST("Number",RTWGenSettings.XOSC1_XTALEN) 
%assign XOSC1_IPTAT = CAST("Number",RTWGenSettings.XOSC1_IPTAT) 
%assign XOSC1_IMULT = CAST("Number",RTWGenSettings.XOSC1_IMULT) 
%assign XOSC1_CFDPRESC = CAST("Number",RTWGenSettings.XOSC1_CFDPRESC) 
%if XOSC1_CONFIG
%if XOSC1_XTALEN
/* ---- Configure XOSC1 Crystal Oscillator source (%<XOSC1_FREQUENCY>Hz) on X1IN X1OUT---- */
%else
/* ---- Configure XOSC1 Clock source (%<XOSC1_FREQUENCY>Hz) on X1IN ---- */
%endif
tmp_REG = OSCCTRL_XOSCCTRL_ENABLE(%<XOSC1_ENABLE>); 	/* Enable */
%if XOSC1_STARTUP > 0
tmp_REG |= OSCCTRL_XOSCCTRL_STARTUP(%<XOSC1_STARTUP>); /* [31ms, 61, 122 ... 1s] from 0 to 16 */
%endif
%if XOSC1_SWBEN > 0
tmp_REG |= OSCCTRL_XOSCCTRL_SWBEN_Msk; /* Clock Switch back enabled or not */
%endif
%if XOSC1_CFDEN > 0
tmp_REG |= OSCCTRL_XOSCCTRL_CFDEN_Msk; /* clock failure detector enabled  */
%endif
%if XOSC1_ENALC > 0
tmp_REG |= OSCCTRL_XOSCCTRL_ENALC_Msk; /* Automatic loop control */
%endif
%if XOSC1_LOWBUFGAIN > 0
tmp_REG |= OSCCTRL_XOSCCTRL_LOWBUFGAIN_Msk; /* Low Buffer Gain is enabled or not (value 1 mulitply by a factor 2 the amplitude) */
%endif
%if XOSC1_ONDEMAND > 0
tmp_REG |= OSCCTRL_XOSCCTRL_ONDEMAND_Msk; /* on demand  enabled */
%endif
%if XOSC1_RUNSTDBY > 0
tmp_REG |= OSCCTRL_XOSCCTRL_RUNSTDBY_Msk; /* run in standby mode */
%endif
%if XOSC1_XTALEN > 0
tmp_REG |= OSCCTRL_XOSCCTRL_XTALEN_Msk; /* Crystal connected to XIN/XOUT */
%endif
%if XOSC1_IPTAT > 0
tmp_REG |= OSCCTRL_XOSCCTRL_IPTAT(%<XOSC1_IPTAT>); /* always 3, except for frequency lower than 8Mhz? */
%endif
%if XOSC1_IMULT > 0
tmp_REG |= OSCCTRL_XOSCCTRL_IMULT(%<XOSC1_IMULT>); /* adjust current, see table */
%endif
%if XOSC1_CFDPRESC > 0
tmp_REG |= OSCCTRL_XOSCCTRL_CFDPRESC(%<XOSC1_CFDPRESC>); /* Clock failure detector prescaler */
%endif
OSCCTRL_REGS->OSCCTRL_XOSCCTRL[1] = tmp_REG; /* Write config XOSCCTRL1 */
while ((OSCCTRL_REGS->OSCCTRL_STATUS & OSCCTRL_STATUS_XOSCRDY1_Msk) != OSCCTRL_STATUS_XOSCRDY1_Msk ); /* Wait for Oscillator ready bit */	
%endif
%openfile buffer
%assign GCLK_PCHCTRLn = MchpVector64(RTWGenSettings.GCLK_PCHCTRLn) 	
%foreach iP = SIZE(GCLK_PCHCTRLn,1)	
%if GCLK_PCHCTRLn[iP] >= 0
%switch iP		
%case 0
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by  DFLL48 input clock source */
%break
%case 1
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by  Reference clock for FDPLL0 */
%break
%case 2
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by  Reference clock for FDPLL1 */
%break
%case 3
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by FDPLL[0 1] 32KHz clock for internal lock timer / SDHC[0 1] Slow / SERCOM[0..7] Slow */
%break
%case 4
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by EIC */
%break
%case 5
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by FREQM Measure */
%break
%case 6
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by FREQM Reference */
%break
%case 7
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by SERCOM0 Core */
%break
%case 8
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by SERCOM1 Core */
%break
%case 9
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by TC0, TC1 */
%break
%case 10
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by USB */
%break
%case 11
%case 12
%case 13
%case 14
%case 15
%case 16
%case 17
%case 18
%case 19
%case 20
%case 21
%case 22
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by  EVSYS%<iP-11> */
%break
%case 23
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by SERCOM2 Core */
%break
%case 24
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by SERCOM3 Core */
%break
%case 25
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by TCC0, TCC1 */
%break
%case 26
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by TC2, TC3 */
%break
%case 27
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by CAN0 */
%break
%case 28
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by CAN1 */
%break
%case 29
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by TCC2, TCC3 */
%break
%case 30
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by TC4, TC5 */
%break
%case 31
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by PDEC */
%break
%case 32
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by AC */
%break
%case 33
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by CCL */
%break
%case 34
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by SERCOM4 Core */
%break
%case 35
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by SERCOM5 Core */
%break
%case 36
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by SERCOM6 Core */
%break
%case 37
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by SERCOM7 Core */
%break
%case 38
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by TCC4 */
%break
%case 39
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by GCLK_TC7 TC6, TC7 */
%break
%case 40
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by ADC0 */
%break
%case 41
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by ADC1 */
%break
%case 42
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by DAC */
%break
%case 43
%case 44
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by I2S */
%break
%case 45
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by SDHC0 */
%break
%case 46
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by SDHC1 */
%break
%case 47
GCLK_REGS->GCLK_PCHCTRL[%<iP>] = %<MchpHex(GCLK_PCHCTRLn[iP] + 64)>; /* GCLK %<CAST("Number",GCLK_PCHCTRLn[iP])> used by CM4 Trace */
%break
%default
%error("Peripheral GCLK clock assignement out of range")
%endswitch
%endif	
%endforeach
%closefile buffer
%if !ISEMPTY(buffer)
/* Assign Peripheral relying on GCLK clock (GCLK_PCHCTRL[0-47]) a source (GLCK0-11) */
%<buffer>
%endif
%assign GCLK_GENERATOR_x_CONFIG = MchpVector64(RTWGenSettings.GCLK_GENERATOR_x_CONFIG)  
%assign GCLK_GEN_x_SOURCE = MchpVector64(RTWGenSettings.GCLK_GEN_x_SOURCE)  
%assign GCLK_GEN_x_RUNSTDBY = MchpVector64(RTWGenSettings.GCLK_GEN_x_RUNSTDBY)  
%assign GCLK_GEN_x_DIVSEL = MchpVector64(RTWGenSettings.GCLK_GEN_x_DIVSEL)  
%assign GCLK_GEN_x_OE = MchpVector64(RTWGenSettings.GCLK_GEN_x_OE)  
%assign GCLK_GEN_x_OOV = MchpVector64(RTWGenSettings.GCLK_GEN_x_OOV)  
%assign GCLK_GEN_x_IDC = MchpVector64(RTWGenSettings.GCLK_GEN_x_IDC)  
%assign GCLK_GEN_x_GENEN = MchpVector64(RTWGenSettings.GCLK_GEN_x_GENEN)  
%assign GCLK_GEN_x_DIV = MchpVector64(RTWGenSettings.GCLK_GEN_x_DIV)  
%openfile buffer
%foreach iGLK = SIZE(GCLK_GENERATOR_x_CONFIG,1)	
%if GCLK_GENERATOR_x_CONFIG[iGLK] > 0		
%if (GCLK_PCHCTRLn[1] == iGLK) || (GCLK_PCHCTRLn[2] == iGLK)	
%switch GCLK_GEN_x_SOURCE[iGLK]
%case 0
tmp_REG = GCLK_GENCTRL_SRC(GCLK_GENCTRL_SRC_XOSC0_Val);      /* GCLK%<iGLK> uses XOSC0 oscillator  */				
%break
%case 1
tmp_REG = GCLK_GENCTRL_SRC(GCLK_GENCTRL_SRC_XOSC1_Val);      /* GCLK%<iGLK> uses XOSC1 oscillator */
%break
%case 2
tmp_REG = GCLK_GENCTRL_SRC(GCLK_GENCTRL_SRC_GCLKIN_Val);     /* GCLK%<iGLK> uses Generator input pad */
%break
%case 3
tmp_REG = GCLK_GENCTRL_SRC(GCLK_GENCTRL_SRC_GCLKGEN1_Val);   /* GCLK%<iGLK> uses Generic clock generator 1 */
%break
%case 4
tmp_REG = GCLK_GENCTRL_SRC(GCLK_GENCTRL_SRC_OSCULP32K_Val);  /* GCLK%<iGLK> uses OSCULP32K oscillator */
%break
%case 5
tmp_REG = GCLK_GENCTRL_SRC(GCLK_GENCTRL_SRC_XOSC32K_Val);    /* GCLK%<iGLK> uses XOSC32K oscillator  */
%break
%case 6
tmp_REG = GCLK_GENCTRL_SRC(GCLK_GENCTRL_SRC_DFLL_Val);       /* GCLK%<iGLK> uses DFLL */
%break
%case 7
tmp_REG = GCLK_GENCTRL_SRC(GCLK_GENCTRL_SRC_DPLL0_Val);      /* GCLK%<iGLK> uses DPLL0 */
%break
%case 8
tmp_REG = GCLK_GENCTRL_SRC(GCLK_GENCTRL_SRC_DPLL1_Val);      /* GCLK%<iGLK> uses DPLL1 */	
%break
%default
%error("Internal error: Generator source not recognized")
%endswitch		
%if GCLK_GEN_x_RUNSTDBY[iGLK]
tmp_REG |= GCLK_GENCTRL_RUNSTDBY_Msk; /* Run in stdby mode */
%endif
%if GCLK_GEN_x_DIVSEL[iGLK]
tmp_REG |= GCLK_GENCTRL_DIVSEL_Msk; /* Divide by 2^(divider factor + 1) */
%endif
%if GCLK_GEN_x_OE[iGLK]
tmp_REG |= GCLK_GENCTRL_OE_Msk; /* Output enable */
%endif
%if GCLK_GEN_x_OOV[iGLK]
tmp_REG |= GCLK_GENCTRL_OOV_Msk; /* Output Off Value */
%endif
%if GCLK_GEN_x_IDC[iGLK]
tmp_REG |= GCLK_GENCTRL_IDC_Msk; /* Improve Duty Cycle */
%endif
%if GCLK_GEN_x_GENEN[iGLK]		
tmp_REG |= GCLK_GENCTRL_GENEN_Msk; /* Generic Clock Generator Enabled */
%endif
%if GCLK_GEN_x_DIV[iGLK]
tmp_REG |= GCLK_GENCTRL_DIV(%<CAST("Number",GCLK_GEN_x_DIV[iGLK])>); /* Divider factor */
%endif
GCLK_REGS->GCLK_GENCTRL[%<iGLK>] = tmp_REG;	/* GCLK%<iGLK> config */	
%endif			
%endif
%endforeach
%closefile buffer
%if !ISEMPTY(buffer)
/* ---- Configure GCLK used as PLL source  ---- */
%<buffer>
tmp_REG = 0;
%foreach iGLK = SIZE(GCLK_GENERATOR_x_CONFIG,1)
%if GCLK_GENERATOR_x_CONFIG[iGLK] > 0
%if (GCLK_PCHCTRLn[1] == iGLK) || (GCLK_PCHCTRLn[2] == iGLK)	
tmp_REG |= GCLK_SYNCBUSY_GENCTRL(GCLK_SYNCBUSY_GENCTRL_GCLK%<iGLK>_Val); /* GCLK%<iGLK> sync bit */
%endif
%endif	
%endforeach
while((GCLK_REGS->GCLK_SYNCBUSY & tmp_REG) == tmp_REG) ; /* Wait Sync for GCLKs */
%endif
%assign DPLL0_CONFIG = CAST("Number",RTWGenSettings.DPLL0_CONFIG) 
%assign DPLL0_INFO_Fin  = CAST("Real",RTWGenSettings.DPLL0_INFO_Fin)
%assign DPLL0_INFO_PLLout  = CAST("Real",RTWGenSettings.DPLL0_INFO_PLLout)
%assign DPLL0_GCLK = CAST("Number",RTWGenSettings.DPLL0_GCLK) 
%assign DPLL0_ENABLE = CAST("Number",RTWGenSettings.DPLL0_ENABLE) 
%assign DPLL0_ONDEMAND = CAST("Number",RTWGenSettings.DPLL0_ONDEMAND) 
%assign DPLL0_RUNSTDBY = CAST("Number",RTWGenSettings.DPLL0_RUNSTDBY) 
%assign DPLL0_LDRFRAC = CAST("Number",RTWGenSettings.DPLL0_LDRFRAC) 
%assign DPLL0_LDR = CAST("Number",RTWGenSettings.DPLL0_LDR) 
%assign DPLL0_DIV = CAST("Number",RTWGenSettings.DPLL0_DIV) 
%assign DPLL0_DCOEN = CAST("Number",RTWGenSettings.DPLL0_DCOEN) 
%assign DPLL0_DCOFILTER = CAST("Number",RTWGenSettings.DPLL0_DCOFILTER) 
%assign DPLL0_LBYPASS = CAST("Number",RTWGenSettings.DPLL0_LBYPASS) 
%assign DPLL0_LTIME = CAST("Number",RTWGenSettings.DPLL0_LTIME) 
%assign DPLL0_REFCLK = CAST("Number",RTWGenSettings.DPLL0_REFCLK) 
%assign DPLL0_WUF = CAST("Number",RTWGenSettings.DPLL0_WUF) 
%assign DPLL0_FILTER = CAST("Number",RTWGenSettings.DPLL0_FILTER) 
%if DPLL0_CONFIG
/* ---- Configure DPLL0 from %<QUARTZ>Hz to %<DPLL0_INFO_PLLout>Hz ---- */
tmp_REG = OSCCTRL_DPLLRATIO_LDR(%<DPLL0_LDR>); /* PLL Multiplier (x%<DPLL0_LDR>) from %<DPLL0_INFO_Fin> to %<DPLL0_INFO_PLLout> */
%if DPLL0_LDRFRAC > 0
tmp_REG |= OSCCTRL_DPLLRATIO_LDRFRAC(%<DPLL0_LDRFRAC>); /* PLL Multiplier Fractional (%<DPLL0_LDRFRAC>/32) */
%endif
OSCCTRL_REGS->DPLL[0].OSCCTRL_DPLLRATIO = tmp_REG; /* Write OSCCTRL_DPLL0_RATIO config */
%switch DPLL0_REFCLK
%case 0
tmp_REG = OSCCTRL_DPLLCTRLB_REFCLK(%<DPLL0_REFCLK>); /* set GCLK as PLL Source Clock %<QUARTZ>Hz */
%break
%case 1
tmp_REG = OSCCTRL_DPLLCTRLB_REFCLK(%<DPLL0_REFCLK>); /* set XOSC32K as PLL Source Clock %<QUARTZ>Hz */
%break
%case 2
tmp_REG = OSCCTRL_DPLLCTRLB_REFCLK(%<DPLL0_REFCLK>); /* set XOSC0 as PLL Source Clock %<QUARTZ>Hz */
%break
%case 3			
tmp_REG = OSCCTRL_DPLLCTRLB_REFCLK(%<DPLL0_REFCLK>); /* set XOSC1 as PLL Source Clock %<QUARTZ>Hz */
%break
%default
%error("Unknown Source clock for PLL")
%endswitch
%if DPLL0_DIV > 0
tmp_REG |= OSCCTRL_DPLLCTRLB_DIV(%<DPLL0_DIV>); /* Clock Divider <0x0-0x7FF> from %<QUARTZ> to %<DPLL0_INFO_Fin>Hz */
%endif
%if DPLL0_DCOEN > 0
tmp_REG |= OSCCTRL_DPLLCTRLB_DCOEN_Msk; /* Indicates whether DCO Filter Enable is enabled or not */
%endif
%if DPLL0_DCOFILTER > 0
tmp_REG |= OSCCTRL_DPLLCTRLB_DCOFILTER(%<DPLL0_DCOFILTER>); /* Sigma-Delta DCO Filter Selection <0x0-0x7> */
%endif
%if DPLL0_LBYPASS > 0
tmp_REG |= OSCCTRL_DPLLCTRLB_LBYPASS_Msk; /* % Indicates whether Lock Bypass is enabled or not */
%endif
%if DPLL0_LTIME > 0
tmp_REG |= OSCCTRL_DPLLCTRLB_LTIME(%<DPLL0_LTIME>); /* Lock Time */
%endif
%if DPLL0_WUF > 0
tmp_REG |= OSCCTRL_DPLLCTRLB_WUF_Msk; /* % Indicates whether Wake Up Fast is enabled or not */
%endif
%if DPLL0_FILTER > 0
tmp_REG |= OSCCTRL_DPLLCTRLB_FILTER(%<DPLL0_FILTER>); /* % Proportional Integral Filter Selection <0x0-0xF> */
%endif
OSCCTRL_REGS->DPLL[0].OSCCTRL_DPLLCTRLB = tmp_REG; /* Write OSCCTRL_DPLL0_CTRLB config */
while ((OSCCTRL_REGS->DPLL[0].OSCCTRL_DPLLSYNCBUSY & OSCCTRL_DPLLSYNCBUSY_DPLLRATIO_Msk) != 0 ); /* Wait for DPLLRATIO Sync */
%if %<DPLL0_ENABLE>
tmp_REG = OSCCTRL_DPLLCTRLA_ENABLE_Msk;  /* Enable DPLL0 */
%else
tmp_REG = 0;
%endif	
%if DPLL0_ONDEMAND
tmp_REG |= OSCCTRL_DPLLCTRLA_ONDEMAND_Msk; /*  On Demand Control is enabled */
%endif
%if DPLL0_RUNSTDBY		
tmp_REG |= OSCCTRL_DPLLCTRLA_RUNSTDBY_Msk; /* Run in standby is enabled */
%endif
OSCCTRL_REGS->DPLL[0].OSCCTRL_DPLLCTRLA = tmp_REG; /* Write OSCCTRL_DPLL0_CTRLA config */
while ((OSCCTRL_REGS->DPLL[0].OSCCTRL_DPLLSYNCBUSY & OSCCTRL_DPLLSYNCBUSY_ENABLE_Msk) != 0 ); /* Wait for DPLL0CTRL1.ENABLE bit Sync */
while ((OSCCTRL_REGS->DPLL[0].OSCCTRL_DPLLSTATUS & OSCCTRL_DPLLSTATUS_LOCK_Msk) == 0 ); /* Wait for PLL ready bit */	
%endif
%assign MCLK_HSDIV = CAST("Number",RTWGenSettings.MCLK_HSDIV) 
%assign MCLK_CPUDIV = CAST("Number",RTWGenSettings.MCLK_CPUDIV) 
%if MCLK_HSDIV > 1	
/* APB HS Clock Devider */
MCLK_REGS->MCLK_HSDIV = %<MCLK_HSDIV>; /* APB HS clock devider  */
%endif
%if MCLK_CPUDIV > 1	
/* CPU clock divider */
MCLK_REGS->MCLK_CPUDIV = %<MCLK_CPUDIV>; /* APB AHB ane CPU clock devider */
%endif
%openfile buffer
%foreach iGLK = SIZE(GCLK_GENERATOR_x_CONFIG,1)
%if GCLK_GENERATOR_x_CONFIG[iGLK] > 0	
%if 0 == ((GCLK_PCHCTRLn[1] == iGLK) || (GCLK_PCHCTRLn[2] == iGLK))	
%switch GCLK_GEN_x_SOURCE[iGLK]
%case 0
tmp_REG = GCLK_GENCTRL_SRC(GCLK_GENCTRL_SRC_XOSC0_Val);      /* GCLK%<iGLK> uses XOSC0 oscillator  */				
%break
%case 1
tmp_REG = GCLK_GENCTRL_SRC(GCLK_GENCTRL_SRC_XOSC1_Val);      /* GCLK%<iGLK> uses XOSC1 oscillator */
%break
%case 2
tmp_REG = GCLK_GENCTRL_SRC(GCLK_GENCTRL_SRC_GCLKIN_Val);     /* GCLK%<iGLK> uses Generator input pad */
%break
%case 3
tmp_REG = GCLK_GENCTRL_SRC(GCLK_GENCTRL_SRC_GCLKGEN1_Val);   /* GCLK%<iGLK> uses Generic clock generator 1 */
%break
%case 4
tmp_REG = GCLK_GENCTRL_SRC(GCLK_GENCTRL_SRC_OSCULP32K_Val);  /* GCLK%<iGLK> uses OSCULP32K oscillator */
%break
%case 5
tmp_REG = GCLK_GENCTRL_SRC(GCLK_GENCTRL_SRC_XOSC32K_Val);    /* GCLK%<iGLK> uses XOSC32K oscillator  */
%break
%case 6
tmp_REG = GCLK_GENCTRL_SRC(GCLK_GENCTRL_SRC_DFLL_Val);       /* GCLK%<iGLK> uses DFLL */
%break
%case 7
tmp_REG = GCLK_GENCTRL_SRC(GCLK_GENCTRL_SRC_DPLL0_Val);      /* GCLK%<iGLK> uses DPLL0 */
%break
%case 8
tmp_REG = GCLK_GENCTRL_SRC(GCLK_GENCTRL_SRC_DPLL1_Val);      /* GCLK%<iGLK> uses DPLL1 */	
%break
%default
%error("Internal error: Generator source not recognized")
%endswitch		
%if GCLK_GEN_x_RUNSTDBY[iGLK]
tmp_REG |= GCLK_GENCTRL_RUNSTDBY_Msk; /* Run in stdby mode */
%endif
%if GCLK_GEN_x_DIVSEL[iGLK]
tmp_REG |= GCLK_GENCTRL_DIVSEL_Msk; /* Divide by 2^(divider factor + 1) */
%endif
%if GCLK_GEN_x_OE[iGLK]
tmp_REG |= GCLK_GENCTRL_OE_Msk; /* Output enable */
%endif
%if GCLK_GEN_x_OOV[iGLK]
tmp_REG |= GCLK_GENCTRL_OOV_Msk; /* Output Off Value */
%endif
%if GCLK_GEN_x_IDC[iGLK]
tmp_REG |= GCLK_GENCTRL_IDC_Msk; /* Improve Duty Cycle */
%endif
%if GCLK_GEN_x_GENEN[iGLK]		
tmp_REG |= GCLK_GENCTRL_GENEN_Msk; /* Generic Clock Generator Enabled */
%endif
%if GCLK_GEN_x_DIV[iGLK]
tmp_REG |= GCLK_GENCTRL_DIV(%<CAST("Number",GCLK_GEN_x_DIV[iGLK])>); /* Divider factor */
%endif
GCLK_REGS->GCLK_GENCTRL[%<iGLK>] = tmp_REG;	/* GCLK%<iGLK> config */				
%endif
%endif
%endforeach
%closefile buffer
%if !ISEMPTY(buffer)
/* ---- Configure GCLK used to clock CPU (GCLK0) and peripherals ---- */
%<buffer>
tmp_REG = 0;
%foreach iGLK = SIZE(GCLK_GENERATOR_x_CONFIG,1)
%if GCLK_GENERATOR_x_CONFIG[iGLK] > 0
%if 0 == ((GCLK_PCHCTRLn[1] == iGLK) || (GCLK_PCHCTRLn[2] == iGLK))	
tmp_REG |= GCLK_SYNCBUSY_GENCTRL(GCLK_SYNCBUSY_GENCTRL_GCLK%<iGLK>_Val); /* GCLK%<iGLK> sync bit */
%endif	
%endif
%endforeach
while((GCLK_REGS->GCLK_SYNCBUSY & tmp_REG) == tmp_REG) ; /* Wait Sync for GCLKs */
%endif
}
%if DFLL_CONFIG == 0
/* Switch off DFLL48Mhz clock not used */
OSCCTRL_REGS->OSCCTRL_DFLLCTRLA = 0x00;	/* Disable DFLL48M */	
%endif
/* ------- END of Clock Configuration ----  */
%<MCHP_ConfigPins()>
/* Initialize model */
%if ConfigChipOnly == 0
%<LibCallModelInitialize()> 	
%endif
/* ------- NVIC Setup ------ */
%assign TimeStep_SyncADC = CAST("Number",RTWGenSettings.TimeStep_SyncADC)
%if TimeStep_SyncADC == -1
%if CompiledModel.FixedStepOpts.SolverMode == "MultiTasking"
NVIC_SetPriority(SysTick_IRQn, 6u);     /* Scheduler Priority set to 6 */
NVIC_SetPriority(SVCall_IRQn, 0u);
__asm volatile (" SVC #1"); /* The SVC#1 exception will be triggered only once (before SysTick exception!) to ensure that processor can enter in Thread Mode when exceptions are active (see page 601 of ARMv7-M Architecture Reference Manual) */
%else
NVIC_SetPriority(SysTick_IRQn, 6u);     /* Scheduler Priority set to 6 */
%endif
%openfile LocalStartup_TrigTimeStepInstruction
%<::Startup_TrigTimeStepInstruction>\		 		
/* ------ SysTick  Init -----------  */
%assign SYS_TICK_TS_Load = CAST("Number",RTWGenSettings.SYS_TICK_TS_Load)
SysTick->VAL   =  1UL*8;								/*  Start value for the sys Tick counter. Execute first STEP ASAP */
SysTick->LOAD  =  %<SYS_TICK_TS_Load>UL;                                /*  Reload value (corresponds to 1s). This value will be decremented at each CPU tick */
SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk;   /*  Enable SysTick Interrupt; start the counter; select the source for tick (MCLK)   */
%closefile LocalStartup_TrigTimeStepInstruction
%assign ::Startup_TrigTimeStepInstruction = LocalStartup_TrigTimeStepInstruction
%else 
%openfile LocalStartup_TrigTimeStepInstruction
%<::Startup_TrigTimeStepInstruction>\		 		
%if CompiledModel.FixedStepOpts.SolverMode == "MultiTasking"
NVIC_SetPriority(TC0_IRQn, 6u);     /* Scheduler Priority set to 6 */
NVIC_SetPriority(SVCall_IRQn, 0u);
__asm volatile (" SVC #1"); /* The SVC#1 exception will be triggered only once (before SysTick exception!) to ensure that processor can enter in Thread Mode when exceptions are active (see page 601 of ARMv7-M Architecture Reference Manual) */
NVIC_EnableIRQ(TC0_IRQn);                               /*  Enable NVIC line for TC0_IRQn  */
%else
%endif
%closefile LocalStartup_TrigTimeStepInstruction
%assign ::Startup_TrigTimeStepInstruction = LocalStartup_TrigTimeStepInstruction
%endif    	
__enable_irq();	/* Enable Interrupt (Clear PRIMASK) */
%closefile tmpFcnOsc
%return tmpFcnOsc
%endfunction
