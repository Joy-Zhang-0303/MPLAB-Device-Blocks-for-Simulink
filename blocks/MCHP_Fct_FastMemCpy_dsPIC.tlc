
%if ::isPIC32
%assign ::FastMemCpyThreshold_DMA = 9999999     
%assign ::FastMemCpyThreshold = 9999999     
%elseif ::isdsPIC	
%assign ::FastMemCpyThreshold_DMA = 8
%assign ::FastMemCpyThreshold = 16
%endif
%function FastMemCpy(dst,src,n) Output
%if ((ChipIdL1[0] == "E") || (ChipIdL1[0] == "C")) && ( ChipIdN[0] == 33 || ChipIdN[0] == 24)     
fastmemcpy((__eds__ unsigned char*) %<dst>, (__eds__ unsigned char*) %<src>,(unsigned int) %<n>);
%elseif (ChipIdL1[0] == "F") && (ChipIdN[0] == 24)                      
fastmemcpy((__eds__ unsigned char*) %<dst>, (__eds__ unsigned char*) %<src>,(unsigned int) %<n>);
%else 
fastmemcpy((unsigned char*) %<dst>, (unsigned char*) %<src>,(unsigned int) %<n>);
%endif 
%if EXISTS(::MCHP_fastMemCpy) == 0
%openfile fastMemCpy_h = "MCHP_fastMemCpy.h"             
#ifndef _MCHP_FAST_MEMCPY_H
#define	_MCHP_FAST_MEMCPY_H
#include <xc.h>
#include <string.h>
#include <stdio.h>
/*     ------------------------------------------- */
/*     "fastmemcpy" handles:                        */
/*                                                  */
/*     RAM to RAM                                   */
/*     RAM to EDS                                   */
/*     EDS to RAM                                   */
/*     EDS to EDS                                   */
/*     PSV to RAM                                   */
/*     PSV to EDS                                   */
/*                                                  */
/*     Utilities for function test:                 */
/*     inline __attribute__((always_inline))        */
/*     __attribute__ ((noinline))                   */
/*     ----------------------------------------------  */
%if ((ChipIdL1[0] == "E") || (ChipIdL1[0] == "C")) && ( ChipIdN[0] == 33 || ChipIdN[0] == 24)  
/* For devices with EDS: PIC24E and dsPIC33E */
static __attribute__((always_inline)) volatile __eds__ unsigned char * fastmemcpy(volatile __eds__ unsigned char *destination, volatile __eds__ const unsigned char *source, volatile unsigned int NoOfBytesToCopy)
{
if (NoOfBytesToCopy == 0){
return destination;
}
/* Save EDS context */
unsigned int SAVED_DSRPAG = DSRPAG;
unsigned SAVED_DSWPAG = DSWPAG;
unsigned int sourceAddress = (unsigned int)source;
unsigned int destinationAddress = (unsigned int) destination;
/* Avoid Address error trap when DSRPAG or DSWPAG are set to 0x0000 */
/* When an object is in normal RAM space, it's associated pointer will have MSW value equal to 0 : Example EDS address = 0x0000xxxx */
/* When an object is in EDS space (up to 64Kb), it's associated pointer will have MSW value equal to 1 : Example EDS address = 0x0001xxxx */
DSRPAG = (unsigned long int)source >> 16u;
DSWPAG = (unsigned long int)destination >> 16u;
unsigned int temp = 0x0001;
__asm__ volatile(
"CP0  DSRPAG                    \n"
"BTSC SR,#1                     \n"
"MOV %[tmp],DSRPAG              \n"
"CP0  DSWPAG                    \n"
"BTSC SR,#1                     \n"
"MOV %[tmp],DSWPAG              \n"
:
: [tmp] "r" (temp)
: "cc");
temp = (sourceAddress | destinationAddress | NoOfBytesToCopy) & temp;
switch (temp){
case 0 :
// Even: copy in word mode
NoOfBytesToCopy >>= 1u;
NoOfBytesToCopy--;
__asm__ volatile(
"REPEAT %[cnt]                              \n"
"MOV [%[srcAddr]++], [%[dstAddr]++]         \n"
: [dstAddr] "+r"(destinationAddress),[srcAddr] "+r"(sourceAddress)
: [cnt] "r"(NoOfBytesToCopy)
: "memory", "RCOUNT");
break;
case 1 :
// Odd: copy in byte mode
NoOfBytesToCopy--;
__asm__ volatile(
"REPEAT %[cnt]                              \n"
"MOV.b [%[srcAddr]++], [%[dstAddr]++]       \n"
: [dstAddr] "+r"(destinationAddress),[srcAddr] "+r"(sourceAddress)
: [cnt] "r"(NoOfBytesToCopy)
: "memory", "RCOUNT");
break;
}
/* Restore EDS context */
DSRPAG = SAVED_DSRPAG;
DSWPAG = SAVED_DSWPAG;
return destination;
}
%elseif (ChipIdL1[0] == "F") && (ChipIdN[0] == 24)  
/* For devices with EDS: PIC24F (special case: has EDS, but DSWRPAG/DSWPAG are not automatically incremented) */
static __attribute__((always_inline)) volatile __eds__ unsigned char * fastmemcpy(volatile __eds__ unsigned char *destination, volatile __eds__ const unsigned char *source, volatile unsigned int NoOfBytesToCopy)
{
if (NoOfBytesToCopy == 0){
return destination;
}
/* Save EDS context */
unsigned int SAVED_DSRPAG = DSRPAG;
unsigned SAVED_DSWPAG = DSWPAG;
unsigned int sourceAddress = (unsigned int)source;
unsigned int destinationAddress = (unsigned int) destination;
/* Avoid Address error trap when DSRPAG or DSWPAG are set to 0x0000 */
/* When an object is in normal RAM space, it's associated pointer will have MSW value equal to 0 : Example EDS address = 0x0000xxxx */
/* When an object is in EDS space (up to 64Kb), it's associated pointer will have MSW value equal to 1 : Example EDS address = 0x0001xxxx */
DSRPAG = (unsigned long int)source >> 16u;
DSWPAG = (unsigned long int)destination >> 16u;
/* Experimental code used to compute the condition for the "if" statement*/
/* More efficient than using C */
unsigned int temp = 0x0001;
unsigned int PageOverlap = 0;
volatile unsigned int dummyReg;
__asm__ volatile(
//Adjust DSxPAG registers
"CP0  DSRPAG                        \n"
"BTSC SR,#1                         \n"
"MOV %[tmp],DSRPAG                  \n"
"CP0  DSWPAG                        \n"
"BTSC SR,#1                         \n"
"MOV %[tmp],DSWPAG                  \n"
// Check any EDS or PSV page boundary will be crossed
"ADD  %[srcAddr],%[cnt],%[dummy]    \n"
"BTSC SR,#0                         \n"
"MOV #0x0001,%[PagOv]               \n"
"ADD  %[dstAddr],%[cnt],%[dummy]    \n"
"BTSC SR,#0                         \n"
"MOV #0x0001,%[PagOv]               \n"
: [PagOv]"+r"(PageOverlap),[dummy]"=r"(dummyReg)
: [tmp]"r"(temp) ,[dstAddr]"r"(destinationAddress), [srcAddr]"r"(sourceAddress),[cnt] "r"(NoOfBytesToCopy)
: "cc");
temp = (sourceAddress | destinationAddress | NoOfBytesToCopy) & temp;
/* If source data is in EDS and the page boundary is not exceeded OR if source data is in PSV, but the PSV page is not exceeded */
if ( !(PageOverlap) )   //(((unsigned long int)sourceAddress + NoOfBytesToCopy) <= 0xFFFF) && (((unsigned long int)destinationAddress + NoOfBytesToCopy) <= 0xFFFF)  )
{
switch (temp){
case 0 :
// Even: copy in word mode
NoOfBytesToCopy >>= 1u;
NoOfBytesToCopy--;
__asm__ volatile(
"REPEAT %[cnt]                              \n"
"MOV [%[srcAddr]++], [%[dstAddr]++]         \n"
: [dstAddr] "+r"(destinationAddress),[srcAddr] "+r"(sourceAddress)
: [cnt] "r"(NoOfBytesToCopy)
: "memory", "RCOUNT");
break;
case 1 :
// Odd: copy in byte mode
NoOfBytesToCopy--;
__asm__ volatile(
"REPEAT %[cnt]                              \n"
"MOV.b [%[srcAddr]++], [%[dstAddr]++]       \n"
: [dstAddr] "+r"(destinationAddress),[srcAddr] "+r"(sourceAddress)
: [cnt] "r"(NoOfBytesToCopy)
: "memory", "RCOUNT");
break;
}
}
else{
/* Only if source data is in PSV and will exceed a page boundary OR if data is in EDS and will exceed a page boundary. This is 3x slower */
__asm__ volatile(
"cp %[tmp],#1                           \n"
"bra z,1f                               \n"
//copy byte mode
" 2: mov.b [%[srcAddr]],[%[dstAddr]]        \n"
"dec %[cnt],%[cnt]                      \n"
"bra z,4f                               \n"
"add %[dstAddr],#1,%[dstAddr]           \n"
"bra nc,3f                              \n"
"inc DSWPAG                             \n"
"mov #0x8000,w2                         \n"
" 3: add %[srcAddr],#1,%[srcAddr]           \n"
"bra nc,2b                              \n"
"inc DSRPAG                             \n"
"mov #0x8000,%[srcAddr]                 \n"
"bra 2b                                 \n"
//"copy in word mode
" 1: mov  [%[srcAddr]],[%[dstAddr]]         \n"
"dec2 %[cnt],%[cnt]                     \n"
"bra z,4f                               \n"
"add %[dstAddr],#2,%[dstAddr]           \n"
"bra nc,3f                              \n"
"inc DSWPAG                             \n"
"mov #0x8000,%[dstAddr]                 \n"
" 3: add %[srcAddr],#2,%[srcAddr]           \n"
" bra nc,1b                              \n"
"inc DSRPAG                             \n"
"mov #0x8000,%[srcAddr]                 \n"
"bra 1b                                 \n"
" 4: NOP                                    \n"
: [dstAddr] "+r"(destinationAddress),[srcAddr] "+r"(sourceAddress)
: [cnt] "r"(NoOfBytesToCopy), [tmp] "r"(temp)
: "memory", "cc");
}
/* Restore EDS context */
DSRPAG = SAVED_DSRPAG;
DSWPAG = SAVED_DSWPAG;
return destination;
}
%else 
#if defined(PSVPAG) == 0        
#error "fastmemcpy" function cannot be used with selected device: NO DSRPAG/DSWPAG OR PSVPAG REGISTERS ARE PRESENT
#endif
/* For devices without EDS: 30F, 33F, PIC24H */
static volatile __attribute__((always_inline)) unsigned char * fastmemcpy(volatile unsigned char *destination, volatile __eds__ const unsigned char *source, volatile unsigned int NoOfBytesToCopy)
{
if (NoOfBytesToCopy == 0){
return destination;
}
/* Save PSV context */
unsigned int SAVED_CORCON = CORCON;
unsigned int SAVED_PSVPAG = PSVPAG;
unsigned int sourceAddress = (unsigned int)source;
unsigned int sourcePage = (unsigned long int)source >> 16u;
unsigned int destinationAddress = (unsigned int) destination;
unsigned int temp = 0x0001;
PSVPAG = sourcePage;
temp = (sourceAddress | destinationAddress | NoOfBytesToCopy) & temp;
/* If source data is in RAM or if source data is in PSV, but the PSV page is not exceeded */
if ( ((unsigned long int)sourceAddress + NoOfBytesToCopy) <= 0xFFFF ){
switch (temp){
case 0 :
// Even: copy in word mode
NoOfBytesToCopy >>= 1u;
NoOfBytesToCopy--;
__asm__ volatile(
"REPEAT %[cnt]                              \n"
"MOV [%[srcAddr]++], [%[dstAddr]++]         \n"
: [dstAddr] "+r"(destinationAddress),[srcAddr] "+r"(sourceAddress)
: [cnt] "r"(NoOfBytesToCopy)
: "memory", "RCOUNT");
break;
case 1 :
// Odd: copy in byte mode
NoOfBytesToCopy--;
__asm__ volatile(
"REPEAT %[cnt]                              \n"
"MOV.b [%[srcAddr]++], [%[dstAddr]++]       \n"
: [dstAddr] "+r"(destinationAddress),[srcAddr] "+r"(sourceAddress)
: [cnt] "r"(NoOfBytesToCopy)
: "memory", "RCOUNT");
break;
}
}
else{
/* Only if source data is in PSV and will exceed a page boundary. This is 3x slower */
__asm__ volatile(
"cp %[tmp],#1                       \n"
"bra nz,1f                          \n"
"2: mov.b [%[srcAddr]],[%[dstAddr]++]   \n"
"dec %[cnt],%[cnt]                  \n"
"bra z,4f                           \n"
"3: add %[srcAddr],#1,%[srcAddr]        \n"
"bra nc,2b                          \n"
"inc PSVPAG                         \n"
"mov #0x8000,%[srcAddr]             \n"
"bra 2b                             \n"
"1: mov [%[srcAddr]],[%[dstAddr]++]     \n"
"dec2 %[cnt],%[cnt]                 \n"
"bra z,4f                           \n"
"3: add %[srcAddr],#2,%[srcAddr]        \n"
"bra nc,1b                          \n"
"inc PSVPAG                         \n"
"mov #0x8000,%[srcAddr]             \n"
"bra 1b                             \n"
"4: NOP                                \n"
: [dstAddr] "+r"(destinationAddress),[srcAddr] "+r"(sourceAddress)
: [cnt] "r"(NoOfBytesToCopy), [tmp] "r"(temp)
: "memory", "cc");
}
/* Restore PSVPAG & CORCON context */
CORCON = SAVED_CORCON;
PSVPAG = SAVED_PSVPAG;
return destination;
}
%endif  
/*------------------------------------------------------------------------------------ */
/* Attention! : use a " " blank space before LABEL_%= or otherwise, the concatenation */
/* with assembler generated number for label (%=) will not take place, resulting */
/* into an unknown "Label_&= :" mnemonic. */
/*-------------------------------------------------------------------------------------*/
#endif 
%closefile fastMemCpy_h
%<LibAddToCommonIncludes("MCHP_fastMemCpy.h")>
%endif
%assign ::MCHP_fastMemCpy = 1
%endfunction
