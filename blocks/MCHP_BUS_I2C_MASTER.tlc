%implements  MCHP_BUS_I2C_MASTER "C"
%include "MCHP_Functions.tlc"
%assign ::MCHP_NumI2CBlocks      = [0,0,0,0,0,0,0,0,0,0,0,0]
%assign ::MCHP_I2C_StartImplemented = [0,0,0,0,0,0,0,0,0,0,0,0]		
%assign ::MCHP_I2C_OutputImplemented = [0,0,0,0,0,0,0,0,0,0,0,0]	
%if ::isCORTEX_M4F || ::isCORTEX_M0p
%include "MCHP_BUS_I2C_Functions_SAMx5.tlc"
%elseif ::MCHP_modsrc.DOS_01441_i2c_upb_v1_32bit 
%include "MCHP_BUS_I2C_Functions_DOS_01441_i2c_upb_v1_32bit.tlc"
%elseif ::MCHP_modsrc.DOS_01441_i2c_upb_v1_16bit_TLAH 
%include "MCHP_BUS_I2C_Functions_DOS_01441_i2c_upb_v1_16bit_TLAH.tlc"  
%elseif (::ChipIdN[0] == 30)
%include "MCHP_BUS_I2C_Functions_dsPIC30F.tlc"
%else  
%include "MCHP_BUS_I2C_Functions_DOS_00996.tlc"
%endif
%assign ::MCHP_I2C_NextState = [%<FirstState>, %<FirstState>, %<FirstState>, %<FirstState>, %<FirstState>, %<FirstState>, %<FirstState>, %<FirstState>, %<FirstState>, %<FirstState>, %<FirstState>, %<FirstState>]		
%function BlockInstanceSetup(block, system) void
%assign I2CRef = CAST("Number",block.RTWdata.I2CRef)
%assign ::MCHP_NumI2CBlocks[I2CRef] = ::MCHP_NumI2CBlocks[I2CRef] + 1
%createrecord MCHP_TLCData {Current_NumI2CBlocks ::MCHP_NumI2CBlocks[I2CRef]}
%addtorecord block MCHP_TLCData MCHP_TLCData
%<HARMONY_RegisterPeripheral("I2C",I2CRef,block)>
%endfunction
%function Start(block, system) Output
%assign I2CRef = CAST("Number",block.RTWdata.I2CRef)
%assign blockingMode = CAST("Number",block.RTWdata.blockingMode)
%assign sequenceCompleted = CAST("Number",block.RTWdata.sequenceCompleted)
%assign NewRegName = CAST("Number",block.RTWdata.NewRegName)
%switch NewRegName
%case 0
%assign I2CRefReg =  ""
%assign I2CRefRegEnd = ""
%case 1
%assign I2CRefReg =  I2CRef
%assign I2CRefRegEnd = ""
%break
%case 2
%assign I2CRefReg =  I2CRef
%assign I2CRefRegEnd = "L"
%break
%endswitch
%assign I2CUserData = MchpVector(block.RTWdata.I2CUserData)
%assign I2CSequence = MchpVector(block.RTWdata.I2CSequence)
%assign SeqL = 10
%assign I2CSequenceLength = FEVAL("numel",I2CSequence)
%assign nSeq = I2CSequenceLength / SeqL	
%assign I2CxCON = CAST("Number",block.RTWdata.I2CxCON)
%assign Buff8_size = MchpVector(block.RTWdata.Buff8_size)
%assign Buff16_size = MchpVector(block.RTWdata.Buff16_size)
%assign IntPriority = MchpVector(block.RTWdata.IntPriority)
%assign PIN_SDA = CAST("Number",block.RTWdata.PIN_SDA)
%assign PIN_SCL = CAST("Number",block.RTWdata.PIN_SCL)
%assign DOS_01441_i2c_upb_v1_32bit = CAST("Number",block.RTWdata.DOS_01441_i2c_upb_v1_32bit)
%assign hexHandle = MchpVector(block.RTWdata.hexHandle)
%assign ::MCHP_I2C_StartImplemented[I2CRef] = ::MCHP_I2C_StartImplemented[I2CRef] + 1
%if ::MCHP_NumI2CBlocks[I2CRef] == 1
%assign I2C_Id = ""
%else
%assign I2C_Id = block.MCHP_TLCData.Current_NumI2CBlocks
%endif
%if ::MCHP_I2C_StartImplemented[I2CRef] == 1	
%if I2CSequence[0] == -1
%<I2C_Config(I2CRef,I2CSequence,0)>	
%<SetSDA_SCL_Output_0(PIN_SDA,PIN_SCL)>		
%<I2C_InterruptsConfig(I2CRef,IntPriority)>
%endif
%endif
%assign nI2CPortOut = 0
%foreach iSeq = nSeq
%switch I2CSequence[iSeq*SeqL]
%case 128 
%assign nI2CPortOut = nI2CPortOut + 1
%break
%endswitch
%endforeach
%if LibBlockSampleTime(block) == -2		
%if (nI2CPortOut != 0) && (blockingMode == 0)		
%error "This I2C block used for initialisation (inf sample time) requires to enable "blocking mode" so as to provide a valid output."
%else
/* I2C Initialisation sequence executed once */
%<OutputsI2C(block, system)>
%endif
%endif
%endfunction
%function Outputs(block, system) Output
%assign I2CRef = CAST("Number",block.RTWdata.I2CRef)
%assign blockingMode = CAST("Number",block.RTWdata.blockingMode)
%assign sequenceCompleted = CAST("Number",block.RTWdata.sequenceCompleted)
%assign I2CSequence = MchpVector(block.RTWdata.I2CSequence)
%assign SeqL = 10
%assign I2CSequenceLength = FEVAL("numel",I2CSequence)
%assign nSeq = I2CSequenceLength / SeqL	
%assign nI2CPortOut = 0
%foreach iSeq = nSeq
%switch I2CSequence[iSeq*SeqL]
%case 128 
%assign nI2CPortOut = nI2CPortOut + 1
%break
%endswitch
%endforeach
%if (LibBlockSampleTime(block) != -2) || ...
((LibBlockSampleTime(block) == -2) && (nI2CPortOut != 0) && (blockingMode == 0))
%<OutputsI2C(block, system)>
%endif
%endfunction
%function OutputsI2C(block, system) Output
%assign I2CRef = CAST("Number",block.RTWdata.I2CRef)
%assign blockingMode = CAST("Number",block.RTWdata.blockingMode)
%assign sequenceCompleted = CAST("Number",block.RTWdata.sequenceCompleted)
%assign NewRegName = CAST("Number",block.RTWdata.NewRegName)
%switch NewRegName
%case 0
%assign I2CRefReg =  ""
%assign I2CRefRegEnd = ""
%case 1
%assign I2CRefReg =  I2CRef
%assign I2CRefRegEnd = ""
%break
%case 2
%assign I2CRefReg =  I2CRef
%assign I2CRefRegEnd = "L"
%break
%endswitch
%assign DOS_01441_i2c_upb_v1_32bit = CAST("Number",block.RTWdata.DOS_01441_i2c_upb_v1_32bit)
%addtorecord block.MCHP_TLCData I2C_StartSequenceState ::MCHP_I2C_NextState[I2CRef]
/* number of I2C blocks : %<::MCHP_NumI2CBlocks[I2CRef]> ; Current: %<block.MCHP_TLCData.Current_NumI2CBlocks> ; MCHP_I2C_StartImplemented =  %<::MCHP_I2C_StartImplemented[I2CRef]>*/
%assign ::MCHP_I2C_OutputImplemented[I2CRef] = ::MCHP_I2C_OutputImplemented[I2CRef] + 1
%<MCHP_I2C_Interrupt(block)>
%if ::MCHP_NumI2CBlocks[I2CRef] == 1
%assign I2C_Id = ""
%else
%assign I2C_Id = block.MCHP_TLCData.Current_NumI2CBlocks
%endif
%assign I2CUserData = MchpVector(block.RTWdata.I2CUserData)
%assign I2CSequence = MchpVector(block.RTWdata.I2CSequence)
%assign SeqL = 10
%assign I2CSequenceLength = FEVAL("numel",I2CSequence)
%assign nSeq = I2CSequenceLength / SeqL	
%assign I2CxCON = CAST("Number",block.RTWdata.I2CxCON)
%assign Buff8_size = MchpVector(block.RTWdata.Buff8_size)
%assign Buff16_size = MchpVector(block.RTWdata.Buff16_size)
%assign IntPriority = MchpVector(block.RTWdata.IntPriority)
%assign PIN_SDA = CAST("Number",block.RTWdata.PIN_SDA)
%assign PIN_SCL = CAST("Number",block.RTWdata.PIN_SCL)
%assign hexHandle = MchpVector(block.RTWdata.hexHandle)
%assign StartSequenceState = block.MCHP_TLCData.I2C_StartSequenceState	
%assign uIdx = 0	
%assign uIdx = 0	
%assign yIdx = 0	
%if sequenceCompleted	
%assign OutPortSequenceCompleted = LibBlockOutputSignal(yIdx, "", "", 0)
%assign yIdx = yIdx + 1
%endif
%assign yIdxTab = [0:1024]	
%assign uIdxTab = [0:1024]
%foreach iSeq = nSeq
%assign uIdxTab[iSeq] = -1
%assign yIdxTab[iSeq] = -1
%switch I2CSequence[iSeq*SeqL]
%case 32 
%if I2CSequence[iSeq*SeqL+1] == 1	
%assign uIdxTab[iSeq] = uIdx
%assign uIdx = uIdx+1
%endif
%break
%case 64 
%if I2CSequence[iSeq*SeqL+2] == 1	
%assign uIdxTab[iSeq] = uIdx
%assign uIdx = uIdx+1
%endif
%break
%case 128 
%assign yIdxTab[iSeq] = yIdx
%assign yIdx = yIdx+1
%break
%endswitch
%endforeach
%if blockingMode == 0
%if sequenceCompleted
%<OutPortSequenceCompleted> = (MCHP_I2C%<I2CRef>_Seq%<I2C_Id>_Completed > 0);		/* Completed I2C %<I2CRef> sequence %<I2C_Id> flag */
MCHP_I2C%<I2CRef>_Seq%<I2C_Id>_Completed = 0;
%endif
%include "MCHP_BUS_I2C_MASTER_InOutBackground.tlc"
%else 
%include "MCHP_BUS_I2C_MASTER_InOutBlocking.tlc"
%if sequenceCompleted
%<OutPortSequenceCompleted> = (MCHP_I2C%<I2CRef>_Seq%<I2C_Id>_Completed > 0);		/* Completed I2C %<I2CRef> sequence %<I2C_Id> flag */
MCHP_I2C%<I2CRef>_Seq%<I2C_Id>_Completed = 0;
%endif
%endif
%endfunction
%function MCHP_I2C_Interrupt(block) void
%assign ChipIdL1 = CAST("String",RTWGenSettings.ChipIdL1)
%assign ChipIdL2 = CAST("String",RTWGenSettings.ChipIdL2)
%assign ChipIdL3 = CAST("String",RTWGenSettings.ChipIdL3)
%assign ChipIdN =  MchpVector(RTWGenSettings.ChipIdN)
%assign sequenceCompleted = CAST("Number",block.RTWdata.sequenceCompleted)
%assign I2CRef = CAST("Number",block.RTWdata.I2CRef)
%assign NewRegName = CAST("Number",block.RTWdata.NewRegName)
%switch NewRegName
%case 0
%assign I2CRefReg =  ""
%assign I2CRefRegEnd = ""
%case 1
%assign I2CRefReg =  I2CRef
%assign I2CRefRegEnd = ""
%break
%case 2
%assign I2CRefReg =  I2CRef
%assign I2CRefRegEnd = "L"
%break
%endswitch
%if ::MCHP_NumI2CBlocks[I2CRef] == 1
%assign I2C_Id = ""
%else
%assign I2C_Id = block.MCHP_TLCData.Current_NumI2CBlocks
%endif
%assign I2CUserData = MchpVector(block.RTWdata.I2CUserData)
%assign I2CSequence = MchpVector(block.RTWdata.I2CSequence)
%assign SeqL = 10
%assign I2CSequenceLength = FEVAL("numel",I2CSequence)
%assign nSeq = I2CSequenceLength / SeqL	
%assign I2CxCON = CAST("Number",block.RTWdata.I2CxCON)
%assign Buff8_size = MchpVector(block.RTWdata.Buff8_size)
%assign Buff16_size = MchpVector(block.RTWdata.Buff16_size)
%assign IntPriority = MchpVector(block.RTWdata.IntPriority)
%assign PIN_SDA = CAST("Number",block.RTWdata.PIN_SDA)
%assign PIN_SCL = CAST("Number",block.RTWdata.PIN_SCL)
%assign DOS_01441_i2c_upb_v1_32bit = CAST("Number",block.RTWdata.DOS_01441_i2c_upb_v1_32bit)
%assign hexHandle = MchpVector(block.RTWdata.hexHandle)
%assign StartSequenceState = block.MCHP_TLCData.I2C_StartSequenceState
%assign MASTER = 1
%assign uIdx = 0	
%assign yIdx = 0	
%assign UseUserInterrupt = 0
%foreach iSeq = nSeq
%if I2CSequence[iSeq*SeqL] == 16
%assign UseUserInterrupt = 1
%break
%endif
%endforeach
%if ::MCHP_I2C_OutputImplemented[I2CRef] == 1
%openfile I2C_InterruptFun =  "MCHP_I2C%<I2CRef>_Interrupt.c"
%assign ::MCHP_I2C_InterruptImplemented[I2CRef] = 1	
#include "%<LibGetMdlPubHdrBaseName()>.h"
#include "%<LibGetMdlPubHdrBaseName()>_private.h"
/* I2C - Interrupt: %<Name> */
%else
%openfile I2C_InterruptFun ="MCHP_I2C%<I2CRef>_Interrupt.c","a"	
%endif
%assign cDatafile = "MCHP_I2C%<I2CRef>_Interrupt_data.c"
%if ::MCHP_I2C_OutputImplemented[I2CRef] == 1
%openfile I2C_InterruptFun_data =  cDatafile
/* Declaration of Global Variable for I2C %<I2CRef> Peripheral */
#include "%<LibGetMdlPubHdrBaseName()>.h"
#include "%<LibGetMdlPubHdrBaseName()>_private.h"	
/* I2C - Interrupt: %<Name> */
volatile uint16_T MCHP_I2C%<I2CRef>_State = 0;
%openfile buffer
extern uint16_T volatile MCHP_I2C%<I2CRef>_State;
%closefile buffer
%<LibCacheExtern(buffer)>
%else
%openfile I2C_InterruptFun_data = cDatafile,"a" 
%endif
%if sequenceCompleted
int volatile MCHP_I2C%<I2CRef>_Seq%<I2C_Id>_Completed = 0;	/* Completed I2C %<I2CRef>%<I2C_Id> sequence flag */
%openfile buffer
extern int volatile MCHP_I2C%<I2CRef>_Seq%<I2C_Id>_Completed; /* Completed I2C %<I2CRef>%<I2C_Id> sequence flag */
%closefile buffer
%<LibCacheExtern(buffer)>		
%endif
%if ::MCHP_NumI2CBlocks[I2CRef] != 1
unsigned int volatile MCHP_I2C%<I2CRef>%<I2C_Id>_Request = 0;
%openfile buffer
extern unsigned int volatile MCHP_I2C%<I2CRef>%<I2C_Id>_Request;
%closefile buffer
%<LibCacheExtern(buffer)>
%if ::MCHP_I2C_OutputImplemented[I2CRef] == 1
%openfile buffer
typedef struct MCHP_I2C%<I2CRef>_QueueStr{
volatile uint16_T buffer[%<::MCHP_NumI2CBlocks[I2CRef]+1>];			/* Size is equal to the number or distinct sequence set +1 */
uint16_T  tail;									/* tail is the index for the next value to be read from the Circular buffer */				
volatile uint16_T  head;							/* head is the index for the next value to be written into the Circular buffer */
}  MCHP_I2C%<I2CRef>_QueueStr;
%closefile buffer
%<LibCacheTypedefs(buffer)>
/* Declare I2C%<I2CRef> Queue Circular Buffer */
MCHP_I2C%<I2CRef>_QueueStr MCHP_I2C%<I2CRef>_Queue;
%openfile buffer
/* Declare I2C%<I2CRef> Queue Circular Buffer */
extern MCHP_I2C%<I2CRef>_QueueStr MCHP_I2C%<I2CRef>_Queue;
%closefile buffer
%<LibCacheExtern(buffer)>
%endif
%else
unsigned int volatile MCHP_I2C%<I2CRef>_Request = 0;
%openfile buffer
extern unsigned int volatile MCHP_I2C%<I2CRef>_Request;
%closefile buffer
%<LibCacheExtern(buffer)>
%endif
%if Buff16_size != 0
volatile uint16_T I2C%<I2CRef>%<I2C_Id>_Buff16[%<Buff16_size>];
%openfile buffer
extern volatile uint16_T I2C%<I2CRef>%<I2C_Id>_Buff16[%<Buff16_size>];
%closefile buffer
%<LibCacheExtern(buffer)>
%endif
%if Buff8_size != 0
volatile uint8_T I2C%<I2CRef>%<I2C_Id>_Buff8[%<Buff8_size>];
%openfile buffer
extern volatile uint8_T I2C%<I2CRef>%<I2C_Id>_Buff8[%<Buff8_size>];
%closefile buffer
%<LibCacheExtern(buffer)>
%endif
%closefile I2C_InterruptFun_data
%if ::MCHP_I2C_OutputImplemented[I2CRef] == 1
%<I2C_Declare_Interrupt(I2CRef,IntPriority,UseUserInterrupt,block)>
{
%<MCHP_InterruptProlog()>
%if ::MCHP_NumI2CBlocks[I2CRef] != 1	
boolean_T Continue;
%endif
%<Clear_I2C_Interrupt_Flag(I2CRef)>
%<MCHP_ProfileMCU("enter")>
/* Declaration of Variables */
%assign MCHP_I2Cx_State = 0
%if ::MCHP_NumI2CBlocks[I2CRef] != 1	
do{
Continue = 0;	/* By default, execute one sequence only */
%endif
switch(MCHP_I2C%<I2CRef>_State)
{
case %<MCHP_I2Cx_State>:	/* Idle */
%assign MCHP_I2Cx_State = MCHP_I2Cx_State+1
%if ::MCHP_NumI2CBlocks[I2CRef] != 1	
/* Check if the next sequence is already in the queue. If so, start it */
Continue = (MCHP_I2C%<I2CRef>_Queue.head != MCHP_I2C%<I2CRef>_Queue.tail); /* One next sequence queued, start it now */
if (Continue) {
MCHP_I2C%<I2CRef>_State = MCHP_I2C%<I2CRef>_Queue.buffer[MCHP_I2C%<I2CRef>_Queue.tail];
if (MCHP_I2C%<I2CRef>_Queue.tail >= %<::MCHP_NumI2CBlocks[I2CRef]>)	/* There are %<::MCHP_NumI2CBlocks[I2CRef]> I2C%<I2CRef> blocks, max idx for queue is %<::MCHP_NumI2CBlocks[I2CRef]> */
MCHP_I2C%<I2CRef>_Queue.tail = 0;
else
MCHP_I2C%<I2CRef>_Queue.tail++;
}
%endif
break;
case %<MCHP_I2Cx_State>:	/* Problem: try Reset of I2C BUS : Repeated Start sequence and Stop */
%assign MCHP_I2Cx_State = MCHP_I2Cx_State+1
%<Set_SDA_SCL_DIT_Pin_Input(PIN_SDA,PIN_SCL)>
%<I2C_Config(I2CRef,I2CSequence,0)>
%<I2C_ResetStateError(I2CRef)>
%assign MCHP_I2Cx_State = MCHP_I2Cx_State + %<I2C_Restart(I2CRef,MCHP_I2Cx_State)>
/* Problem: try Reset of I2C BUS : Stop sequence*/
%<I2C_ResetStateError(I2CRef)>
%assign BreakRequired = %<I2C_Stop(I2CRef,0)>
MCHP_I2C%<I2CRef>_State++;
break;
case %<MCHP_I2Cx_State>:
%assign MCHP_I2Cx_State = MCHP_I2Cx_State+1
%<I2C_ResetStateError(I2CRef)>
MCHP_I2C%<I2CRef>_State = 0;
%if ::MCHP_NumI2CBlocks[I2CRef] > 1
Continue = (MCHP_I2C%<I2CRef>_Queue.head != MCHP_I2C%<I2CRef>_Queue.tail);		/* Any pending sequence ? */
%endif
break;
%else
%assign MCHP_I2Cx_State = ::MCHP_I2C_NextState[I2CRef]
%endif
case %<MCHP_I2Cx_State>:	/* Start a new I2C Sequence */
%assign MCHP_I2Cx_State = MCHP_I2Cx_State+1
%assign BreakRequired = 0
%assign PreviousValue8 = -1
%assign WriteAddress_DataReadReady = 0	
%assign NextNACK = 0	
%if sequenceCompleted
%assign CheckSlave_Ack_required = 0
%endif
%assign Flag_AuthorizeReEnable = 0
%foreach iSeq = nSeq
%assign seqRepeat = I2CSequence[iSeq*SeqL+1]
%switch I2CSequence[iSeq*SeqL]
%case 0	
%if BreakRequired		
MCHP_I2C%<I2CRef>_State++;
break;
case %<MCHP_I2Cx_State>:
%assign MCHP_I2Cx_State = MCHP_I2Cx_State+1
%assign BreakRequired = 0
%endif
%if sequenceCompleted
%if CheckSlave_Ack_required == 2	
MCHP_I2C%<I2CRef>_Seq%<I2C_Id>_Completed -= (int) %<I2C_isNACK(I2CRef)>;	/* decrement on NACK: sequence completed remains 0 */
%endif
%assign CheckSlave_Ack_required	= 0	
%endif
%if (PreviousValue8 >= 0)
%assign writeTo = "I2C%<I2CRef>%<I2C_Id>_Buff8[%<PreviousValue8>]"
%<I2C_ReadDataRegister(I2CRef,MASTER,8,writeTo)>
%assign PreviousValue8 = -1	
%assign MCHP_I2Cx_State = MCHP_I2Cx_State + %<I2C_Write_NACK(I2CRef,MASTER,MCHP_I2Cx_State)>
%assign NextNACK = 1
%assign BreakRequired = 0
%endif
/*	I2C configuration update */
%<I2C_Config(I2CRef,I2CSequence,iSeq*SeqL)>
%break
%case 1	
%if BreakRequired		
MCHP_I2C%<I2CRef>_State++;
break;
case %<MCHP_I2Cx_State>:
%assign MCHP_I2Cx_State = MCHP_I2Cx_State+1
%assign BreakRequired = 0
%endif
%if sequenceCompleted
%if CheckSlave_Ack_required >= 2				
MCHP_I2C%<I2CRef>_Seq%<I2C_Id>_Completed -= (int) %<I2C_isNACK(I2CRef)>;	/* decrement on NACK: sequence completed remains 0 */
%endif
%assign CheckSlave_Ack_required	= 1	
%endif
%if (PreviousValue8 >= 0)
%assign writeTo = "I2C%<I2CRef>%<I2C_Id>_Buff8[%<PreviousValue8>]"
%<I2C_ReadDataRegister(I2CRef,MASTER,8,writeTo)>
%assign PreviousValue8 = -1	
%assign MCHP_I2Cx_State = MCHP_I2Cx_State + %<I2C_Write_NACK(I2CRef,MASTER,MCHP_I2Cx_State)>
%assign NextNACK = 1
%assign BreakRequired = 0
%endif
%assign BreakRequired = %<I2C_Start(I2CRef)>
%break
%case 2	
%if BreakRequired		
MCHP_I2C%<I2CRef>_State++;
break;
case %<MCHP_I2Cx_State>:
%assign MCHP_I2Cx_State = MCHP_I2Cx_State+1
%assign BreakRequired = 0
%endif
%if sequenceCompleted
%if CheckSlave_Ack_required >= 2				
MCHP_I2C%<I2CRef>_Seq%<I2C_Id>_Completed -= (int) %<I2C_isNACK(I2CRef)>;	/* decrement on NACK: sequence completed remains 0 */
%endif
%assign CheckSlave_Ack_required	= 0
%endif
%if (PreviousValue8 >= 0)
%assign writeTo = "I2C%<I2CRef>%<I2C_Id>_Buff8[%<PreviousValue8>]"
%<I2C_ReadDataRegister(I2CRef,MASTER,8,writeTo)>
%assign PreviousValue8 = -1	
%assign MCHP_I2Cx_State = MCHP_I2Cx_State + %<I2C_Write_NACK(I2CRef,MASTER,MCHP_I2Cx_State)>
%assign NextNACK = 1
%assign BreakRequired = 0
%endif
%assign BreakRequired = %<I2C_Stop(I2CRef,NextNACK)>
%assign NextNACK = 0
%break
%case 3	
%assign AddrForRestart = I2CSequence[iSeq*SeqL+1]
%if BreakRequired		
MCHP_I2C%<I2CRef>_State++;
break;
case %<MCHP_I2Cx_State>:
%assign MCHP_I2Cx_State = MCHP_I2Cx_State+1
%assign BreakRequired = 0
%endif
%if sequenceCompleted
%if CheckSlave_Ack_required == 2	
MCHP_I2C%<I2CRef>_Seq%<I2C_Id>_Completed -= (int) %<I2C_isNACK(I2CRef)>;	/* decrement on NACK: sequence completed remains 0 */				
%endif
%assign CheckSlave_Ack_required	= 0	
%endif
%if (PreviousValue8 >= 0)
%assign writeTo = "I2C%<I2CRef>%<I2C_Id>_Buff8[%<PreviousValue8>]"
%<I2C_ReadDataRegister(I2CRef,MASTER,8,writeTo)>
%assign PreviousValue8 = -1	
%assign MCHP_I2Cx_State = MCHP_I2Cx_State + %<I2C_Write_NACK(I2CRef,MASTER,MCHP_I2Cx_State)>
%assign NextNACK = 1		
%assign BreakRequired = 0
%endif
%assign MCHP_I2Cx_State = MCHP_I2Cx_State + %<I2C_Restart(I2CRef,MCHP_I2Cx_State)>			
%if  AddrForRestart != -1
%assign N_Read = I2CSequence[iSeq*SeqL+8]	
%assign RW = -1
%assign AddressIsBlockInput = 0
%assign MCHP_I2Cx_State = I2C_WriteAddress(I2CRef,1,7,AddrForRestart,RW,AddressIsBlockInput,N_Read,MCHP_I2Cx_State) 
%assign WriteAddress_DataReadReady = I2C_WriteAddress_DataReadReady(I2CRef,1,NB,address,Address_ReadWrite,AddressIsBlockInput,N_Read,MCHP_I2Cx_State)
%assign NextNACK = 0
%assign BreakRequired = 1
%endif    		
%break
%case 32	
%if BreakRequired		
MCHP_I2C%<I2CRef>_State++;
break;
case %<MCHP_I2Cx_State>:
%assign MCHP_I2Cx_State = MCHP_I2Cx_State+1
%assign BreakRequired = 0
%endif
%if sequenceCompleted
%if CheckSlave_Ack_required >= 2				
MCHP_I2C%<I2CRef>_Seq%<I2C_Id>_Completed -= (int) %<I2C_isNACK(I2CRef)>;	/* decrement on NACK: sequence completed remains 0 */
%endif 			
%endif
%if (PreviousValue8 >= 0)
%assign writeTo = "I2C%<I2CRef>%<I2C_Id>_Buff8[%<PreviousValue8>]"
%<I2C_ReadDataRegister(I2CRef,MASTER,8,writeTo)>
%assign PreviousValue8 = -1	
%assign MCHP_I2Cx_State = MCHP_I2Cx_State + %<I2C_Write_NACK(I2CRef,MASTER,MCHP_I2Cx_State)>
%assign NextNACK = 1
%assign BreakRequired = 0
%endif
%assign AddressIsBlockInput = I2CSequence[iSeq*SeqL+1]
%assign Address_ReadWrite = I2CSequence[iSeq*SeqL+9]
%assign NB = 7 + (3 * I2CSequence[iSeq*SeqL+2])	
%if AddressIsBlockInput
%assign address = "I2C%<I2CRef>%<I2C_Id>_Buff16[%<I2CSequence[iSeq*SeqL+6]>]"
%else
%assign address = %<I2CSequence[iSeq*SeqL+3]>
%endif
%assign N_Read = I2CSequence[iSeq*SeqL+8]	
%assign MCHP_I2Cx_State = I2C_WriteAddress(I2CRef,1,NB,address,Address_ReadWrite,AddressIsBlockInput,N_Read,MCHP_I2Cx_State)						
%assign WriteAddress_DataReadReady = I2C_WriteAddress_DataReadReady(I2CRef,1,NB,address,Address_ReadWrite,AddressIsBlockInput,N_Read,MCHP_I2Cx_State)			
%assign NextNACK = 0
%assign BreakRequired = 1
%if sequenceCompleted
%assign CheckSlave_Ack_required	= 2
%endif
%break
%case 64	
%assign BlockInput = I2CSequence[iSeq*SeqL+2]
%foreach repeat = seqRepeat
%if BlockInput == 1	
%assign repeat2max = 1
%else
%assign repeat2max = I2CSequence[iSeq*SeqL+4]
%endif
%foreach repeat2 = repeat2max
%if BreakRequired		
MCHP_I2C%<I2CRef>_State++;
break;
case %<MCHP_I2Cx_State>:
%assign MCHP_I2Cx_State = MCHP_I2Cx_State+1
%assign BreakRequired = 0
%endif
%if sequenceCompleted
%if CheckSlave_Ack_required >= 2				
MCHP_I2C%<I2CRef>_Seq%<I2C_Id>_Completed -= (int) %<I2C_isNACK(I2CRef)>;	/* decrement on NACK: sequence completed remains 0 */
%endif 			
%endif
%if (PreviousValue8 >= 0)
%assign writeTo = "I2C%<I2CRef>%<I2C_Id>_Buff8[%<PreviousValue8>]"
%<I2C_ReadDataRegister(I2CRef,MASTER,8,writeTo)>
%assign PreviousValue8 = -1	
%assign MCHP_I2Cx_State = MCHP_I2Cx_State + %<I2C_Write_NACK(I2CRef,MASTER,MCHP_I2Cx_State)>
%assign NextNACK = 1
%assign BreakRequired = 0
%endif
%if BlockInput == 1	
%assign value = "I2C%<I2CRef>%<I2C_Id>_Buff8[%<I2CSequence[iSeq*SeqL+6] + repeat * repeat2max + repeat2>]"
%<I2C_WriteDataRegister(I2CRef,MASTER,8,value)>
%if sequenceCompleted
%assign CheckSlave_Ack_required	= 2
%endif 							
%else 
%assign value = "%<MchpHex(I2CUserData[I2CSequence[iSeq*SeqL+3]+repeat2-(repeat2max+1)])>"
%<I2C_WriteDataRegister(I2CRef,MASTER,8,value)>
%if sequenceCompleted
%if (I2CUserData[I2CSequence[iSeq*SeqL+3]+repeat2-(repeat2max+1)] & 248 )  == 8	
%if CheckSlave_Ack_required == 1	
%assign CheckSlave_Ack_required	= 8		
%else
%assign CheckSlave_Ack_required	= 2		
%endif
%endif
%endif 							
%endif
%assign BreakRequired = 1
%endforeach
%endforeach
%break
%case 128	
%assign seqRepeat = seqRepeat - WriteAddress_DataReadReady	
%if WriteAddress_DataReadReady
%assign PreviousValue8 = I2CSequence[iSeq*SeqL+7]
%endif
%foreach repeat = seqRepeat
%if BreakRequired		
MCHP_I2C%<I2CRef>_State++;
break;
case %<MCHP_I2Cx_State>:
%assign MCHP_I2Cx_State = MCHP_I2Cx_State+1
%assign BreakRequired = 0
%endif
%if sequenceCompleted
%if CheckSlave_Ack_required >= 2				
MCHP_I2C%<I2CRef>_Seq%<I2C_Id>_Completed -= (int) %<I2C_isNACK(I2CRef)>;	/* decrement on NACK: sequence completed remains 0 */
%endif
%assign CheckSlave_Ack_required	= 0
%endif
%if (PreviousValue8 >= 0)
%assign writeTo = "I2C%<I2CRef>%<I2C_Id>_Buff8[%<PreviousValue8>]"
%<I2C_ReadDataRegister(I2CRef,MASTER,8,writeTo)>
%assign PreviousValue8 = -1	
%assign MCHP_I2Cx_State = MCHP_I2Cx_State + %<I2C_Write_ACK(I2CRef,MASTER,MCHP_I2Cx_State)>
%assign NextNACK = 0
%assign BreakRequired = 0
%endif
%<I2C_Receive(I2CRef,NextNACK)>
%assign NextNACK = 0
%assign PreviousValue8 = %<I2CSequence[iSeq*SeqL+7] + repeat + WriteAddress_DataReadReady>	
%assign BreakRequired = 1
%endforeach
%assign WriteAddress_DataReadReady = 0	
%break
%case 4 
%if BreakRequired		
MCHP_I2C%<I2CRef>_State++;
break;
case %<MCHP_I2Cx_State>:
%assign MCHP_I2Cx_State = MCHP_I2Cx_State+1
%assign BreakRequired = 0
%endif
%assign pinRef = I2CSequence[iSeq*SeqL+1]
%assign pinVal = I2CSequence[iSeq*SeqL+2]			
%if %<I2CSequence[iSeq*SeqL+2]> == 2
%<MCHP_ToggleOutputBit(pinRef,"")>
%else
%<MCHP_SetOutputBit(pinRef,pinVal,"")>  						
%endif
%break
%case 8 
/* Delay */
%if BreakRequired		
MCHP_I2C%<I2CRef>_State++;
break;
case %<MCHP_I2Cx_State>:
%assign MCHP_I2Cx_State = MCHP_I2Cx_State+1
%assign BreakRequired = 0
%endif
%assign time_s = %<I2CSequence[iSeq*SeqL+1]>
%assign param = %<I2CSequence[iSeq*SeqL+2]>
%<I2C_delay(time_s,param)>
%break
%case 16 
/* Call user Interrupt */
%if BreakRequired		
MCHP_I2C%<I2CRef>_State++;
break;
case %<MCHP_I2Cx_State>:
%assign MCHP_I2Cx_State = MCHP_I2Cx_State+1
%assign BreakRequired = 0
%endif
%if (Flag_AuthorizeReEnable == 0) && (iSeq == (nSeq-1) )	
/* This last interrupt from this I2C sequence could re-enabled itself (this I2C sequence) */
%if sequenceCompleted
MCHP_I2C%<I2CRef>_Seq%<I2C_Id>_Completed += 1;	/* is 1 only if no NACK were encountered. */			
%endif
%if ::MCHP_NumI2CBlocks[I2CRef] != 1
MCHP_I2C%<I2CRef>%<I2C_Id>_Request = 0;	/* This I2C sequence could be Re-Enabled */
%else
MCHP_I2C%<I2CRef>_State = 0;	/* I2C available  */
%endif
%assign Flag_AuthorizeReEnable = 1		
%endif
%assign cDatafilename = "MCHP_I2C%<I2CRef>_%<I2CSequence[iSeq*SeqL+1]>"	  
#ifdef Flag_%<cDatafilename>
%<DSB()>
%<cDatafilename>();
#else
#warning "No code were generated for at least one I2C interrupt present in an I2C sequence."
#endif
%endswitch
%endforeach
%if BreakRequired		
MCHP_I2C%<I2CRef>_State++;
break;
case %<MCHP_I2Cx_State>:
%assign MCHP_I2Cx_State = MCHP_I2Cx_State+1
%assign BreakRequired = 0
%endif
%if sequenceCompleted
%if CheckSlave_Ack_required >= 2
%assign CheckSlave_Ack_required	= 0
MCHP_I2C%<I2CRef>_Seq%<I2C_Id>_Completed -= (int) %<I2C_isNACK(I2CRef)>;	/* decrement on NACK: sequence completed remains 0 */
%endif
%endif
%if (PreviousValue8 >= 0)
%assign writeTo = "I2C%<I2CRef>%<I2C_Id>_Buff8[%<PreviousValue8>]"
%<I2C_ReadDataRegister(I2CRef,MASTER,8,writeTo)>				
%assign PreviousValue8 = -1	
%endif
%if (::MCHP_NumI2CBlocks[I2CRef] != 1)
%if (Flag_AuthorizeReEnable == 0)
%if sequenceCompleted
MCHP_I2C%<I2CRef>_Seq%<I2C_Id>_Completed += 1;	/* is 1 only if no NACK were encountered. */
%endif			
MCHP_I2C%<I2CRef>%<I2C_Id>_Request = 0;	/* This I2C sequence could be Re-Enabled */
MCHP_I2C%<I2CRef>_State = 0;
%assign Flag_AuthorizeReEnable = 1		
%else
MCHP_I2C%<I2CRef>_State = 0;
%endif
%else 
MCHP_I2C%<I2CRef>_Request = 0;	/* Reset counter for error */
%if sequenceCompleted
MCHP_I2C%<I2CRef>_Seq%<I2C_Id>_Completed += 1;	/* is 1 only if no NACK were encountered. */
%endif					
%if (Flag_AuthorizeReEnable == 0)
MCHP_I2C%<I2CRef>_State = 0; /* End of I2C Sequence. I2C is available for a new sequence */
%else
if (MCHP_I2C%<I2CRef>_State != 0)		
%assign cmt = "an User Interrupt has re-enabled this I2C block. The MCHP_I2C%<I2CRef>_State has been set within the interrupt. Force Re-enter Interrupt"
%<I2C_Trig_Interrupt(I2CRef,cmt)>
%endif
%endif
%if ::MCHP_NumI2CBlocks[I2CRef] > 1
Continue = (MCHP_I2C%<I2CRef>_Queue.head != MCHP_I2C%<I2CRef>_Queue.tail); /* One next sequence queued, start it now */
%endif
break;
%closefile I2C_InterruptFun
%assign ::MCHP_I2C_NextState[I2CRef] = MCHP_I2Cx_State
%endfunction
