%include "MCHP_Functions_Atomic.tlc"
%function MCHP_taskCheckOverrun_Exit(taskID) void
%openfile taskCheck
if (taskCounter[%<taskID>] == 0) { 		/* no task execution dropped: overrun on lower rate task will slow down higher rate task. Keep task Synchronisation */
if (Overrun.Flags%<taskID>) {
%if (%<::MASTER_BusyFlag> != -1)
%<Mchp_asm_Adec("BusyFlagRecursion")> 
%endif
%<MCHP_ProfileMCU("exit")>
%<MCHP_MCUOverload(taskID)>
%<MCHP_Scheduler_EXIT()>
}
event.Flags%<taskID> = 1U;
}
%closefile taskCheck
%return taskCheck
%endfunction
%function MCHP_taskCheckOverrun_Continue(taskID) void
%openfile taskCheck
if (taskCounter[%<taskID>] == 0) {  /* task dropped on overload */
event.Flags%<taskID> = 1U;
%openfile overload
%<MCHP_MCUOverload(taskID)>
%closefile overload
%if !WHITE_SPACE(overload)
if (Overrun.Flags%<taskID>)
{
%<overload>
}
%endif
}
%closefile taskCheck
%return taskCheck
%endfunction
%function MCHP_mrScheduler(InterruptPrefix,InterruptNumber,ChipIdN) void
%<MCHP_writeContextSwitchForSAME70()>
%openfile mrScheduler
{
__asm volatile ("     MRS R0, APSR    ");         /* Move into R0 the value of APSR (status flags) */
__asm volatile ("     PUSH {R0, LR}   ");         /* PUSH APSR and LR on the stack */	
__asm volatile ("     SUB SP, SP, #0x20");		/* create empty 32 bytes stack frame {R0 R1 R2 R3 R12 LR PC(return adr) xPSR}*/
__asm volatile ("     ADR R0,Call_isr_routine_in_thread_mode");	/* fake return address */
__asm volatile ("     NOP");
__asm volatile ("     STR R0,[SP, #24]");	/* Write to stack PC return address */
__asm volatile ("     MOV R0,#0x01");		/* R0 = 0x0000 0001 */
__asm volatile ("     LSL R0,#24");		/* R0 = 0x0100 0000 */
__asm volatile ("     STR R0,[SP, #28]");	/* Write to stack xPSR  */
__asm volatile ("     MOV R0,#0x6");		/* R0 = 0x0000 0006 */
__asm volatile ("     mvn r0, r0");		/* R0 = 0xFFFF FFF9 (b1001) 8thread mode - 4main stack */
__asm volatile ("     MOV LR, R0");		/* Write LR return mode (EXEC_RETURN) */
__asm volatile ("     BX LR");				/* Branch with EXEC_RETURN value: return from interrupt with created stack go to THREAD MODE */
__asm volatile ("Call_isr_routine_in_thread_mode:");
__asm volatile ("     BL MCHP_Scheduler");	/* Call function & save return address in LR (BL link) */
__asm volatile ("     ISB");				/* Instruction Barriere */
__asm volatile ("     SVC #0");			/* Call SVC handler to return to caller */
__asm volatile ("Unknown_Execution:");		/* Forever loop for SVC beeing serviced, go to HANDLER Mode  */
__asm volatile ("     B Unknown_Execution");
}
%closefile mrScheduler
%return mrScheduler
%endfunction
%function MCHP_writeContextSwitchForSAME70() void
%assign srcName = LibGetMdlSrcBaseName() + "_main"
%assign modelC  = LibCreateSourceFile("Source", "Custom", srcName )
%openfile tmpBuf
/* Multitasking wrapper */
/* SVC Interrupt service routine to restore the context: SVC_Handler */
/* SVC_Handler is used to return from the re-entrant scheduler function */
__attribute__ ((naked,aligned(4))) void SVCall_Handler(void) {
__asm volatile ("     MOVS r0, #0x4");
__asm volatile ("     MOV r1, LR");
__asm volatile ("     TST r0, r1");		/* values in MSP or PSP stack ? */
__asm volatile ("     BEQ stack_used_msp");
__asm volatile ("     MRS R0, PSP");		/* use Process Stack */
__asm volatile ("     B get_service_request");
__asm volatile ("stack_used_msp:");
__asm volatile ("     MRS R0, MSP");		/* use Main Stack */
__asm volatile ("get_service_request:");
__asm volatile ("     LDR R1, [R0, #24]");	/* Read return address from stack to check calling argument */
__asm volatile ("     SUB R1, R1, #0x2");	/* back to calling instruction (SVC #0) */
__asm volatile ("     LDRB R0, [R1]");		/* Load insstruction (SVC #0) */
__asm volatile ("     CMP R0, #0");		/* compare with argument #0 */
__asm volatile ("     BEQ svc_service_0");
__asm volatile ("     B Unknown_SVC_Request");
__asm volatile ("svc_service_0:");
__asm volatile ("     ADD SP, SP, #32");		/* Do not return to SVC caller but to thread. Remove SVC caller stack */
__asm volatile ("     POP {R0, R1}");			/* pop xPSR and PC(return address) */
__asm volatile ("     MSR APSR_nzcvq, R0");	/* Restore APSR */
__asm volatile ("     BX R1");
__asm volatile ("Unknown_SVC_Request:");
__asm volatile ("     B Unknown_SVC_Request");	
}	
__attribute__((externally_visible))	void MCHP_Scheduler()
%<MCHP_mrScheduler_m0p()>
%closefile tmpBuf
%<LibSetSourceFileSection(modelC,"Functions",tmpBuf)>
%endfunction
%function MCHP_mrScheduler_m0p() Output
%assign ::MASTER_BusyFlag = CAST("Number",RTWGenSettings.MASTER_BusyFlag)
%assign MASTER_BusyFlagPin = CAST("Number",%<::MASTER_BusyFlag % 32>)
%assign MASTER_BusyFlagLetter = STRINGOF([%<::MASTER_BusyFlag / 32 + 65>])
%assign MCHP_NEAR_MEM = Mchp_NEAR_MEM()
%assign tid01Eq = LibGetTID01EQ()
{ /* Scheduler */
%if (MASTER_BusyFlag != -1)
extern volatile uint_T BusyFlagRecursion %<MCHP_NEAR_MEM>;		
%endif
struct {
%foreach i = LibNumSynchronousSampleTimes()			
unsigned int Flags%<i> : 1;
%endforeach
} static volatile Overrun = {
%assign comma = ""
%foreach iTID = (LibNumSynchronousSampleTimes())  	
%<comma> .Flags%<iTID> = 0
%assign comma = ","
%endforeach		 		
};	    	
struct {
%foreach i = LibNumSynchronousSampleTimes()				
unsigned int Flags%<i> : 1;
%endforeach
} static volatile event = {
%assign comma = ""
%foreach iTID = (LibNumSynchronousSampleTimes())  	
%<comma> .Flags%<iTID> = 0
%assign comma = ","
%endforeach		 		
};	    	
%if SuppressMultiTaskScheduler
static  uint_T taskCounter[%<LibNumSynchronousSampleTimes()>] = %<FcnInitializeTaskCounter()>;
%endif
%if (%<::MASTER_BusyFlag> != -1)
/* Set busy flag */
%<Mchp_asm_Ainc("BusyFlagRecursion")> 
%<MCHP_SetOutputBit(MASTER_BusyFlag,1,"Set Busy Flag PIN")>			
%endif
/* Disable Scheduler but keep others interrupts active */	
%<Mchp_asm_DisableSchedulerInterrupt()>	 		
%<MCHP_GetModelInput(0)>
/* Check subrate overrun, set rates that need to run this time step*/
%foreach i = (%<LibNumSynchronousSampleTimes()-1>)			
%switch MCHP_SchedulerTaskOverload
%case "Queue"
%case "Skip"
%<MCHP_taskCheckOverrun_Continue(i+1)>
%break
%case "Delay"
%<MCHP_taskCheckOverrun_Exit(i+1)>
%break
%default
%error Scheduler Option %<MCHP_SchedulerTaskOverload> not recognized.
%endswitch
%endforeach
%if ExtMode
if (0U==(%<ERTStopCheck()>)) {
rtExtModeShutdown(%<NumSynchronousSampleTimes>);
}
%endif
/* Update task internal counters */
%<ERTMainGenSchedulerCode()>
%<::MCHP_TimeStep_BeforeExecution>
/* Re-Enable Interrupt. IPL value is 2 at this point */
%<Mchp_asm_EnableSchedulerInterrupt()>
event.Flags0 = 1;	/* Always execute task 0 */
/* Step the model for any subrate */
%foreach i = %<LibNumSynchronousSampleTimes()>			
/* ---------- Handle Task %<i> ---------- */		
%<MCHP_taskExecute(i,0)>
%endforeach
%if (%<::MASTER_BusyFlag> != -1)
/* Release busy flag */
%<Mchp_asm_Adec("BusyFlagRecursion")> 
if (0U == BusyFlagRecursion)
%<MCHP_SetOutputBit(MASTER_BusyFlag,0,"Release Busy Flag PIN")>	
%endif
%<MCHP_InterruptEpilog()>
}
%endfunction
%function MCHP_Scheduler_EXIT() Output
{
%<MCHP_InterruptEpilog()>
return;
}
%endfunction