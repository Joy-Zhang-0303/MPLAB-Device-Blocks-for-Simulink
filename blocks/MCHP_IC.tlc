%implements  MCHP_IC  "C"
%include "MCHP_Functions.tlc"
%function BlockInstanceSetup(block, system) void
%assign Channels =  MchpVector(block.RTWdata.Channels)
%foreach idx = SIZE(Channels,1)
%<HARMONY_RegisterPeripheral("IC",Channels[idx],block)>	
%endforeach
%endfunction
%function Start(block, system) Output
%assign IntPriority = CAST("Number",block.RTWdata.IntPriority)
%assign ICtype = CAST("Number",block.RTWdata.ICtype)
%assign Channels =  MchpVector(block.RTWdata.Channels)
%assign RefTimers =  MchpVector(block.RTWdata.RefTimers)
%assign Channel_UP_Down_Periode =  MchpVector(block.RTWdata.Channel_UP_Down_Periode)
%assign ChangeDetected =  MchpVector(block.RTWdata.ChangeDetected)
%assign ICxCON1 = MchpVector(block.RTWdata.ICxCON1)
%assign ICxCON2 =  MchpVector(block.RTWdata.ICxCON2)
%if ICtype == 1
%assign ICTypeRef = "1"
%else
%assign ICTypeRef = ""
%endif
%if ICtype == 1
%foreach idx = SIZE(Channels,1)
%if ICxCON1[idx] == -1
%continue
%endif
IC%<Channels[idx]>CON1 = %<MchpHex(ICxCON1[idx])>;
%if %<ICxCON2[idx]> != -1
IC%<Channels[idx]>CON2 = %<MchpHex(ICxCON2[idx])>;
%endif
%endforeach
%else
%foreach idx = SIZE(Channels,1)
%if ICxCON1[idx] == -1
%continue
%endif
IC%<Channels[idx]>CON%<ICTypeRef> = %<MchpHex(ICxCON1[idx])>;
%endforeach
%endif
/* Set-up Input Capture Interruption */
%foreach idx = SIZE(Channels,1)
%if ICxCON1[idx] == -1
%continue
%endif
%<MCHP_SFR( "IC%<Channels[idx]>IF" , 0 , "Clear interrupt Flag" )>
%<MCHP_SFR( "IC%<Channels[idx]>IP" , IntPriority , "Set interrupt Priority" )>
%<MCHP_SFR( "IC%<Channels[idx]>IE" , 1 , "Enable Interrupt" )>
%endforeach
%assign ChipIdN =  CAST("String",RTWGenSettings.ChipIdN)
%assign ChipIdN = FEVAL("str2num",ChipIdN)
%assign ChipIdN = FEVAL("int32",ChipIdN)		
%openfile dspicfun = "MCHP_IC_Interrupt.c"
#include "%<LibGetMdlPubHdrBaseName()>.h"
#include "%<LibGetMdlPubHdrBaseName()>_private.h"
/* Input Capture - Data-Interrupt: %<Name> */
%foreach idx = SIZE(Channels,1)
%if ICxCON1[idx] == -1
%continue
%endif
%if ((Channel_UP_Down_Periode[idx] & 1) != 0)        
volatile uint16_T MCHP_ic%<Channels[idx]>up;
%endif
%if ((Channel_UP_Down_Periode[idx] & 2) != 0)        
volatile uint16_T MCHP_ic%<Channels[idx]>down;
%endif
%if ((Channel_UP_Down_Periode[idx] & 4) != 0)        
volatile uint16_T MCHP_ic%<Channels[idx]>RisingPeriode;
%endif
%if ((Channel_UP_Down_Periode[idx] & 8) != 0)        
volatile uint16_T MCHP_ic%<Channels[idx]>FallingPeriode;
%endif
%if (ChangeDetected[idx] != 0)
volatile uint16_T MCHP_ic%<Channels[idx]>ChangeDetectedFlag;
%endif
%endforeach
/* Implement Input Capture Interrupts if required */
%foreach idx = SIZE(Channels,1)
%if ICxCON1[idx] == -1
%continue
%endif
%if ::isPIC32	
%<Mchp_Interrupt32(IntPriority,1,0,"INPUT_CAPTURE_%<Channels[idx]>_VECTOR",block)>  
%else
%<Mchp_Interrupt16(IntPriority,Mchp_No_auto_psv()	,"IC%<Channels[idx]>Interrupt",block)> 			
%endif
{
static uint16_T IC%<Channels[idx]>BUF_Old;
uint16_T IC%<Channels[idx]>BUF_New;
%<MCHP_ProfileMCU("enter")>
while(IC%<Channels[idx]>CON%<ICTypeRef>bits.ICBNE == 1) IC%<Channels[idx]>BUF_New = IC%<Channels[idx]>BUF; /* take the last value */
%if ((Channel_UP_Down_Periode[idx] & (1+2)) != 0)        
if (IC%<Channels[idx]>CON%<ICTypeRef> & 1) 				/* This is a rising edge */
{
IC%<Channels[idx]>CON%<ICTypeRef> &= 0xFFFE;			/* detect next falling edge */
%if (Channel_UP_Down_Periode[idx] & 2)				
MCHP_ic%<Channels[idx]>down = IC%<Channels[idx]>BUF_New - IC%<Channels[idx]>BUF_Old; /* Compute Down time */
%endif
%if (Channel_UP_Down_Periode[idx] == 5)
MCHP_ic%<Channels[idx]>RisingPeriode = IC%<Channels[idx]>BUF_New - IC%<Channels[idx]>BUF_Old; /* Compute Periode */
IC%<Channels[idx]>BUF_Old = IC%<Channels[idx]>BUF_New;	/* Start New Measurement */	
%endif
%if (ChangeDetected[idx] & 1)
MCHP_ic%<Channels[idx]>ChangeDetectedFlag++;
%endif
}
else 			/* falling edge */
{
IC%<Channels[idx]>CON%<ICTypeRef> |= 1;		/* detect next rising edge */
%if (Channel_UP_Down_Periode[idx] & 1)        
MCHP_ic%<Channels[idx]>up = IC%<Channels[idx]>BUF_New - IC%<Channels[idx]>BUF_Old; /* Compute Up time */
%endif
%if (Channel_UP_Down_Periode[idx] == 10)
MCHP_ic%<Channels[idx]>FallingPeriode = IC%<Channels[idx]>BUF_New - IC%<Channels[idx]>BUF_Old; /* Compute Periode */
IC%<Channels[idx]>BUF_Old = IC%<Channels[idx]>BUF_New;	/* Start New Measurement */	
%endif
%if (ChangeDetected[idx] & 2)
MCHP_ic%<Channels[idx]>ChangeDetectedFlag++;
%endif
}
%else 
%if ((Channel_UP_Down_Periode[idx] & 4) != 0)
MCHP_ic%<Channels[idx]>RisingPeriode = IC%<Channels[idx]>BUF_New - IC%<Channels[idx]>BUF_Old;
%if (ChangeDetected[idx] & 1)
MCHP_ic%<Channels[idx]>ChangeDetectedFlag++;		
%endif
%elseif ((Channel_UP_Down_Periode[idx] & 8) != 0)
MCHP_ic%<Channels[idx]>FallingPeriode = IC%<Channels[idx]>BUF_New - IC%<Channels[idx]>BUF_Old;
%if (ChangeDetected[idx] & 2)
MCHP_ic%<Channels[idx]>ChangeDetectedFlag++;		
%endif
%endif
%endif
%if ((Channel_UP_Down_Periode[idx] != 5) && (Channel_UP_Down_Periode[idx] != 10))
IC%<Channels[idx]>BUF_Old = IC%<Channels[idx]>BUF_New;
%endif
%if (Channel_UP_Down_Periode[idx]  == 0)
%if (ChangeDetected[idx] != 0)
MCHP_ic%<Channels[idx]>ChangeDetectedFlag++;
%endif
%endif
%<MCHP_ProfileMCU("exitUpdate")>
%<MCHP_SFR( "IC%<Channels[idx]>IF" , 0 , "Clear Interrupt Flag" )>				
}
%endforeach
%closefile dspicfun
%openfile buffer
%foreach idx = SIZE(Channels,1)
%if ICxCON1[idx] == -1
%continue
%endif
%if ((Channel_UP_Down_Periode[idx] & 1) != 0)        
extern volatile uint16_T MCHP_ic%<Channels[idx]>up;
%endif
%if ((Channel_UP_Down_Periode[idx] & 2) != 0)        
extern volatile uint16_T MCHP_ic%<Channels[idx]>down;
%endif
%if ((Channel_UP_Down_Periode[idx] & 4) != 0)        
extern volatile uint16_T MCHP_ic%<Channels[idx]>RisingPeriode;
%endif
%if ((Channel_UP_Down_Periode[idx] & 8) != 0)        
extern volatile uint16_T MCHP_ic%<Channels[idx]>FallingPeriode;
%endif
%if (ChangeDetected[idx] != 0)
extern volatile uint16_T MCHP_ic%<Channels[idx]>ChangeDetectedFlag;
%endif
%endforeach
%closefile buffer
%<LibCacheFunctionPrototype(buffer)>
%endfunction
%function Outputs(block, system) Output
/* S-Function "dsPIC_PWM_IC" Block: %<Name> */
%assign ICtype = CAST("Number",block.RTWdata.ICtype)
%assign Channels = MchpVector(block.RTWdata.Channels)
%assign Channel_UP_Down_Periode = MchpVector(block.RTWdata.Channel_UP_Down_Periode)
%assign ChangeDetected = MchpVector(block.RTWdata.ChangeDetected)
%assign ICxCON1 = MchpVector(block.RTWdata.ICxCON1)
%assign portOut = 0
%foreach idx = SIZE(Channels,1)
%if ICxCON1[idx] == -1
%continue
%endif
%if ((Channel_UP_Down_Periode[idx] & 1) != 0)        
%assign u = LibBlockOutputSignal(portOut, "", "", 1)
%<u> = MCHP_ic%<Channels[idx]>up;
%assign portOut = portOut+1
%endif
%if ((Channel_UP_Down_Periode[idx] & 2) != 0)        
%assign u = LibBlockOutputSignal(portOut, "", "", 1)
%<u> = MCHP_ic%<Channels[idx]>down;
%assign portOut = portOut+1
%endif
%if ((Channel_UP_Down_Periode[idx] & 4) != 0)        
%assign u = LibBlockOutputSignal(portOut, "", "", 1)
%<u> = MCHP_ic%<Channels[idx]>RisingPeriode;
%assign portOut = portOut+1
%endif
%if ((Channel_UP_Down_Periode[idx] & 8) != 0)        
%assign u = LibBlockOutputSignal(portOut, "", "", 1)
%<u> = MCHP_ic%<Channels[idx]>FallingPeriode;
%assign portOut = portOut+1
%endif
%if (ChangeDetected[idx] != 0)        
%assign u = LibBlockOutputSignal(portOut, "", "", 1)
%<u> = MCHP_ic%<Channels[idx]>ChangeDetectedFlag;
MCHP_ic%<Channels[idx]>ChangeDetectedFlag = 0;
%assign portOut = portOut+1
%endif
%endforeach
%endfunction
%function Update(block, system) Output
%endfunction
