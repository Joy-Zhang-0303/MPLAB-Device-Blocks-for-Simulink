
%include "MCHP_UART_Tx_PIC_FunUtils.tlc"
%function MCHP_UART_Config_Tx_DMA(block,system) Output
%assign MEMORY_DMA_QUALIFIER = MchpDMA_MemoryQualifier()	
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%assign UART_NAME = "UART%<UARTRef>"
%assign TX_IMPLEMENTATION = MchpVector(RTWGenSettings.UART_TX_IMPLEMENTATION)
%assign TX_IMPLEMENTATION = TX_IMPLEMENTATION[UARTRef-1]		
%assign RX_IMPLEMENTATION = MchpVector(RTWGenSettings.UART_RX_IMPLEMENTATION)
%assign RX_IMPLEMENTATION = RX_IMPLEMENTATION[UARTRef-1]		
%assign InitSequence_enable = CAST("Number",block.RTWdata.InitSequence_enable)
%assign UART_HALF_DUPLEX_MODE = MchpVector(RTWGenSettings.UART_HALF_DUPLEX_MODE)
%assign UART_HALF_DUPLEX_MODE = UART_HALF_DUPLEX_MODE[UARTRef-1]
%if ::DOS_03076_uart_protocol_upb_v1_16bit
%assign UTXBF = "U%<UARTRef>" +  "STAHbits.UTXBF"
%else
%assign UTXBF = "U%<UARTRef>" + "STAbits.UTXBF"
%endif	 	
%switch TX_IMPLEMENTATION
%case 3 
%assign TX_INT_PRIORITY = CAST("Number",block.RTWdata.TX_INT_PRIORITY)
MCHP_%<UART_NAME>_Tx.BufferAB = 0;
MCHP_%<UART_NAME>_Tx.overload = 0;			
%case 4	
MCHP_%<UART_NAME>_Tx.tail = 0;		
%assign UART_TX_DMACHANNEL = MchpVector(RTWGenSettings.UART_TX_DMACHANNEL)
%assign TX_DMA_CHANNEL = UART_TX_DMACHANNEL[UARTRef-1]		
%assign TX_BufferSize = CAST("Number",block.RTWdata.TX_DMA_SIZE)
%assign MEMORY_DMA_ATTRIBUTE = MchpDMA_MemoryAttribute(%<TX_BufferSize>)			
%switch ::ChipIs
%case "PIC32" 
%switch ::ChipIdL1
%case "MK"
%assign DMAREQ_TAB = CAST("Vector",[-1 ,40, 58, 64, 67 , 70])			
%break
%case "MZ"
%assign DMAREQ_TAB = CAST("Vector",[-1 ,114, 147, 159, 172 , 181, 190])			
%endswitch
DMACONSET = 0x8000;	/* Enable DMA Controller */
DCH%<TX_DMA_CHANNEL>CON = 2;	/* Priority, within [0-3] */				
DCH%<TX_DMA_CHANNEL>ECON = (_UART%<UARTRef>_TX_VECTOR << 8)  + %<MchpHex( (1 << 4) ) >;	
DCH%<TX_DMA_CHANNEL>SSIZ = %<TX_BufferSize >;	/* %<TX_BufferSize> DMA Requests */ 
DCH%<TX_DMA_CHANNEL>DSIZ = 1;	/* Destination size is one byte */
DCH%<TX_DMA_CHANNEL>CSIZ = 1;	/* one byte per uart transfert request */
DCH%<TX_DMA_CHANNEL>DSA = (unsigned int) &U%<UARTRef>TXREG & 0x1FFFFFFF;	/* Physical Address for TX register */	
%if TX_IMPLEMENTATION != 3 
DCH%<TX_DMA_CHANNEL>SSA = (unsigned int) MCHP_%<UART_NAME>_Tx_buffer & 0x1FFFFFFF;  /*  Physical address for Tx Buffer */									
%endif
DCH%<TX_DMA_CHANNEL>INTCLR = 0x00FF00FF; 	/* Clear existing event, disable all interrupts */
DCH%<TX_DMA_CHANNEL>INTSET = 0x00090000; 	/* Enable Block Complete interrupt and error interrupts */				
%break
%case "dsPIC"
%assign DMAREQ_TAB = CAST("Vector",[-1 ,12, 31, 83, 89])			
DMA%<TX_DMA_CHANNEL>CON = 0x6001 ;
DMA%<TX_DMA_CHANNEL>CNT = %<TX_BufferSize - 1 >;	/* %<TX_BufferSize> DMA Requests */ 
DMA%<TX_DMA_CHANNEL>REQ = %<MchpHex(DMAREQ_TAB[UARTRef])>;	
DMA%<TX_DMA_CHANNEL>PAD = (volatile unsigned int) &U%<UARTRef>TXREG;
%switch ::ChipIdL1
%case "HJ"
%case "FJ"
%if TX_IMPLEMENTATION != 3 
DMA%<TX_DMA_CHANNEL>STA = (uint16_T) (%<MEMORY_DMA_QUALIFIER> uint8_T*) &MCHP_%<UART_NAME>_Tx_buffer ;
%endif				
%break
%case "EP"	
%case "EV"						
%if TX_IMPLEMENTATION != 3 
DMA%<TX_DMA_CHANNEL>STAL = (uint16_T) (%<MEMORY_DMA_QUALIFIER> uint8_T*) &MCHP_%<UART_NAME>_Tx_buffer ; 
DMA%<TX_DMA_CHANNEL>STAH = 0x0000;					
%endif
%break			
%endswitch
%break
%default
%error("Chip %<::ChipIs> not recognized (UART Rx DMA block)")
%endswitch
%if TX_IMPLEMENTATION == 3	
%<MCHP_SFR( "DMA%<TX_DMA_CHANNEL>IP" , TX_INT_PRIORITY , "Set DMA Interrupt priority" )>
%<MCHP_SFR( "DMA%<TX_DMA_CHANNEL>IF" , 0 , "Clear Interrupt flag" )>
%<MCHP_SFR( "DMA%<TX_DMA_CHANNEL>IE" , 0 , "Disable Interrupt" )>
%if ::isdsPIC	
%<MCHP_SFR(  "U%<UARTRef>TXIP"  , TX_INT_PRIORITY  , " Tx Interrupt priority set to %<TX_INT_PRIORITY >" )>  
%<MCHP_SFR(  "U%<UARTRef>TXIF"  , 0 				   , "" )> 		
%<MCHP_SFR(  "U%<UARTRef>TXIE"  , 0 				   , "" )> 		
%endif
%endif
%break
%endswitch
%openfile dspicfun = "MCHP_%<UART_NAME>_Tx_Interrupt.c"				
#include "%<LibGetMdlPubHdrBaseName()>.h"
#include "%<LibGetMdlPubHdrBaseName()>_private.h"
/* UART Config %<Name> - DMA Interrupt for %<UART_NAME> */ 		
%switch TX_IMPLEMENTATION
%case 3 
%openfile buffer
/* Declare UART%<UARTRef> Tx DMA Buffer Structure */
extern MCHP_%<UART_NAME>_TxStr MCHP_%<UART_NAME>_Tx;
extern %<MEMORY_DMA_QUALIFIER> uint8_T 		MCHP_%<UART_NAME>_Tx_bufferA[Tx_BUFF_SIZE_%<UART_NAME>] %<MEMORY_DMA_ATTRIBUTE> ;
extern %<MEMORY_DMA_QUALIFIER> uint8_T 		MCHP_%<UART_NAME>_Tx_bufferB[Tx_BUFF_SIZE_%<UART_NAME>] %<MEMORY_DMA_ATTRIBUTE> ;
%closefile buffer
%<LibCacheExtern(buffer)>			
%openfile buffer
/* Declare UART%<UARTRef> Tx DMA Buffer Structure */
#define Tx_BUFF_SIZE_%<UART_NAME> (%<TX_BufferSize>)
typedef struct MCHP_%<UART_NAME>_TxStr{
volatile uint_T BufferAB : 1; 				
volatile uint_T tail;								/* tail is the index for the next value to be read from the Circular buffer */				
volatile uint_T overload;							/* head is the index for the next value to be written into the buffer */
}  MCHP_%<UART_NAME>_TxStr;
%closefile buffer
%<LibCacheTypedefs(buffer)>				
/* Declare UART%<UARTRef> Tx DMA Buffer Structure */
MCHP_%<UART_NAME>_TxStr MCHP_%<UART_NAME>_Tx;
%<MEMORY_DMA_QUALIFIER> uint8_T 		MCHP_%<UART_NAME>_Tx_bufferA[Tx_BUFF_SIZE_%<UART_NAME>] %<MEMORY_DMA_ATTRIBUTE> ;	/* Declare DMA buffer outside the structure which should not be in the DMA dedicated memory */
%<MEMORY_DMA_QUALIFIER> uint8_T 		MCHP_%<UART_NAME>_Tx_bufferB[Tx_BUFF_SIZE_%<UART_NAME>] %<MEMORY_DMA_ATTRIBUTE> ;
%break
%case 4 
%openfile buffer
/* Declare UART%<UARTRef> Tx DMA Buffer Structure */
extern MCHP_%<UART_NAME>_TxStr MCHP_%<UART_NAME>_Tx;
extern %<MEMORY_DMA_QUALIFIER> uint8_T 		MCHP_%<UART_NAME>_Tx_buffer[Tx_BUFF_SIZE_%<UART_NAME>] %<MEMORY_DMA_ATTRIBUTE> ;
%closefile buffer
%<LibCacheExtern(buffer)>			
%openfile buffer
/* Declare UART%<UARTRef> Tx DMA Buffer Structure */
#define Tx_BUFF_SIZE_%<UART_NAME> (%<TX_BufferSize>)
typedef struct MCHP_%<UART_NAME>_TxStr{
volatile uint_T  		tail;									/* tail is the index for the next value to be read from the buffer */				
}  MCHP_%<UART_NAME>_TxStr;
%closefile buffer
%<LibCacheTypedefs(buffer)>				
/* Declare UART%<UARTRef> Tx DMA Buffer Structure */
MCHP_%<UART_NAME>_TxStr MCHP_%<UART_NAME>_Tx;
%<MEMORY_DMA_QUALIFIER> uint8_T 		MCHP_%<UART_NAME>_Tx_buffer[Tx_BUFF_SIZE_%<UART_NAME>] %<MEMORY_DMA_ATTRIBUTE> ; /* Declare DMA buffer outside the structure which should not be in the DMA dedicated memory */
%break	
%endswitch
%switch TX_IMPLEMENTATION
%case 3 
%if ::isPIC32
%<Mchp_Interrupt32(TX_INT_PRIORITY,1,0,"DMA%<TX_DMA_CHANNEL>_VECTOR",block)>  
%else								
%<Mchp_Interrupt16(TX_INT_PRIORITY,Mchp_No_auto_psv(),"DMA%<TX_DMA_CHANNEL>Interrupt",block)> 						
%endif
{
%if ::isPIC32
DCH%<TX_DMA_CHANNEL>INTCLR = 0xFF;	/* Clear the DMA Channel interrupt flag*/	
%endif
%<MCHP_SFR( "DMA%<TX_DMA_CHANNEL>IE" , 0 , "Disable Interrupt" )>
%<MCHP_SFR( "DMA%<TX_DMA_CHANNEL>IF" , 0 , "Clear Interrupt flag" )>
%<MCHP_ProfileMCU("enter")>	
%if ::isPIC32
/* If still ongoing DMA Transfer. DMA interrupt comes too early. straight start of another transfer would corrupt data. */
while(%<UTXNotEmpty(block)>); 	/* Wait for UART buffer to be empty. */
%<UART_Tx_DMA_Send_SwitchBuffer(UART_NAME,TX_DMA_CHANNEL,::ChipIdN,::ChipIdL1)>
MCHP_%<UART_NAME>_Tx.tail = 0;	
MCHP_%<UART_NAME>_Tx.overload = 0;				
%else
/* If still ongoing DMA Transfer. DMA interrupt comes too early. straight start of another transfer would corrupt data. */
%<MCHP_SFR(  "U%<UARTRef>TXIF"  , 0 				   , "")>
if (%<UTXNotEmpty(block)>) {
%<MCHP_SFR(  "U%<UARTRef>TXIE" , 1 				   , "Enable Tx interrupt. We wait one empty place in Tx buffer to re-enable DMA transfert.")>
} else {
%<UART_Tx_DMA_Send_SwitchBuffer(UART_NAME,TX_DMA_CHANNEL,::ChipIdN,::ChipIdL1)>					
MCHP_%<UART_NAME>_Tx.tail = 0;	
MCHP_%<UART_NAME>_Tx.overload = 0;					
}		
%endif		
%<MCHP_ProfileMCU("exitUpdate")>							
}	/* end of interrupt */		
%if ::isdsPIC			
%<Mchp_Interrupt16(TX_INT_PRIORITY,Mchp_No_auto_psv(),"U%<UARTRef>TXInterrupt",block)> 			
{
%<MCHP_SFR(  "U%<UARTRef>TXIE"  , 0 				   , "Disable UART Tx Interrupt ")>
%<MCHP_ProfileMCU("enter")>	
/* We can re-enable DMA transfert from this UART Tx interrupt. We are sure there is one empty space in the UART Tx buffer. */
%<UART_Tx_DMA_Send_SwitchBuffer(UART_NAME,TX_DMA_CHANNEL,::ChipIdN,::ChipIdL1)>					
MCHP_%<UART_NAME>_Tx.tail = 0;	
MCHP_%<UART_NAME>_Tx.overload = 0;					
%<MCHP_ProfileMCU("exitUpdate")>
} /* End of interrupt */
%endif
%break
%case 4 
%break	
%endswitch
%closefile dspicfun
%endfunction