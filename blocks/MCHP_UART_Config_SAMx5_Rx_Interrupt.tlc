
%include "MCHP_UART_Rx_SAMx5_FunUtils.tlc"
%function MCHP_UART_Config_Rx_Interrupt(block,system) Output
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%assign UART_NAME = UART_Rx_get_UART_NAME(block)
%assign INTERRUPT_Tx_name = "SERCOM%<UARTRef-1>_0"	
%assign INTERRUPT_Rx_name = "SERCOM%<UARTRef-1>_2"	
%assign RX_IMPLEMENTATION = MchpVector(RTWGenSettings.UART_RX_IMPLEMENTATION)
%assign RX_IMPLEMENTATION = RX_IMPLEMENTATION[UARTRef-1]		
%assign InitSequence_enable = CAST("Number",block.RTWdata.InitSequence_enable)
%assign UART_HALF_DUPLEX_MODE = MchpVector(RTWGenSettings.UART_HALF_DUPLEX_MODE)
%assign UART_HALF_DUPLEX_MODE = UART_HALF_DUPLEX_MODE[UARTRef-1]
%assign RX_INT_PRIORITY = CAST("Number",block.RTWdata.RX_INT_PRIORITY)
%assign RX_BufferSize = CAST("Number",block.RTWdata.RX_CIRCULAR_SIZE)
%openfile buffer
/* Declare UART%<UARTRef> Rx Circular Buffer Structure */
#define Rx_BUFF_SIZE_%<UART_NAME> (%<RX_BufferSize>)
typedef struct MCHP_%<UART_NAME>_RxStr{
volatile uint8_T buffer[Rx_BUFF_SIZE_%<UART_NAME>];			/* Size Rx_BUFF_SIZE_%<UART_NAME> is %<RX_BufferSize> */
volatile uint_T  tail;					/* tail is the index for the next value to be written into the Circular buffer */
volatile uint_T  head;					/* head is the index for the next value to be read from the Circular buffer */ 
}  MCHP_%<UART_NAME>_RxStr;
/* To read the UART%<UARTRef> Rx Circular with a custom code: read the next value: buffer[head], then increment head index by 1 modulo Rx_BUFF_SIZE_%<UART_NAME> (=%<RX_BufferSize>).
code example:
if %<URXNotEmpty(block)>
if (MCHP_%<UART_NAME>_Rx.tail != MCHP_%<UART_NAME>_Rx.head)	{  		// is buffer not empty ?
output = (uint8_T) MCHP_%<UART_NAME>_Rx.buffer[MCHP_%<UART_NAME>_Rx.head ++];     // Read one char 	   	
MCHP_%<UART_NAME>_Rx.head &= (Rx_BUFF_SIZE_%<UART_NAME>-1); 	// modulo : use a simple bitewise "and" operator as <Rx_BUFF_SIZE_%<UART_NAME>> is a power of 2			
}
*/ 			 			 		 								
%closefile buffer
%<LibCacheTypedefs(buffer)>	
%openfile dspicfun = "MCHP_%<UART_NAME>_Rx_Interrupt.c"				
#include "%<LibGetMdlPubHdrBaseName()>.h"
#include "%<LibGetMdlPubHdrBaseName()>_private.h"
MCHP_%<UART_NAME>_RxStr MCHP_%<UART_NAME>_Rx = { .head = 0, .tail = 0}; /* %<UART_NAME> Rx FIFO */
%openfile buffer
extern MCHP_%<UART_NAME>_RxStr MCHP_%<UART_NAME>_Rx;
%closefile buffer
%<LibCacheExtern(buffer)>
void %<INTERRUPT_Rx_name>_Handler(void)
{
%<MCHP_InterruptProlog()>
uint_T Tmp;
%<MCHP_ProfileMCU("enter")>
Tmp = ~(MCHP_%<UART_NAME>_Rx.tail - MCHP_%<UART_NAME>_Rx.head);		/* head - tail - 1 */ 
Tmp &= (Rx_BUFF_SIZE_%<UART_NAME>-1);	/* Tmp =  (head - tail - 1) modulo buffersize Rx_BUFF_SIZE_%<UART_NAME>) ; tmp <~ Rx_BUFF_SIZE_%<UART_NAME> - (head - tail) - 1*/			
while %<URXNotEmpty(block)>
{
if (Tmp--) {	
MCHP_%<UART_NAME>_Rx.buffer[MCHP_%<UART_NAME>_Rx.tail] = (uint8_T) %<UART_Rx_ReadRegister(block)>;
MCHP_%<UART_NAME>_Rx.tail = (MCHP_%<UART_NAME>_Rx.tail+1) & (Rx_BUFF_SIZE_%<UART_NAME>-1);
} else {
uint8_T a;
do a = %<UART_Rx_ReadRegister(block)>;
while %<URXNotEmpty(block)>;
break;
}
}
%<MCHP_ProfileMCU("exitUpdate")>
%<MCHP_InterruptEpilog()>
}	
%closefile dspicfun
%endfunction