%implements  MCHP_QEI  "C"
%include "MCHP_Functions.tlc"
%function Start(block, system) Output
%assign ChipIdL1 = CAST("String",RTWGenSettings.ChipIdL1)
%assign ChipIdL2 = CAST("String",RTWGenSettings.ChipIdL2)
%assign ChipIdL3 = CAST("String",RTWGenSettings.ChipIdL3)
%assign ChipIdN = MchpVector(RTWGenSettings.ChipIdN)
%assign QEI_Type = CAST("Number",block.RTWdata.QEI_Type)
%assign QEI_REF012 = CAST("Number",block.RTWdata.QEI_REF)
%assign QEIxCON = CAST("Number",block.RTWdata.QEIxCON)
%assign QEIxIOC = CAST("Number",block.RTWdata.QEIxIOC)
%assign QEIxICH = CAST("Number",block.RTWdata.QEIxICH)
%assign QEIxICL = CAST("Number",block.RTWdata.QEIxICL)
%assign QEIxLECH = CAST("Number",block.RTWdata.QEIxLECH)
%assign QEIxLECL = CAST("Number",block.RTWdata.QEIxLECL)
%assign QEIxGECH = CAST("Number",block.RTWdata.QEIxGECH)
%assign QEIxGECL = CAST("Number",block.RTWdata.QEIxGECL)
%assign QEI_IP = CAST("Number",block.RTWdata.QEI_IP)
%assign DOS_01494_qei_32b_upb_v1 = CAST("Number",block.RTWdata.DOS_01494_qei_32b_upb_v1)	
%if QEI_REF012 == 0
%assign QEI_REF = ""		
%else
%assign QEI_REF = QEI_REF012
%endif
/* Initialize QEI %<QEI_REF> Peripheral */
%if QEI_Type == 16
%assign MAXxCNT = CAST("Number",block.RTWdata.MAXxCNT)
MAX%<QEI_REF>CNT = %<MAXxCNT>;
DFLT%<QEI_REF>CON = %<MchpHex(QEIxIOC)>;
QEI%<QEI_REF>CON = %<MchpHex(QEIxCON)>;
%if QEI_IP != -1
%if QEI_REF012 == 1
%openfile buffer
#if !defined(_QEI1IF) && defined(_QEIIF)
#define _QEI1IF _QEIIF
#define _QEI1IE _QEIIE
#define _QEI1IP _QEIIP
#define _QEI1Interrupt _QEIInterrupt
#endif
%closefile buffer
%<LibCacheDefine(buffer)>
%endif
_QEI%<QEI_REF>IP = %<QEI_IP>;
_QEI%<QEI_REF>IF = 0;
_QEI%<QEI_REF>IE = 1; /* Enable Interrupt */
%openfile buffer
volatile extern uint16_T  MCHP_QEI%<QEI_REF>_Count;
%closefile buffer
%<LibCacheExtern(buffer)>
%openfile dspicfun = "MCHP_QEI%<QEI_REF>_Interrupt.c"
#include "%<LibGetMdlPubHdrBaseName()>.h"
#include "%<LibGetMdlPubHdrBaseName()>_private.h"
/* QEI - Interrupt: %<Name> */
volatile uint16_T  MCHP_QEI%<QEI_REF>_Count ;
%if %<QEI_IP> == 5
%assign shadow = "__shadow__,"
%else
%assign shadow = ""
%endif
%<Mchp_Interrupt16(QEI_IP,Mchp_No_auto_psv(),"QEI%<QEI_REF>Interrupt",block)> 		
{
_QEI%<QEI_REF>IF = 0;	/* Clear Interrupt Flag */
%<MCHP_ProfileMCU("enter")>
if (QEI%<QEI_REF>CONbits.UPDN == 1) /* Use direction for detecting upward or downard turn count */
MCHP_QEI%<QEI_REF>_Count++;
else
MCHP_QEI%<QEI_REF>_Count--;
%<MCHP_ProfileMCU("exitUpdate")>
}
%closefile dspicfun
%endif
%else	
%if QEIxICL != -1
%if DOS_01494_qei_32b_upb_v1 
QEI%<QEI_REF>ICC = %<MchpHex(QEIxICH*65536 + QEIxICL)>; /* Initialisation Value */
%else
QEI%<QEI_REF>ICH = %<MchpHex(QEIxICH)>;			/* Initialisation Value (High) */
QEI%<QEI_REF>ICL = %<MchpHex(QEIxICL)>;			/* Initialisation Value (Low) */
%endif
%endif
%if QEIxLECL != -1
%if DOS_01494_qei_32b_upb_v1 
QEI%<QEI_REF>CMPL = %<MchpHex(QEIxLECH * 65536 + QEIxLECL)>;	/* Lower bound */
QEI%<QEI_REF>ICC  = %<MchpHex(QEIxGECH * 65536 + QEIxGECL)>;	/* Upper bound */			
%else	
QEI%<QEI_REF>LECH = %<MchpHex(QEIxLECH)>;	/* Lower bound (High)*/
QEI%<QEI_REF>LECL = %<MchpHex(QEIxLECL)>;	/* Lower bound (Low)*/
QEI%<QEI_REF>GECH = %<MchpHex(QEIxGECH)>;	/* Upper bound (High)*/
QEI%<QEI_REF>GECL = %<MchpHex(QEIxGECL)>;	/* Upper bound (Low)*/
%endif
%endif
QEI%<QEI_REF>IOC = %<MchpHex(QEIxIOC)>;
QEI%<QEI_REF>CON = %<MchpHex(QEIxCON)>;
%if QEI_IP != -1
%assign QEIxSTAT = CAST("Number",block.RTWdata.QEIxSTAT)
QEI%<QEI_REF>STAT = %<MchpHex(QEIxSTAT)>;
%<MCHP_SFR(  "QEI%<QEI_REF>IP"  , QEI_IP  , " QEI%<QEI_REF> Interrupt priority set to %<QEI_IP>" )>  
%<MCHP_SFR(  "QEI%<QEI_REF>IF"  , 0 				   , " Reset pending interrupts" )>
%<MCHP_SFR(  "QEI%<QEI_REF>IE"  , 1 				   , " Enable interrupt" )>
%openfile buffer
volatile extern uint%<QEI_Type>_T  MCHP_QEI%<QEI_REF>_Count;
%closefile buffer
%<LibCacheExtern(buffer)>
%openfile dspicfun = "MCHP_QEI%<QEI_REF>_Interrupt.c"
#include "%<LibGetMdlPubHdrBaseName()>.h"
#include "%<LibGetMdlPubHdrBaseName()>_private.h"
volatile uint%<QEI_Type>_T  MCHP_QEI%<QEI_REF>_Count ;
%if ::isPIC32				
%<Mchp_Interrupt32(QEI_IP,1,0,"QEI%<QEI_REF>_VECTOR",block)>  
%else
%<Mchp_Interrupt16(QEI_IP,Mchp_No_auto_psv(),"QEI%<QEI_REF>Interrupt",block)> 		
%endif
{
%<MCHP_ProfileMCU("enter")>
MCHP_QEI%<QEI_REF>_Count = MCHP_QEI%<QEI_REF>_Count + QEI%<QEI_REF>STATbits.PCHEQIRQ ;
MCHP_QEI%<QEI_REF>_Count = MCHP_QEI%<QEI_REF>_Count - QEI%<QEI_REF>STATbits.PCLEQIRQ ;
%if ::isPIC32
{
register int tmp;
tmp = QEI%<QEI_REF>STAT;	/* Reinitalise Interrupt Flags */
}
%else
QEI%<QEI_REF>STAT = %<QEIxSTAT>; /* Reinitalise Interrupt Flags */
%endif
%<MCHP_SFR(  "QEI%<QEI_REF>IF"  , 0 				   , " Clear Interrupt Flag " )> 		
%<MCHP_ProfileMCU("exitUpdate")>
}
%closefile dspicfun
%endif
%endif
%endfunction
%function Outputs(block, system) Output
%assign QEI_Type = CAST("Number",block.RTWdata.QEI_Type)
%assign QEI_REF012 = CAST("Number",block.RTWdata.QEI_REF)
%assign INDXxCNT_Output = CAST("Number",block.RTWdata.INDXxCNT_Output)
%assign POSxCNT_Output = CAST("Number",block.RTWdata.POSxCNT_Output)
%assign PCIIRQ_Output = CAST("Number",block.RTWdata.PCIIRQ_Output)
%assign VELxCNT_output = CAST("Number",block.RTWdata.VELxCNT_output)
%assign INTHLD_output = CAST("Number",block.RTWdata.INTHLD_output)
%assign ExternalReset = CAST("Number",block.RTWdata.ExternalReset)
%assign QEI_IP = CAST("Number",block.RTWdata.QEI_IP)
%assign DOS_01494_qei_32b_upb_v1 = CAST("Number",block.RTWdata.DOS_01494_qei_32b_upb_v1)	
%if QEI_REF012 == 0
%assign QEI_REF = ""		
%else
%assign QEI_REF = QEI_REF012
%endif
%if QEI_Type == 16
%assign IndexOutput = 0
%assign IndexInput = 0
%if INDXxCNT_Output != 0
%assign INDXxCNT_out = LibBlockOutputSignal(IndexOutput, "", "",0)
%assign IndexOutput = IndexOutput + 1
%endif
%if POSxCNT_Output != 0
%assign POSxCNT_out = LibBlockOutputSignal(IndexOutput, "", "",0)
%assign IndexOutput = IndexOutput + 1
%endif
%if ExternalReset == 1
%assign ExternalResetValueL = CAST("Number",block.RTWdata.ExternalResetValueL)
%assign y = LibBlockInputSignal(IndexInput, "", "",0)
%assign IndexInput = IndexInput + 1
if (%<y> == 0)
{
%if INDXxCNT_Output != 0
%<INDXxCNT_out> = MCHP_QEI%<QEI_REF>_Count;
%endif
%<POSxCNT_out> = POS%<QEI_REF>CNT;	/* Read QEI %<QEI_REF> position */
}
else
{
%if INDXxCNT_Output != 0
MCHP_QEI%<QEI_REF>_Count = 0;
%endif
POS%<QEI_REF>CNT = %<ExternalResetValueL>;
%if INDXxCNT_Output != 0
%<INDXxCNT_out> = 0;							/* QEI - Reset */
%endif
%<POSxCNT_out> =  %<ExternalResetValueL>;			/* Reset : Position output is the Initialisation Value */
}
%else
%if INDXxCNT_Output != 0
%<INDXxCNT_out> = MCHP_QEI%<QEI_REF>_Count;
%endif
%<POSxCNT_out> = POS%<QEI_REF>CNT;	/* Read QEI %<QEI_REF> position */
%endif
%else	
%assign IndexOutput = 0
%assign IndexInput = 0
%if INDXxCNT_Output != 0
%assign INDXxCNT_out = LibBlockOutputSignal(IndexOutput, "", "",0)
%assign IndexOutput = IndexOutput + 1
%endif
%if POSxCNT_Output != 0
%assign POSxCNT_out = LibBlockOutputSignal(IndexOutput, "", "",0)
%assign IndexOutput = IndexOutput + 1
%endif
%if DOS_01494_qei_32b_upb_v1 
%if ExternalReset == 1
%assign ExternalResetValueH = CAST("Number",block.RTWdata.ExternalResetValueH)
%assign ExternalResetValueL = CAST("Number",block.RTWdata.ExternalResetValueL)
%assign y = LibBlockInputSignal(IndexInput, "", "",0)
%assign IndexInput = IndexInput + 1
if (%<y> == 0) {
%if QEI_IP != -1 
%<INDXxCNT_out> = MCHP_QEI%<QEI_REF>_Count;
%elseif INDXxCNT_Output != 0
%<INDXxCNT_out> = INDX%<QEI_REF>CNT;	/* read QEI Counter */
%endif
%if POSxCNT_Output != 0
%<POSxCNT_out> = POS%<QEI_REF>CNT;	/* read QEI Position */
%endif
} else {
%if INDXxCNT_Output != 0
%if QEI_IP != -1 
MCHP_QEI%<QEI_REF>_Count = 0;
%else
INDX%<QEI_REF>CNT = 0;	/* QEI - Reset */
%endif
%endif
%if POSxCNT_Output != 0
POS%<QEI_REF>CNT = %<ExternalResetValueH*65536 + ExternalResetValueL>;	/* QEI - Reset */
%endif
%if INDXxCNT_Output != 0
%<INDXxCNT_out> = 0;	/* Index has just been reset */
%endif
%if POSxCNT_Output != 0
%<POSxCNT_out> = %<ExternalResetValueH << 16  + ExternalResetValueL>;	/* Reset : Position output is the Initialisation Value */
%endif
}
%else 
%if (INDXxCNT_Output != 0) && (QEI_IP != -1) 
%<INDXxCNT_out> = MCHP_QEI%<QEI_REF>_Count;
%else
%if INDXxCNT_Output != 0
%<INDXxCNT_out> = INDX%<QEI_REF>CNT;	/* QEI Index */
%endif
%endif
%if POSxCNT_Output != 0
%<POSxCNT_out> = POS%<QEI_REF>CNT;	/* QEI Position */
%endif
%endif
%if PCIIRQ_Output == 1
%assign u = LibBlockOutputSignal(IndexOutput, "", "",0)
%assign IndexOutput = IndexOutput + 1
%<u> = QEI%<QEI_REF>STATbits.PCIIRQ;	/* Position Counter (Homing) Initialization Status */
%endif
%if VELxCNT_output == 1
%assign u = LibBlockOutputSignal(IndexOutput, "", "",0)
%assign IndexOutput = IndexOutput + 1
%<u> = VEL%<QEI_REF>CNT;	/* Velocity Counter (Register is Reset when read) */
%endif
%if INTHLD_output != 0
%assign u = LibBlockOutputSignal(IndexOutput, "", "",0)
%assign IndexOutput = IndexOutput + 1
%<u> = INT%<QEI_REF>HLD;
%endif
%else 
%if ExternalReset == 1
%assign ExternalResetValueH = CAST("Number",block.RTWdata.ExternalResetValueH)
%assign ExternalResetValueL = CAST("Number",block.RTWdata.ExternalResetValueL)
%assign y = LibBlockInputSignal(IndexInput, "", "",0)
%assign IndexInput = IndexInput + 1
if (%<y> == 0) {
%if QEI_IP != -1 
%<INDXxCNT_out> = MCHP_QEI%<QEI_REF>_Count;
%else
%if INDXxCNT_Output == 16
%<INDXxCNT_out> = INDX%<QEI_REF>CNTL;	/* POS%<QEI_REF>CNTH is not taken into account (16 bits output) */
%elseif INDXxCNT_Output == 32
%<INDXxCNT_out> = INDX%<QEI_REF>CNTL;	/* INDX%<QEI_REF>CNTH will be copied to INDX%<QEI_REF>HLD */
%<INDXxCNT_out> |= (uint32_T) INDX%<QEI_REF>HLD << 16;
%endif
%endif
%if POSxCNT_Output == 16
%<POSxCNT_out> = POS%<QEI_REF>CNTL;	/* POS%<QEI_REF>CNTH is not taken into account (16 bits output) */
%elseif POSxCNT_Output == 32
%<POSxCNT_out> = POS%<QEI_REF>CNTL;	/* POS%<QEI_REF>CNTH will be copied to POS%<QEI_REF>HLD */
%<POSxCNT_out> |= (uint32_T) POS%<QEI_REF>HLD << 16;
%endif
} else {
%if INDXxCNT_Output != 0
%if QEI_IP != -1 
MCHP_QEI%<QEI_REF>_Count = 0;
%else
%if INDXxCNT_Output == 32
INDX%<QEI_REF>HLD = 0;	/* QEI - Reset MSB */ 
%endif
INDX%<QEI_REF>CNTL = 0;	/* QEI - Reset LSB */
%endif
%endif
%if POSxCNT_Output != 0
%if POSxCNT_Output == 32
POS%<QEI_REF>HLD = %<ExternalResetValueH>;	/* QEI - Reset MSB */ 
%endif
POS%<QEI_REF>CNTL = %<ExternalResetValueL>;	/* QEI - Reset LSB */
%endif
%if INDXxCNT_Output != 0
%<INDXxCNT_out> = 0;	/* Index has just been reset */
%endif
%if POSxCNT_Output != 0
%<POSxCNT_out> = %<ExternalResetValueH << 16  + ExternalResetValueL>;	/* Reset : Position output is the Initialisation Value */
%endif
}
%else 
%if (INDXxCNT_Output != 0) && (QEI_IP != -1) 
%<INDXxCNT_out> = MCHP_QEI%<QEI_REF>_Count;
%else
%if INDXxCNT_Output == 16
%<INDXxCNT_out> = INDX%<QEI_REF>CNTL;	/* POS%<QEI_REF>CNTH is not taken into account (16 bits output) */
%elseif INDXxCNT_Output == 32
%<INDXxCNT_out> = INDX%<QEI_REF>CNTL;	/* INDX%<QEI_REF>CNTH will be copied to INDX%<QEI_REF>HLD */
%<INDXxCNT_out> |= (uint32_T) INDX%<QEI_REF>HLD << 16;
%endif
%endif
%if POSxCNT_Output == 16
%<POSxCNT_out> = POS%<QEI_REF>CNTL;	/* POS%<QEI_REF>CNTH is not taken into account (16 bits output) */
%elseif POSxCNT_Output == 32
%<POSxCNT_out> = POS%<QEI_REF>CNTL;	/* POS%<QEI_REF>CNTH will be copied to POS%<QEI_REF>HLD */
%<POSxCNT_out> |= (uint32_T) POS%<QEI_REF>HLD << 16;
%endif
%endif
%if PCIIRQ_Output == 1
%assign u = LibBlockOutputSignal(IndexOutput, "", "",0)
%assign IndexOutput = IndexOutput + 1
%<u> = QEI%<QEI_REF>STATbits.PCIIRQ;	/* Position Counter (Homing) Initialization Status */
%endif
%if VELxCNT_output == 1
%assign u = LibBlockOutputSignal(IndexOutput, "", "",0)
%assign IndexOutput = IndexOutput + 1
%<u> = VEL%<QEI_REF>CNT;	/* Velocity Counter (Register is Reset when read) */
%endif
%if INTHLD_output == 16
%assign u = LibBlockOutputSignal(IndexOutput, "", "",0)
%assign IndexOutput = IndexOutput + 1
%<u> = INT%<QEI_REF>HLDL;	/* INT%<QEI_REF>HLDH is not taken into account (16 bits output) */
%elseif INTHLD_output == 32
%assign u = LibBlockOutputSignal(IndexOutput, "", "",0)
%assign IndexOutput = IndexOutput + 1
%<u> = INT%<QEI_REF>HLDL + (uint32_T) INT%<QEI_REF>HLDH << 16;
%endif
%endif 
%endif	
%endfunction
%function Update(block, system) Output
%endfunction
