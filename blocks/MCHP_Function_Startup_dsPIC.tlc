%include "MCHP_Functions.tlc"
%function MchpStartup(ConfigChipOnly) void
%assign CLKDIV = CAST("Real",RTWGenSettings.CLKDIV) 
%assign PLLFBD = CAST("Real",RTWGenSettings.PLLFBD)	
%assign SWITCH_OSC = CAST("Number",RTWGenSettings.SWITCH_OSC)
%assign PLLRNG = CAST("Number",RTWGenSettings.PLLRNG)
%assign PLLDIV = CAST("Number",RTWGenSettings.PLLDIV)	
%assign MIPS = CAST("Real",RTWGenSettings.MIPS)
%assign FLASH_ECC = CAST("Real",RTWGenSettings.FLASH_ECC)
%assign PBxDIV = MchpVector(RTWGenSettings.PBxDIV)	
%openfile tmpFcnOsc
%switch SWITCH_OSC
%case -1 
%assign NOSC = -1
%break
%case 0	
%case 1	
%case 2	
%assign NOSC = 2
%break
%case 3	
%assign NOSC = 0
%break
%case 4	
%assign NOSC = 7
%break
%case 5	
%assign NOSC = 5
%break
%case (0 + (1 << 14 ))			
%case (1 + (1 << 14 ))	
%case (2 + (1 << 14 ))	
%assign NOSC = 3
%break
%case (3 + (1 << 14 ))	
%assign NOSC = 1
%break
%default
%assign NOSC = -1
%warning Problem with Oscillator Configuration.
%endswitch
%if %<SWITCH_OSC> != -1
/* Start Clock Switching */
%endif
%if (%<NOSC> == 1 ) ||  (%<NOSC> == 3 )		
if ((OSCCONbits.COSC & 1) && !(OSCCONbits.COSC & 4)) 		/* check not already in PLL mode (0?1) */
{
__builtin_write_OSCCONH(%<SWITCH_OSC & 6>);   /* Clock Switch to non PLL mode */
__builtin_write_OSCCONL(0x01);  		/* Start clock switching */
__asm__ volatile("nop\n"
"nop");
while(OSCCONbits.COSC != %<SWITCH_OSC & 6>);
}
%endif
%if %<PLLFBD> != -1		
PLLFBD = %<CAST("Number",PLLFBD)>;	/* Oscillator PLL : PLLDIV */
%endif
%if %<CLKDIV> != -1		
CLKDIV = %<MchpHex(CLKDIV)>;	/* Oscillator PLL : FRCDIV ; PLLPOST ; PLLPRE */
%endif
%if %<PLLDIV> != -1
PLLDIV = %<MchpHex(PLLDIV)>;	/* Oscillator PLL : POST1DIV and POST2DIV  */
%endif
%if %<NOSC> != -1
__builtin_write_OSCCONH(%<NOSC>);  /* Clock Switch to desired configuration */
__builtin_write_OSCCONL(0x01);  /* Start clock switching */
%endif
/* Configure Pins as Analog or Digital */		
%<MCHP_ConfigPins()>
%if %<NOSC> != -1
/* Finish clock switching procedure */
while(OSCCONbits.COSC != %<NOSC>); 	/* Wait for Oscillator Stabilisation */
%if (%<NOSC> == 1 ) ||  (%<NOSC> == 3 )		
while(OSCCONbits.LOCK != 1);	/* Wait for PLL Stabilisation */
%endif
%endif
%assign ACLKCON_reg = CAST("Number",RTWGenSettings.ACLKCON_reg)
%if ::MCHP_useAuxilliaryClock_APLL > 0
%if ACLKCON_reg == -1
%error("Auxilliary is required by at least one peripheral but Auxilliary clock configuration is not valid. Verify Auxilliary clock setting in the Microchip MASTER block.")
%else
/* Enable Auxilliary clock */
ACLKCON = %<MchpHex(ACLKCON_reg)>; /* Set Auxilliary clock (APLL)*/
%if (ACLKCON_reg & 32768) != 0
while(!ACLKCONbits.APLLCK); /* Wait for PLL of Auxilliary clock to lock */
__delay_us(50);	/* Delay 50us, Errata DS80000656A */
%endif
%endif
%elseif ACLKCON_reg != -1
/* ACLKCON = %<MchpHex(ACLKCON_reg)>; Auxilliary clock is not used by any peripheral. It is not enabled. */
%endif
/* Initialize model */
%if ConfigChipOnly == 0
%<LibCallModelInitialize()> 	
%endif
%if CAST("Number",RTWGenSettings.DOS_02552_msi_upb_v1_Master) != 0
%if EXISTS(::MCHP_dsPIC_HAVESECONDARYIMAGE)
%if ::MCHP_dsPIC_HAVESECONDARYIMAGE == 1
/* Program and start the secondary core image */
_program_secondary(1,0,secondary_image); /* Deprecated, use _program_secondary() */
_start_secondary();     /* Deprecated, use _start_secondary() */
%endif				
%endif
%endif
%if ConfigChipOnly == 0
/* Configure Timers */
%<MCHP_ConfigTimers()>
%else
/* Cancel Timer configuration to avoid unexpected interruption ,might configure however timers not used for timestep*/
/* Configure Timers */
%<MCHP_ConfigTimers()>
%endif
%closefile tmpFcnOsc
%return tmpFcnOsc
%endfunction