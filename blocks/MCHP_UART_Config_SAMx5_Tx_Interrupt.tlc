
%include "MCHP_UART_Tx_SAMx5_FunUtils.tlc"
%function MCHP_UART_Config_Tx_Interrupt(block,system) Output 	
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%assign UART_NAME = UART_Tx_get_UART_NAME(block)
%assign INTERRUPT_Tx_name = "SERCOM%<UARTRef-1>_0"	
%assign INTERRUPT_Tx_name1 = "SERCOM%<UARTRef-1>_1"	
%assign INTERRUPT_Rx_name = "SERCOM%<UARTRef-1>_2"	
%assign TX_IMPLEMENTATION = MchpVector(RTWGenSettings.UART_TX_IMPLEMENTATION)
%assign TX_IMPLEMENTATION = TX_IMPLEMENTATION[UARTRef-1]		
%assign InitSequence_enable = CAST("Number",block.RTWdata.InitSequence_enable)
%assign UART_HALF_DUPLEX_MODE = MchpVector(RTWGenSettings.UART_HALF_DUPLEX_MODE)
%assign UART_HALF_DUPLEX_MODE = UART_HALF_DUPLEX_MODE[UARTRef-1]
%assign TX_INT_PRIORITY = CAST("Number",block.RTWdata.TX_INT_PRIORITY)
%assign TX_BufferSize = CAST("Number",block.RTWdata.TX_CIRCULAR_SIZE)
%openfile dspicfun = "MCHP_%<UART_NAME>_Tx_Interrupt.c"		
#include <stdlib.h>
#include "%<LibGetMdlPubHdrBaseName()>.h"
#include "%<LibGetMdlPubHdrBaseName()>_private.h"
%openfile buffer
/* Declare %<UART_NAME> Tx Circular Buffer Structure */
#define Tx_BUFF_SIZE_%<UART_NAME> (%<TX_BufferSize>)    
typedef struct MCHP_%<UART_NAME>_TxStr
{
volatile uint8_T buffer[Tx_BUFF_SIZE_%<UART_NAME>];			/* Size Rx_BUFF_SIZE_%<UART_NAME> is %<TX_BufferSize> */
volatile uint_T  tail;                                          /* tail is the index for the next value to be read from the Circular buffer */				
volatile uint_T  head;                                          /* head is the index for the next value to be written into the Circular buffer */
} MCHP_%<UART_NAME>_TxStr;
%closefile buffer
%<LibCacheTypedefs(buffer)>		
%openfile buffer
/* Declare %<UART_NAME> Tx Circular Buffer Structure */
extern MCHP_%<UART_NAME>_TxStr MCHP_%<UART_NAME>_Tx;
%closefile buffer
%<LibCacheExtern(buffer)>
/* Declare %<UART_NAME> Tx Circular Buffer Structure */
MCHP_%<UART_NAME>_TxStr MCHP_%<UART_NAME>_Tx = { .head = 0, .tail = 0 };	/* %<UART_NAME> Tx FIFO */
/* Interrupt SERCOM %<UARTRef-1> 0: when buffer has one empty space to write */
void %<INTERRUPT_Tx_name>_Handler(void)
{
uint_T LocalHead;
%<MCHP_InterruptProlog()>      	
/* Handle Tx interrupt */			
%<MCHP_ProfileMCU("enter")>		
LocalHead = MCHP_%<UART_NAME>_Tx.head;	/* Head is a volatile variable. Use local variable to speed-up execution */
%assign ClosureUART_HALF_DUPLEX_MODE = ""
%if UART_HALF_DUPLEX_MODE == 1
if (MCHP_%<UART_NAME>_Tx.tail == LocalHead)
{			
uint32_T tmp_reg;
tmp_reg = SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_CTRLB;
tmp_reg &= ~(uint32_T) SERCOM_USART_INT_CTRLB_TXEN_Msk; 		/* Disable Tx */
tmp_reg |= SERCOM_USART_INT_CTRLB_RXEN_Msk; 				/* Enable Rx */
SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_CTRLB = tmp_reg; /* Write back UART setting */		
SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_INTENCLR = (SERCOM_USART_INT_INTENCLR_DRE_Msk | SERCOM_USART_INT_INTENCLR_TXC_Msk); /* Disable Tx Interrupt */																	
SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_INTFLAG = SERCOM_USART_INT_INTFLAG_TXC_Msk; 		/* Clear interrupt flag */					
}
else
{
%assign ClosureUART_HALF_DUPLEX_MODE = "}"
%endif
while ( ((SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_INTFLAG) & SERCOM_USART_INT_INTFLAG_DRE_Msk) && (MCHP_%<UART_NAME>_Tx.tail != LocalHead) ) /* while Tx buffer is not full */
{ 									
SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_DATA = MCHP_%<UART_NAME>_Tx.buffer[LocalHead];
LocalHead = (LocalHead + 1) & (Tx_BUFF_SIZE_%<UART_NAME> - 1);
}				
MCHP_%<UART_NAME>_Tx.head = LocalHead; /* Push back volatile variable */	
%if 0 
if (MCHP_%<UART_NAME>_Tx.tail == LocalHead)
SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_INTENCLR = SERCOM_USART_INT_INTENCLR_DRE_Msk; /* Disable Tx Interrupt */
%else		
SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_INTENCLR = SERCOM_USART_INT_INTENCLR_DRE_Msk; /* Disable Tx DRE Interrupt */
%if UART_HALF_DUPLEX_MODE == 0
if (MCHP_%<UART_NAME>_Tx.tail != LocalHead)			
%endif
SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_INTENSET = SERCOM_USART_INT_INTENSET_TXC_Msk; /* Enable Tx TXC Interrupt */
%endif
%<ClosureUART_HALF_DUPLEX_MODE>	
%<MCHP_ProfileMCU("exitUpdate")> 					
%<MCHP_InterruptEpilog()>
} /* End of %<INTERRUPT_Tx_name> Handler */
/* Interrupt SERCOM %<UARTRef-1> 1: when all values have been sent and buffer is empty */
/* Should be able to write two values within the buffer register */
void %<INTERRUPT_Tx_name1>_Handler(void)
{
uint_T LocalHead;
%<MCHP_InterruptProlog()>
/* Handle Tx interrupt */			
%<MCHP_ProfileMCU("enter")>		
LocalHead = MCHP_%<UART_NAME>_Tx.head;	/* Head is a volatile variable. Use local variable to speed-up execution */
%assign ClosureUART_HALF_DUPLEX_MODE = ""
%if UART_HALF_DUPLEX_MODE == 1
if (MCHP_%<UART_NAME>_Tx.tail == LocalHead)
{			
uint32_T tmp_reg;
tmp_reg = SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_CTRLB;
tmp_reg &= ~(uint32_T) SERCOM_USART_INT_CTRLB_TXEN_Msk; 		/* Disable Tx */
tmp_reg |= SERCOM_USART_INT_CTRLB_RXEN_Msk; 				/* Enable Rx */
SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_CTRLB = tmp_reg; /* Write back UART setting */		
SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_INTENCLR = (SERCOM_USART_INT_INTENCLR_DRE_Msk | SERCOM_USART_INT_INTENCLR_TXC_Msk); /* Disable Tx Interrupt */					
SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_INTFLAG = SERCOM_USART_INT_INTFLAG_TXC_Msk; 		/* Clear interrupt flag required */					
}
else
{
%assign ClosureUART_HALF_DUPLEX_MODE = "}"
%endif			
if ((SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_INTFLAG) & SERCOM_USART_INT_INTFLAG_DRE_Msk) /* Should be set */
{
/* Can feed two bytes */ 					
if (MCHP_%<UART_NAME>_Tx.tail != LocalHead)
{
SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_DATA = MCHP_%<UART_NAME>_Tx.buffer[LocalHead];
LocalHead = (LocalHead + 1) & (Tx_BUFF_SIZE_%<UART_NAME> - 1);
}
if (MCHP_%<UART_NAME>_Tx.tail != LocalHead)
{
SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_DATA = MCHP_%<UART_NAME>_Tx.buffer[LocalHead];
LocalHead = (LocalHead + 1) & (Tx_BUFF_SIZE_%<UART_NAME> - 1);
}
MCHP_%<UART_NAME>_Tx.head = LocalHead; /* Push back volatile variable */	
}
%if UART_HALF_DUPLEX_MODE == 0
if (MCHP_%<UART_NAME>_Tx.tail == LocalHead)
SERCOM%<UARTRef-1>_REGS->USART_INT.SERCOM_INTENCLR = SERCOM_USART_INT_INTENCLR_TXC_Msk; /* Disable Tx Interrupt */	
%endif
%<ClosureUART_HALF_DUPLEX_MODE>	
%<MCHP_ProfileMCU("exitUpdate")> 					
%<MCHP_InterruptEpilog()>
} /* End of %<INTERRUPT_Tx_name1> Handler */
%closefile dspicfun
%endfunction