
%function MCHP_UART_Config_Rx_DMA(block,system) Output
%assign UARTRef = CAST("Number",block.RTWdata.UARTRef)
%assign nUSART = CAST("Number",block.RTWdata.nUSART)	
%switch ::ChipIdL1
%case "SAME"
%case "SAMS"
%case "SAMV"
%if UARTRef > nUSART
%assign Per_Type = "UART"
%assign REG_NAME = "UART"
%assign REG_NAME2 = ""
%assign INTERRUPT_STATUS_REG = "SR"
%assign UART_Index = (UARTRef-1) - nUSART
%else
%assign Per_Type = "USART"
%assign REG_NAME = "US"
%assign REG_NAME2 = "USART_"
%assign INTERRUPT_STATUS_REG = "CSR"
%assign UART_Index = UARTRef-1
%endif
%assign UART_NAME = "%<Per_Type>%<UART_Index>"
%break
%case "SAMRH"
%assign Per_Type = "USART"
%assign REG_NAME = "FLEX_US"
%assign REG_NAME2 = ""
%assign INTERRUPT_STATUS_REG = "CSR"
%assign UART_Index = UARTRef-1
%assign UART_NAME = "FLEXCOM%<UART_Index>"
%break
%default
%error("Internal error with UART")
%endswitch
%assign RX_IMPLEMENTATION = MchpVector(RTWGenSettings.UART_RX_IMPLEMENTATION)
%assign RX_IMPLEMENTATION = RX_IMPLEMENTATION[UARTRef-1]		
%assign UART_RX_DMACHANNEL = MchpVector(RTWGenSettings.UART_RX_DMACHANNEL)
%assign RX_DMA_CHANNEL = UART_RX_DMACHANNEL[UARTRef-1]		
%assign XDMAC_Rx_PERID = CAST("Vector",[8 ,10, 12, 21, 23, 25, 27, 29])
%assign XDMAC_UART_RX_PERID = XDMAC_Rx_PERID[UARTRef-1]
%assign RX_BUFFER_SIZE = CAST("Number",block.RTWdata.RX_DMA_SIZE)
%assign RX_OUTPUT_BUFFER_SIZE = %<RX_BUFFER_SIZE> * 2
%assign RX_DMA_IRQ_PRIORITY = 3
%assign TLC_GENERATE_DEBUG_CODE = 0
%openfile buffer
#define RX_OUTPUT_BUFFER_SIZE_%<UART_NAME> (%<RX_BUFFER_SIZE * 2>)
#define RX_BUFFER_SIZE_%<UART_NAME> (%<RX_BUFFER_SIZE>)
#define RX_MICROCBLOCK_SIZE (%<RX_BUFFER_SIZE>)
#define RX_DMA_IRQ_PRIORITY (%<RX_DMA_IRQ_PRIORITY>)
/* Declare variables used for handling Rx-DMA buffers */
extern volatile uint32_t MCHP_current_rx_buffer;
extern volatile uint32_t MCHP_residue;
extern volatile uint32_t MCHP_total_bytes_in_output_buffer;
extern volatile uint32_t MCHP_position_in_output_buffer;
extern volatile uint32_t MCHP_start_position_in_rx_buffer;
extern volatile uint32_t MCHP_end_position_in_rx_buffer;
extern volatile uint32_t MCHP_dirty;
extern volatile uint32_t MCHP_old_residue;
extern volatile uint32_t MCHP_number_of_bytes_to_copy;
/* Declare global variables used for Rx-DMA debug */
extern volatile uint32_t MCHP_complete_ublocks_transfered;
extern volatile uint32_t MCHP_incomplete_ublocks_transfered;
extern volatile uint32_t MCHP_number_of_bis_interrupts;
extern volatile uint32_t MCHP_number_of_fis_interrupts;
/* Declare %<UART_NAME> Rx DMA Buffers */
extern uint8_T MCHP_%<UART_NAME>_Rx_bufferA[RX_BUFFER_SIZE_%<UART_NAME>];
extern uint8_T MCHP_%<UART_NAME>_Rx_bufferB[RX_BUFFER_SIZE_%<UART_NAME>];
extern uint8_T MCHP_%<UART_NAME>_Rx_OutputBuffer[RX_OUTPUT_BUFFER_SIZE_%<UART_NAME>];
%if (TLC_GENERATE_DEBUG_CODE == 1)
#include <stdio.h>
#define MCHP_DEBUG_MODE 1
uint32_t MCHP_Console_Write_String(uint8_t *string);
%endif
%closefile buffer
%<LibCacheExtern(buffer)>
/* ==================================[ XDMAC initialization code (Rx) ]====================================== */
/* DMA Controller Peripheral Connections for %<UART_NAME>(XDMAC_CC.PERID = %<XDMAC_UART_RX_PERID> */
{
PMC_REGS->PMC_PCER1 |=  PMC_PCER1_PID58(1); /* Enable DMA clock. XDMAC ID: 58. The clock enable bit is located in PMC_PCER1  */
/* All XDMA channel interrupts will be enabled with the following stored value */
uint32_t xdmaint;
xdmaint = ( XDMAC_CIE_BIE_Msk   |
XDMAC_CIE_LIE_Msk   |
XDMAC_CIE_DIE_Msk   |
XDMAC_CIE_FIE_Msk   |
XDMAC_CIE_RBIE_Msk  |
XDMAC_CIE_WBIE_Msk  |
XDMAC_CIE_ROIE_Msk);
/* Initialize channel configuration for receiver */
xdmac_rx_cfg.mbr_ubc = RX_MICROCBLOCK_SIZE;
xdmac_rx_cfg.mbr_da = (uint32_t)MCHP_%<UART_NAME>_Rx_bufferA;
xdmac_rx_cfg.mbr_sa = (uint32_t)&(%<UART_NAME>_REGS->%<REG_NAME>_RHR);
xdmac_rx_cfg.mbr_cfg =  XDMAC_CC_TYPE_PER_TRAN |
XDMAC_CC_MBSIZE_SINGLE |
XDMAC_CC_DSYNC_PER2MEM |
XDMAC_CC_CSIZE_CHK_1 |
XDMAC_CC_DWIDTH_BYTE|
XDMAC_CC_SIF_AHB_IF1 |
XDMAC_CC_DIF_AHB_IF0 |
XDMAC_CC_SAM_FIXED_AM |
XDMAC_CC_DAM_INCREMENTED_AM |
XDMAC_CC_PERID(%<UART_NAME>_XDMAC_RX_CH_NUM);
xdmac_rx_cfg.mbr_bc = 0UL;
xdmac_rx_cfg.mbr_ds =  0UL;
xdmac_rx_cfg.mbr_sus = 0UL;
xdmac_rx_cfg.mbr_dus = 0UL;
/* Clear the pending Interrupt Status bit(s) by reading the selected XDMAC Channel x Interrupt Status Register (XDMAC_CISx) */
volatile uint32_t temp = XDMAC_REGS->XDMAC_CHID[XDMAC_RX_CH].XDMAC_CIS;
/* Set source address */
XDMAC_REGS->XDMAC_CHID[XDMAC_RX_CH].XDMAC_CSA = xdmac_rx_cfg.mbr_sa;
/* Set destination address */
XDMAC_REGS->XDMAC_CHID[XDMAC_RX_CH].XDMAC_CDA = xdmac_rx_cfg.mbr_da;
/* Set microblock control*/
XDMAC_REGS->XDMAC_CHID[XDMAC_RX_CH].XDMAC_CUBC = XDMAC_CUBC_UBLEN(xdmac_rx_cfg.mbr_ubc);
/* Set block control */
XDMAC_REGS->XDMAC_CHID[XDMAC_RX_CH].XDMAC_CBC = XDMAC_CBC_BLEN(xdmac_rx_cfg.mbr_bc);
/* Set data stride pattern */
XDMAC_REGS->XDMAC_CHID[XDMAC_RX_CH].XDMAC_CDS_MSP = xdmac_rx_cfg.mbr_ds;
/* Set source microblock stride */
XDMAC_REGS->XDMAC_CHID[XDMAC_RX_CH].XDMAC_CSUS = XDMAC_CSUS_SUBS(xdmac_rx_cfg.mbr_sus);
/* Set destination microblock stride */
XDMAC_REGS->XDMAC_CHID[XDMAC_RX_CH].XDMAC_CDUS = XDMAC_CDUS_DUBS(xdmac_rx_cfg.mbr_dus);
/* Set channel configuration */
XDMAC_REGS->XDMAC_CHID[XDMAC_RX_CH].XDMAC_CC = xdmac_rx_cfg.mbr_cfg;
/* Setup descriptor control */
volatile uint32_t descriptor_control_setup =    XDMAC_CNDC_NDVIEW_NDV0                  |
XDMAC_CNDC_NDE_DSCR_FETCH_EN            |
XDMAC_CNDC_NDSUP_SRC_PARAMS_UNCHANGED   |
XDMAC_CNDC_NDDUP_DST_PARAMS_UPDATED ;
/* Write descriptor control registers */
XDMAC_REGS->XDMAC_CHID[XDMAC_RX_CH].XDMAC_CNDC = descriptor_control_setup;
XDMAC_REGS->XDMAC_CHID[XDMAC_RX_CH].XDMAC_CNDA = ( (uint32_t)(&lld_0[0]) & 0xFFFFFFFC ) | 1; /* XDMAC_CNDA.NDAIF is 0 or 1 */;
/* Initialize the first linked list descriptor. It is a View0-type descriptor */
lld_0[0].mbr_nda = (uint32_t)(&lld_0[1]);
lld_0[0].mbr_ubc = XDMAC_UBC_NVIEW_NDV0 | XDMAC_UBC_NDE_FETCH_EN | XDMAC_UBC_NSEN_UPDATED | XDMAC_UBC_NDEN_UPDATED | XDMAC_UBC_UBLEN(RX_MICROCBLOCK_SIZE);
lld_0[0].mbr_da = (uint32_t)&MCHP_%<UART_NAME>_Rx_bufferA[0];
/* Initialize the second linked list descriptor. It is a View0-type descriptor */
lld_0[1].mbr_nda = (uint32_t)(&lld_0[2]);
lld_0[1].mbr_ubc = XDMAC_UBC_NVIEW_NDV0 | XDMAC_UBC_NDE_FETCH_EN | XDMAC_UBC_NSEN_UPDATED | XDMAC_UBC_NDEN_UPDATED | XDMAC_UBC_UBLEN(RX_MICROCBLOCK_SIZE);
lld_0[1].mbr_da = (uint32_t)&MCHP_%<UART_NAME>_Rx_bufferB[0];
/* Initialize the 3rd linked list descriptor. It is a View0-type descriptor */
lld_0[2].mbr_nda = (uint32_t)(&lld_0[1]);
lld_0[2].mbr_ubc = XDMAC_UBC_NVIEW_NDV0 |  XDMAC_UBC_NDEN_UPDATED | XDMAC_UBC_NSEN_UNCHANGED | XDMAC_UBC_NDE_FETCH_EN | XDMAC_UBC_UBLEN(RX_MICROCBLOCK_SIZE);
lld_0[2].mbr_da = (uint32_t)&MCHP_%<UART_NAME>_Rx_bufferA[0];
/* Enable all interrupts for this DMA channel */
XDMAC_REGS->XDMAC_CHID[XDMAC_RX_CH].XDMAC_CIE = xdmaint;
/* Update DCache before DMA transfer */
/* Enable the DMA channel */
XDMAC_REGS->XDMAC_GE |= XDMAC_GE_EN%<RX_DMA_CHANNEL>_Msk ;
/* Enable XDMAC global interrupt */
XDMAC_REGS->XDMAC_GIE |= XDMAC_GIE_IE%<RX_DMA_CHANNEL>_Msk;
/* Enable XDMAC NVIC interrupt */
NVIC_ClearPendingIRQ(XDMAC_IRQn);
NVIC_SetPriority(XDMAC_IRQn, RX_DMA_IRQ_PRIORITY);
NVIC_EnableIRQ(XDMAC_IRQn);
}
%openfile ::rx_prologue	
/*  */
%closefile rx_prologue
%openfile ::rx_epilogue
/* Handle Rx timeout request interrupt (XDMAC FIFO Flush)*/
/%
%if ( (RX_IMPLEMENTATION == 3) && ISEQUAL(Per_Type, "USART") ) 
/* Handle Rx Receive Timeout Interrupt */
/* Check if USART interrupt was generated by a Receiving TimeOut event */
if(%<UART_NAME>_REGS->US_CSR & US_%<INTERRUPT_STATUS_REG>_TIMEOUT_Msk){
%<UART_NAME>_REGS->US_CR = (%<UART_NAME>_REGS->US_CR & (~US_CR_STTTO_Msk)) | US_CR_STTTO(1UL);   /* Start waiting for a character before enabling the timeout counter. Immediately disables a
timeout period in progress. Resets the status bit TIMEOUT in US_CSR. */
/* Flush the DMA FIFO only if no character is being received  */
if( (%<UART_NAME>_REGS->US_CSR & US_%<INTERRUPT_STATUS_REG>_RXRDY_Msk)== 0UL ){
%if (TLC_GENERATE_DEBUG_CODE == 1)
#ifdef MCHP_DEBUG_MODE
MCHP_Console_Write_String("*** USART Rx-Timeout Interrupt: DMA FLUSH requested ***\n\r");
#endif
%endif
/* Requests a DMA flush for XDMAC channel %<RX_DMA_CHANNEL> (Rx) */
XDMAC_REGS->XDMAC_GSWF |= (1UL << XDMAC_RX_CH);
}
}
%endif
%/
%closefile rx_epilogue
%openfile ::rx_dma_prologue
/* %<UART_NAME> Rx DMA buffers */
uint8_T MCHP_%<UART_NAME>_Rx_bufferA[RX_BUFFER_SIZE_%<UART_NAME>];
uint8_T MCHP_%<UART_NAME>_Rx_bufferB[RX_BUFFER_SIZE_%<UART_NAME>];
uint8_T MCHP_%<UART_NAME>_Rx_OutputBuffer[RX_OUTPUT_BUFFER_SIZE_%<UART_NAME>];
/* Initialize global variables used to manage Rx-DMA buffers */
volatile uint32_t MCHP_current_rx_buffer = 1UL;
volatile uint32_t MCHP_residue = 0UL;
volatile uint32_t MCHP_total_bytes_in_output_buffer = 0UL;
volatile uint32_t MCHP_position_in_output_buffer = 0UL;
volatile uint32_t MCHP_start_position_in_rx_buffer = 0UL;
volatile uint32_t MCHP_end_position_in_rx_buffer = 0UL;
volatile uint32_t MCHP_dirty = 0UL;
volatile uint32_t MCHP_old_residue = RX_MICROCBLOCK_SIZE;
volatile uint32_t MCHP_number_of_bytes_to_copy = 0UL;
%if (TLC_GENERATE_DEBUG_CODE == 1)
/* Initialize global variables used for debug */
volatile uint32_t MCHP_complete_ublocks_transfered = 0UL;
volatile uint32_t MCHP_incomplete_ublocks_transfered = 0UL;
volatile uint32_t MCHP_number_of_bis_interrupts = 0UL;
volatile uint32_t MCHP_number_of_fis_interrupts = 0UL;
%endif
%closefile rx_dma_prologue
%openfile ::rx_dma_epilogue
volatile uint32_t dma_status;
%if (TLC_GENERATE_DEBUG_CODE == 1)
#ifdef MCHP_DEBUG_MODE
uint8_t MCHP_debug_buffer[1000];
#endif
%endif
/*----------------------------- Check if XDMAC Channel %<RX_DMA_CHANNEL> (%<UART_NAME>-RX) issued the interrupt for end of block transfer -----------------------------*/
dma_status = XDMAC_REGS->XDMAC_CHID[XDMAC_RX_CH].XDMAC_CIS; /* get DMA Channel %<RX_DMA_CHANNEL> (Rx) status */
if (dma_status & XDMAC_CIS_BIS_Msk){
%if (TLC_GENERATE_DEBUG_CODE == 1)
#ifdef MCHP_DEBUG_MODE
MCHP_number_of_bis_interrupts++; /* For DEBUG: count the number of interrupts triggered for 'End of Block' */
#endif
%endif
if (MCHP_dirty){
/* If we are here, it means that an incomplete(fragmented) uBlock received it's final byte/bytes.
It is the time to check which bytes are new and copy them to the 'output_buffer'.
Not doing this, some bytes will have duplicate copies in 'output_buffer' */
%if (TLC_GENERATE_DEBUG_CODE == 1)
#ifdef MCHP_DEBUG_MODE
MCHP_Console_Write_String("XDMAC interrupt: BIS MCHP_dirty \n\r");
#endif
%endif
/* Get residual no. of bytes ( see datasheet page 511) */
MCHP_residue = ((XDMAC_REGS->XDMAC_CHID[XDMAC_RX_CH].XDMAC_CUBC & XDMAC_CUBC_Msk ) << 0UL);  /* "0" is a placeholder for getting the number of bytes corresponding to the data width (from channel configuration). In this case "XDMAC_CC_DWIDTH_BYTE_Val" is "0" */
if(MCHP_old_residue < MCHP_residue){
MCHP_number_of_bytes_to_copy = RX_MICROCBLOCK_SIZE - abs(MCHP_old_residue - MCHP_residue);
}
else{
MCHP_number_of_bytes_to_copy = MCHP_old_residue - MCHP_residue;
}
/* Check if there are any new fresh bytes to be copied from DMA FIFO */
if(MCHP_number_of_bytes_to_copy > 0UL){
MCHP_position_in_output_buffer = MCHP_total_bytes_in_output_buffer;
MCHP_start_position_in_rx_buffer = (RX_MICROCBLOCK_SIZE - (MCHP_old_residue));
%if (TLC_GENERATE_DEBUG_CODE == 1)
#ifdef MCHP_DEBUG_MODE
sprintf(MCHP_debug_buffer, "rx_buffer: %u, MCHP_dirty state:%u \n\r", MCHP_current_rx_buffer, MCHP_dirty);
MCHP_Console_Write_String(MCHP_debug_buffer);
sprintf(MCHP_debug_buffer, "MCHP_residue:%u, MCHP_old_residue:%u, MCHP_number_of_bytes_to_copy:%u, MCHP_position_in_output_buffer:%u, MCHP_start_position_in_rx_buffer:%u, MCHP_total_bytes_in_output_buffer:%u \n\r\n\r", MCHP_residue, MCHP_old_residue, MCHP_number_of_bytes_to_copy, MCHP_position_in_output_buffer, MCHP_start_position_in_rx_buffer, MCHP_total_bytes_in_output_buffer);
MCHP_Console_Write_String(MCHP_debug_buffer);
#endif
%endif
if(MCHP_current_rx_buffer == 1UL){
/* Copy from 'rx_bufferA' to the 'output_Buffer' only the useful bytes */
for(volatile uint32_t cnt = 0UL; cnt < MCHP_number_of_bytes_to_copy; cnt++){
MCHP_%<UART_NAME>_Rx_OutputBuffer[MCHP_position_in_output_buffer+cnt] = MCHP_%<UART_NAME>_Rx_bufferA[MCHP_start_position_in_rx_buffer+cnt];
}
MCHP_current_rx_buffer = 2UL; /* switch to bufferB */
}
else{
/* Copy from 'rx_bufferB' only the useful bytes */
for(volatile uint32_t cnt = 0UL; cnt < MCHP_number_of_bytes_to_copy; cnt++){
MCHP_%<UART_NAME>_Rx_OutputBuffer[MCHP_position_in_output_buffer+cnt] = MCHP_%<UART_NAME>_Rx_bufferB[MCHP_start_position_in_rx_buffer+cnt];
}
MCHP_current_rx_buffer = 1UL; /* switch to bufferA */
}
}
}
else{
/* If we are here, it means that current uBlock has received it's final byte.
The uBlock contains a stream of non-fragmented fresh bytes, received in sequential order.
This is the only place where complete uBlocks transfer occurs. It is mandatory to copy the buffer as fast as possible
especially when DMA FIFO size is very large or very small */
%if (TLC_GENERATE_DEBUG_CODE == 1)
#ifdef MCHP_DEBUG_MODE
MCHP_complete_ublocks_transfered++; /* count the number of complete blocks microblocks transferred */
MCHP_Console_Write_String("XDMAC interrupt: BIS NOT MCHP_dirty \n\r");
#endif
%endif
MCHP_number_of_bytes_to_copy = RX_MICROCBLOCK_SIZE;
MCHP_position_in_output_buffer = MCHP_total_bytes_in_output_buffer;
if(MCHP_current_rx_buffer == 1UL){
/* Copy from 'rx_bufferA' to the 'output_Buffer' only the useful bytes */
for(volatile uint32_t temp = 0UL; temp < MCHP_number_of_bytes_to_copy; temp++){
MCHP_%<UART_NAME>_Rx_OutputBuffer[MCHP_position_in_output_buffer+temp] = MCHP_%<UART_NAME>_Rx_bufferA[temp];
}
MCHP_current_rx_buffer = 2UL; /* switch to bufferB */
}
else{
/* Copy from 'rx_bufferB' to the 'output_Buffer' only the useful bytes */
for(volatile uint32_t temp = 0UL; temp < MCHP_number_of_bytes_to_copy; temp++){
MCHP_%<UART_NAME>_Rx_OutputBuffer[MCHP_position_in_output_buffer+temp] = MCHP_%<UART_NAME>_Rx_bufferB[temp];
}
MCHP_current_rx_buffer = 1UL;  /* switch to bufferA */
}
}
/* Update variables */
MCHP_dirty = 0UL; /* now the uBlock transfer is of a complete(non-fragmented) type */
MCHP_old_residue = RX_MICROCBLOCK_SIZE;
MCHP_total_bytes_in_output_buffer += MCHP_number_of_bytes_to_copy;
}/* end of BIS code */
/*------------ Check if DMA channel %<RX_DMA_CHANNEL> (%<UART_NAME>-RX) issued a request for DMA FIFO flush (this will happen ONLY for incomplete uBlocks) ------------*/
if (dma_status & XDMAC_CIS_FIS_Msk){
%if (TLC_GENERATE_DEBUG_CODE == 1)
#ifdef MCHP_DEBUG_MODE
number_of_fis_intrrupts++;  /* count the number of flush-request interrupts */
incomplete_ublocks_transfered++; /* Count the number of incomplete microblocks transferred*/
#endif
%endif
if(MCHP_dirty){
/* If we are here, it means that an USART Rx-Timeout interrupt requested AGAIN a DMA-FIFO flush.
Wee need to check which fresh bytes were received from the previous DMA flush-request. */
%if (TLC_GENERATE_DEBUG_CODE == 1)
#ifdef MCHP_DEBUG_MODE
MCHP_Console_Write_String("XDMAC interrupt: FIS MCHP_dirty \n\r");
#endif
%endif
/* Get residual no. of bytes ( see datasheet page 511) */
MCHP_residue = ((XDMAC_REGS->XDMAC_CHID[XDMAC_RX_CH].XDMAC_CUBC & XDMAC_CUBC_Msk ) << 0);  /* "0" is a placeholder for getting the number of bytes corresponding to the data width (from channel configuration). In this case "XDMAC_CC_DWIDTH_BYTE_Val" is "0" */
MCHP_number_of_bytes_to_copy = MCHP_old_residue - MCHP_residue;
/* If there are any residual bytes to be copied from DMA FIFO */
if(MCHP_number_of_bytes_to_copy > 0UL){
MCHP_position_in_output_buffer = MCHP_total_bytes_in_output_buffer;
MCHP_start_position_in_rx_buffer = (RX_MICROCBLOCK_SIZE - (MCHP_old_residue));
%if (TLC_GENERATE_DEBUG_CODE == 1)
#ifdef MCHP_DEBUG_MODE
sprintf(MCHP_debug_buffer, "rx_buffer: %u, MCHP_dirty state:%u \n\r", MCHP_current_rx_buffer, MCHP_dirty);
MCHP_Console_Write_String(MCHP_debug_buffer);
sprintf(MCHP_debug_buffer, "MCHP_residue:%u, MCHP_old_residue:%u, MCHP_number_of_bytes_to_copy:%u, MCHP_position_in_output_buffer:%u, MCHP_start_position_in_rx_buffer:%u, MCHP_total_bytes_in_output_buffer:%u \n\r\n\r", MCHP_residue, MCHP_old_residue, MCHP_number_of_bytes_to_copy, MCHP_position_in_output_buffer, MCHP_start_position_in_rx_buffer, MCHP_total_bytes_in_output_buffer);
MCHP_Console_Write_String(MCHP_debug_buffer);
#endif
%endif
if (MCHP_current_rx_buffer == 1UL){
/* Copy from 'rx_bufferA' to the 'output_Buffer' only the useful bytes */
for(volatile uint32_t cnt = 0UL; cnt < MCHP_number_of_bytes_to_copy; cnt++){
MCHP_%<UART_NAME>_Rx_OutputBuffer[MCHP_position_in_output_buffer+cnt] = MCHP_%<UART_NAME>_Rx_bufferA[MCHP_start_position_in_rx_buffer+cnt];
}
}
else{
/* Copy from 'rx_bufferB' to the 'output_Buffer' only the useful bytes */
for(volatile uint32_t cnt = 0UL; cnt < MCHP_number_of_bytes_to_copy; cnt++){
MCHP_%<UART_NAME>_Rx_OutputBuffer[MCHP_position_in_output_buffer+cnt] = MCHP_%<UART_NAME>_Rx_bufferB[MCHP_start_position_in_rx_buffer+cnt];
}
}
}
}
else{
/* If we are here, it means that an USART Rx-Timeout Interrupt requested a DMA-FLUSH for the first time
since a complete(non-fragmented) block transfer(BIS) was transferred. Wee need to check which fresh bytes were received.
This information is directly available from reading the UBLEN register(indicating the number of residual bytes or the number
of missing bytes to complete one uBlock transfer) */
%if (TLC_GENERATE_DEBUG_CODE == 1)
#ifdef MCHP_DEBUG_MODE
MCHP_Console_Write_String("XDMAC interrupt: FIS NOT MCHP_dirty \n\r");
#endif
%endif
/* Get residual no. of bytes ( see datasheet page 511) */
MCHP_residue = ((XDMAC_REGS->XDMAC_CHID[XDMAC_RX_CH].XDMAC_CUBC & XDMAC_CUBC_Msk ) << 0);  /* "0" is a placeholder for getting the number of bytes corresponding to the data width (from channel configuration). In this case "XDMAC_CC_DWIDTH_BYTE_Val" is "0" */
MCHP_number_of_bytes_to_copy = MCHP_old_residue - MCHP_residue;
/* If there are any residual bytes to be copied from DMA FIFO */
if(MCHP_number_of_bytes_to_copy > 0UL){
MCHP_position_in_output_buffer = MCHP_total_bytes_in_output_buffer;
MCHP_start_position_in_rx_buffer = (RX_MICROCBLOCK_SIZE - (MCHP_old_residue));
%if (TLC_GENERATE_DEBUG_CODE == 1)
#ifdef MCHP_DEBUG_MODE
sprintf(MCHP_debug_buffer, "rx_buffer: %u, MCHP_dirty state:%u \n\r", MCHP_current_rx_buffer, MCHP_dirty);
MCHP_Console_Write_String(MCHP_debug_buffer);
sprintf(MCHP_debug_buffer, "MCHP_residue:%u, MCHP_old_residue:%u, MCHP_number_of_bytes_to_copy:%u, MCHP_position_in_output_buffer:%u, MCHP_start_position_in_rx_buffer:%u, MCHP_total_bytes_in_output_buffer:%u \n\r\n\r", MCHP_residue, MCHP_old_residue, MCHP_number_of_bytes_to_copy, MCHP_position_in_output_buffer, MCHP_start_position_in_rx_buffer, MCHP_total_bytes_in_output_buffer);
MCHP_Console_Write_String(MCHP_debug_buffer);
#endif
%endif
if (MCHP_current_rx_buffer == 1UL){
/* Copy from 'rx_bufferA' to the 'output_Buffer' only the useful bytes */
for(volatile uint32_t cnt = 0UL; cnt < MCHP_number_of_bytes_to_copy; cnt++){
MCHP_%<UART_NAME>_Rx_OutputBuffer[MCHP_position_in_output_buffer+cnt] = MCHP_%<UART_NAME>_Rx_bufferA[MCHP_start_position_in_rx_buffer+cnt];
}
}
else{
/* Copy from 'rx_bufferB' to the 'output_Buffer' only the useful bytes */
for(volatile uint32_t cnt = 0UL; cnt < MCHP_number_of_bytes_to_copy; cnt++){
MCHP_%<UART_NAME>_Rx_OutputBuffer[MCHP_position_in_output_buffer+cnt] = MCHP_%<UART_NAME>_Rx_bufferB[MCHP_start_position_in_rx_buffer+cnt];
}
}
}
}
MCHP_dirty = 1UL; /* mark the uBlock transfer as incomplete(fragmented) */
MCHP_old_residue = MCHP_residue;
MCHP_total_bytes_in_output_buffer += MCHP_number_of_bytes_to_copy;
} /* end of FIS code */
%closefile rx_dma_epilogue
%endfunction