%implements  MCHP_PWM_HS_FEP  "C"
%include "MCHP_Functions.tlc"		
%assign ::PWM_HS_FEP_PWMxMODSEL = -1
%assign ::PWM_HS_FEP_DIVSEL = -1
%assign ::PWM_HS_FEP_FSCL = -1
%assign ::PWM_HS_FEP_FSMINPER = -1
%assign ::PWM_HS_FEP_POLH = [ -1,-1,-1,-1,-1,-1,-1,-1 ]
%assign ::PWM_HS_FEP_POLL = [ -1,-1,-1,-1,-1,-1,-1,-1 ]
%assign ::PWM_HS_FEP_SWAP = [ -1,-1,-1,-1,-1,-1,-1,-1 ]
%assign ::PWM_HS_FEP_PWMxCLKSEL = -1
%assign ::PWM_HS_FEP_PWMx_ADTR1EN1 = [ -1,-1,-1,-1,-1,-1,-1,-1 ]
%assign ::PWM_HS_FEP_PWMx_ADTR1EN2 = [ -1,-1,-1,-1,-1,-1,-1,-1 ]
%assign ::PWM_HS_FEP_PWMx_ADTR1EN3 = [ -1,-1,-1,-1,-1,-1,-1,-1 ]
%assign ::PWM_HS_FEP_PWMx_ADTR2EN1 = [ -1,-1,-1,-1,-1,-1,-1,-1 ]
%assign ::PWM_HS_FEP_PWMx_ADTR2EN2 = [ -1,-1,-1,-1,-1,-1,-1,-1 ]
%assign ::PWM_HS_FEP_PWMx_ADTR2EN3 = [ -1,-1,-1,-1,-1,-1,-1,-1 ]
%assign ::PWM_HS_FEP_InitPeriod_RAW = [ -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 ]
%assign ::PWM_HS_FEP_DutyCycleP_RAW = [ -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 ]
%assign ::PWM_HS_FEP_DutyCycleS_RAW = [ -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 ]
%assign ::PWM_HS_FEP_InitPhase_RAW = [ -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1 ]
%assign ::PWM_HS_FEP_DeadTime_RAW = [ -1,-1,-1,-1,-1,-1,-1,-1 ]
%assign ::PWM_HS_FEP_DeadTimeAlt_RAW = [ -1,-1,-1,-1,-1,-1,-1,-1 ]
%assign ::PWM_HS_FEP_PGxTRIGA_RAW = [ -1,-1,-1,-1,-1,-1,-1,-1 ]
%assign ::PWM_HS_FEP_PGxTRIGB_RAW = [ -1,-1,-1,-1,-1,-1,-1,-1 ]
%assign ::PWM_HS_FEP_PGxTRIGC_RAW = [ -1,-1,-1,-1,-1,-1,-1,-1 ]
%function BlockTypeSetup(block, system) Output
%endfunction
%function BlockInstanceSetup(block, system) void
%if EXISTS(::MCHP_PWM_HS_FEP_PIC32EFMC_nBlocks)
%assign ::MCHP_PWM_HS_FEP_PIC32EFMC_nBlocks = ::MCHP_PWM_HS_FEP_PIC32EFMC_nBlocks + 1
%else
%assign ::MCHP_PWM_HS_FEP_PIC32EFMC_nBlocks = 1
%endif
%endfunction
%function Start(block, system) Output
%assign ::PWM_HS_FEP_PWMxMODSEL = MchpLocal2Global(block,::PWM_HS_FEP_PWMxMODSEL ,  CAST("Number",block.RTWdata.PWM_HS_FEP_PWMxMODSEL),"PWMxMODSEL" , "")
%assign ::PWM_HS_FEP_DIVSEL = MchpLocal2Global(block,::PWM_HS_FEP_DIVSEL ,  CAST("Number",block.RTWdata.PWM_HS_FEP_DIVSEL),"DIVSEL" , "")
%assign ::PWM_HS_FEP_FSCL = MchpLocal2Global(block,::PWM_HS_FEP_FSCL ,  CAST("Number",block.RTWdata.PWM_HS_FEP_FSCL),"FSCL" , "")
%assign ::PWM_HS_FEP_POLH = MchpLocal2Global(block,::PWM_HS_FEP_POLH ,  MchpVector64(block.RTWdata.PWM_HS_FEP_POLH),"POLH" , "")
%assign ::PWM_HS_FEP_POLL = MchpLocal2Global(block,::PWM_HS_FEP_POLL ,  MchpVector64(block.RTWdata.PWM_HS_FEP_POLL),"POLL" , "")
%assign ::PWM_HS_FEP_SWAP = MchpLocal2Global(block,::PWM_HS_FEP_SWAP ,  MchpVector64(block.RTWdata.PWM_HS_FEP_SWAP),"SWAP" , "")
%assign ::PWM_HS_FEP_PWMxCLKSEL = MchpLocal2Global(block,::PWM_HS_FEP_PWMxCLKSEL ,  CAST("Number",block.RTWdata.PWM_HS_FEP_PWMxCLKSEL),"PWMxCLKSEL" , "")
%assign ::PWM_HS_FEP_PWMx_ADTR1EN1 = MchpLocal2Global(block,::PWM_HS_FEP_PWMx_ADTR1EN1 ,  MchpVector64(block.RTWdata.PWM_HS_FEP_PWMx_ADTR1EN1),"PWMx_ADTR1EN1" , "")
%assign ::PWM_HS_FEP_PWMx_ADTR1EN2 = MchpLocal2Global(block,::PWM_HS_FEP_PWMx_ADTR1EN2 ,  MchpVector64(block.RTWdata.PWM_HS_FEP_PWMx_ADTR1EN2),"PWMx_ADTR1EN2" , "")
%assign ::PWM_HS_FEP_PWMx_ADTR1EN3 = MchpLocal2Global(block,::PWM_HS_FEP_PWMx_ADTR1EN3 ,  MchpVector64(block.RTWdata.PWM_HS_FEP_PWMx_ADTR1EN3),"PWMx_ADTR1EN3" , "")
%assign ::PWM_HS_FEP_PWMx_ADTR2EN1 = MchpLocal2Global(block,::PWM_HS_FEP_PWMx_ADTR2EN1 ,  MchpVector64(block.RTWdata.PWM_HS_FEP_PWMx_ADTR2EN1),"PWMx_ADTR2EN1" , "")
%assign ::PWM_HS_FEP_PWMx_ADTR2EN2 = MchpLocal2Global(block,::PWM_HS_FEP_PWMx_ADTR2EN2 ,  MchpVector64(block.RTWdata.PWM_HS_FEP_PWMx_ADTR2EN2),"PWMx_ADTR2EN2" , "")
%assign ::PWM_HS_FEP_PWMx_ADTR2EN3 = MchpLocal2Global(block,::PWM_HS_FEP_PWMx_ADTR2EN3 ,  MchpVector64(block.RTWdata.PWM_HS_FEP_PWMx_ADTR2EN3),"PWMx_ADTR2EN3" , "")
%assign ::PWM_HS_FEP_FSMINPER = MchpLocal2Global(block,::PWM_HS_FEP_FSMINPER ,  CAST("Number",block.RTWdata.PWM_HS_FEP_FSMINPER),"FSMINPER" , "")
%assign ::PWM_HS_FEP_InitPeriod_RAW = MchpLocal2Global(block,::PWM_HS_FEP_InitPeriod_RAW ,  MchpVector64(block.RTWdata.PWM_HS_FEP_InitPeriod_RAW),"InitPeriod_RAW" , "")
%assign ::PWM_HS_FEP_DutyCycleP_RAW = MchpLocal2Global(block,::PWM_HS_FEP_DutyCycleP_RAW ,  MchpVector64(block.RTWdata.PWM_HS_FEP_DutyCycleP_RAW),"DutyCycleP_RAW" , "")
%assign ::PWM_HS_FEP_DutyCycleS_RAW = MchpLocal2Global(block,::PWM_HS_FEP_DutyCycleS_RAW ,  MchpVector64(block.RTWdata.PWM_HS_FEP_DutyCycleS_RAW),"DutyCycleS_RAW" , "")
%assign ::PWM_HS_FEP_InitPhase_RAW = MchpLocal2Global(block,::PWM_HS_FEP_InitPhase_RAW ,  MchpVector64(block.RTWdata.PWM_HS_FEP_InitPhase_RAW),"InitPhase_RAW" , "")
%assign ::PWM_HS_FEP_DeadTime_RAW = MchpLocal2Global(block,::PWM_HS_FEP_DeadTime_RAW ,  MchpVector64(block.RTWdata.PWM_HS_FEP_DeadTime_RAW),"DeadTime_RAW" , "")
%assign ::PWM_HS_FEP_DeadTimeAlt_RAW = MchpLocal2Global(block,::PWM_HS_FEP_DeadTimeAlt_RAW ,  MchpVector64(block.RTWdata.PWM_HS_FEP_DeadTimeAlt_RAW),"DeadTimeAlt_RAW" , "")
%assign ::PWM_HS_FEP_PGxTRIGA_RAW = MchpLocal2Global(block,::PWM_HS_FEP_PGxTRIGA_RAW ,  MchpVector64(block.RTWdata.PWM_HS_FEP_PGxTRIGA_RAW),"PGxTRIGA_RAW" , "")
%assign ::PWM_HS_FEP_PGxTRIGB_RAW = MchpLocal2Global(block,::PWM_HS_FEP_PGxTRIGB_RAW ,  MchpVector64(block.RTWdata.PWM_HS_FEP_PGxTRIGB_RAW),"PGxTRIGB_RAW" , "")
%assign ::PWM_HS_FEP_PGxTRIGC_RAW = MchpLocal2Global(block,::PWM_HS_FEP_PGxTRIGC_RAW ,  MchpVector64(block.RTWdata.PWM_HS_FEP_PGxTRIGC_RAW),"PGxTRIGC_RAW" , "")
%assign name_PGxPHASE = CAST("String",block.RTWdata.name_PGxPHASE)
%assign name_PGxDC = CAST("String",block.RTWdata.name_PGxDC)
%assign name_PGxTRIGA = CAST("String",block.RTWdata.name_PGxTRIGA)
%assign name_PGxTRIGB = CAST("String",block.RTWdata.name_PGxTRIGB)
%assign ChOn =  MchpVector64(block.RTWdata.ChOn)
%assign PENH =  MchpVector64(block.RTWdata.PENH)
%assign PENL =  MchpVector64(block.RTWdata.PENL)
%assign PGxTRIGA_init_s =  MchpVectorDbl(block.RTWdata.PGxTRIGA_init_s)
%assign PGxTRIGB_init_s =  MchpVectorDbl(block.RTWdata.PGxTRIGB_init_s)
%assign PGxTRIGC_init_s =  MchpVectorDbl(block.RTWdata.PGxTRIGC_init_s)
%assign BlockInput_Period =  CAST("Number",block.RTWdata.BlockInput_Period)
%assign BlockInput_DutyCycle =  MchpVector64(block.RTWdata.BlockInput_DutyCycle)
%assign BlockInput_PhaseShift =  MchpVector64(block.RTWdata.BlockInput_PhaseShift)
%assign BlockInput_SEVTCMP =  MchpVector64(block.RTWdata.BlockInput_SEVTCMP)
%assign BlockInput_TRIGx =  MchpVector64(block.RTWdata.BlockInput_TRIGx)
%assign BlockInput_DeadTime =  MchpVector64(block.RTWdata.BlockInput_DeadTime)
%assign MaxPeriod_s =  MchpVectorDbl(block.RTWdata.MaxPeriod_s)
%assign InitPeriode_s =  MchpVectorDbl(block.RTWdata.InitPeriode_s)
%assign InitDutyCycleP_s =  MchpVectorDbl(block.RTWdata.InitDutyCycleP_s)
%assign InitDutyCycleS_s =  MchpVectorDbl(block.RTWdata.InitDutyCycleS_s)
%assign InitPhase_s =  MchpVectorDbl(block.RTWdata.InitPhase_s)
%assign DeadTime_s =  MchpVectorDbl(block.RTWdata.DeadTime_s)
%assign DeadTimeAlt_s =  MchpVectorDbl(block.RTWdata.DeadTimeAlt_s)
%assign MaxPeriod_RAW =  MchpVector64(block.RTWdata.MaxPeriod_RAW)
%assign MaxPeriod_ss =  MchpVectorDbl(block.RTWdata.MaxPeriod_ss)
%assign MaxDeadTimePhase_ss =  MchpVectorDbl(block.RTWdata.MaxDeadTimePhase_ss)
%assign MaxDeadTimePhase_RAW =  MchpVector64(block.RTWdata.MaxDeadTimePhase_RAW)
%assign BlockInput_VectorScalar =  CAST("Number",block.RTWdata.BlockInput_VectorScalar)
%if EXISTS(::MCHP_PWM_HS_FEP_PIC32EFMC_iBlocks)
%assign ::MCHP_PWM_HS_FEP_PIC32EFMC_iBlocks = ::MCHP_PWM_HS_FEP_PIC32EFMC_iBlocks + 1
%else
%assign ::MCHP_PWM_HS_FEP_PIC32EFMC_iBlocks = 1
%endif
%assign first = 0
%assign EOCsyncIdx = -1
%foreach idx = SIZE(ChOn,1)
%if ChOn[idx] == 1  	
%if first == 0
%assign EOCsyncIdx = %<idx>	
%endif
%assign first = first+1
%endif
%endforeach
%openfile d
%foreach idx = SIZE(ChOn,1)
%if ChOn[idx] == 1
%if idx == EOCsyncIdx	
PG%<idx+1>PER = %<MchpUint(::PWM_HS_FEP_InitPeriod_RAW[idx])>;  /* %<InitPeriode_s[idx]>s */
%else
%if ::PWM_HS_FEP_PWMxMODSEL < 4
PG%<idx+1>PER = %<MchpUint(::PWM_HS_FEP_InitPeriod_RAW[idx])>; /* Sync with PWM %<EOCsyncIdx+1> */
%else 
PG%<idx+1>PER = %<MchpUint(::PWM_HS_FEP_InitPeriod_RAW[idx])>;  /* %<InitPeriode_s[idx]>s */
%endif
%endif
%endif
%endforeach
%closefile d
%if !ISEMPTY(d)
/* Set initial PWM Period */
%<d>
%endif
%openfile d
%foreach idx = SIZE(ChOn,1)
%if ChOn[idx] == 1
%if ::PWM_HS_FEP_DutyCycleP_RAW[idx] > 0
PG%<idx+1>DC = %<MchpUint(::PWM_HS_FEP_DutyCycleP_RAW[idx])>;  /* %<InitDutyCycleP_s[idx]>s */
%endif
%endif
%endforeach
%closefile d
%if !ISEMPTY(d)
/* Set initial PWM Duty Cycles */
%<d>
%endif
%openfile d
%foreach idx = SIZE(ChOn,1)
%if ChOn[idx] == 1
%if ::PWM_HS_FEP_InitPhase_RAW[idx] > 0
PG%<idx+1>PHASE = %<MchpUint(::PWM_HS_FEP_InitPhase_RAW[idx])>;  /* %<InitPhase_s[idx]>s */
%endif
%endif
%endforeach
%closefile d
%if !ISEMPTY(d)
/* Set initial Phase */
%<d>
%endif
%openfile d
%foreach idx = SIZE(ChOn,1)
%if ChOn[idx] == 1
%if ::PWM_HS_FEP_DeadTime_RAW[idx] > 0
PG%<idx+1>DTH = %<MchpUint(::PWM_HS_FEP_DeadTime_RAW[idx])>;  /* %<DeadTime_s[idx]>s */
%endif
%endif
%endforeach
%foreach idx = SIZE(ChOn,1)
%if ChOn[idx] == 1
%if ::PWM_HS_FEP_DeadTimeAlt_RAW[idx] > 0
PG%<idx+1>DTL = %<MchpUint(::PWM_HS_FEP_DeadTimeAlt_RAW[idx])>;  /* %<DeadTimeAlt_s[idx]>s */
%endif
%endif
%endforeach
%closefile d
%if !ISEMPTY(d)
/* Set initial Dead Time */
%<d>
%endif
%openfile d
%foreach idx = SIZE(ChOn,1)
%if ChOn[idx] == 1  	
%if ::PWM_HS_FEP_PGxTRIGA_RAW[idx] >= 0
PG%<idx+1>TRIGA = %<MchpUint(::PWM_HS_FEP_PGxTRIGA_RAW[idx])>; /* Trigger A (%<PGxTRIGA_init_s[idx]>s) for PWM %<idx+1> */
%endif
%if ::PWM_HS_FEP_PGxTRIGB_RAW[idx] >= 0
PG%<idx+1>TRIGB = %<MchpUint(::PWM_HS_FEP_PGxTRIGB_RAW[idx])>; /* Trigger B (%<PGxTRIGB_init_s[idx]>s) for PWM %<idx+1> */
%endif
%if ::PWM_HS_FEP_PGxTRIGC_RAW[idx] >= 0
PG%<idx+1>TRIGC = %<MchpUint(::PWM_HS_FEP_PGxTRIGC_RAW[idx])>; /* Trigger C (%<PGxTRIGC_init_s[idx]>s) for PWM %<idx+1> */
%endif
%endif
%endforeach
%closefile d
%if !ISEMPTY(d)
/* Set Trigger (for ADC) initial values */	
%<d>
%endif
%openfile myCode
%assign myDeclaration = " /* Set PWM settings for each channels */ \n { \n /* non volatile temp variable to precompute settings */ "
%assign ImmediateUpdate = 0
/* PGxCONH */
%foreach idx = SIZE(ChOn,1)
%if ChOn[idx] == 1  	
%assign d = ""  	
%if idx == EOCsyncIdx						
R_PG%<idx+1>CONH.SOCS		= 0;	/* Start of Cycle is Local EOC */		
R_PG%<idx+1>CONH.MSTEN		= 1;	/* Broadcast set of UPDREQ & EOC to other PWMs */			
R_PG%<idx+1>CONH.UPDMOD	= %<ImmediateUpdate>;	/* PWM Update (00 next cycle, 01 Immedite) */
%assign d = "PG%<idx+1>CONHBITS R_PG%<idx+1>CONH = {0};"  							
%else
R_PG%<idx+1>CONH.SOCS		= %<EOCsyncIdx+1>;	/* Start of Cycle sync with 1-4 => PG1 PG4 - PG5 PG8 */					
R_PG%<idx+1>CONH.UPDMOD	= %<2+ImmediateUpdate>;	/* PWM Slave Update (2 next cycle, 3 immediate) */			
%assign d = "PG%<idx+1>CONHBITS R_PG%<idx+1>CONH = {0};"  			
%endif
%if !ISEMPTY(d)
PG%<idx+1>CONHbits = R_PG%<idx+1>CONH; /* -- WRITE CONFIG -- */	
%assign myDeclaration = myDeclaration + d
%endif			
%endif
%endforeach
/* PGxCONL */
%foreach idx = SIZE(ChOn,1)
%if ChOn[idx] == 1  	
%assign d = ""  	
%if idx == EOCsyncIdx				
R_PG%<idx+1>CONL.MODSEL = %<::PWM_HS_FEP_PWMxMODSEL> ;  /* PWM mode */
R_PG%<idx+1>CONL.CLKSEL = %<::PWM_HS_FEP_PWMxCLKSEL>;  /* Clock Selection */
R_PG%<idx+1>CONL.ON    = 0;  /* PWM Generator is disabled */
%assign d = "PG%<idx+1>CONLBITS R_PG%<idx+1>CONL = {0};	"  							
%else
R_PG%<idx+1>CONL.MODSEL = %<::PWM_HS_FEP_PWMxMODSEL> ;  /* PWM mode */			
R_PG%<idx+1>CONL.CLKSEL  = %<::PWM_HS_FEP_PWMxCLKSEL>;  /* Clock Selection */
R_PG%<idx+1>CONL.ON    = 1;  /* PWM Generator is enabled */		
%assign d = "PG%<idx+1>CONLBITS R_PG%<idx+1>CONL = {0};	"  			
%endif
%if !ISEMPTY(d)				
PG%<idx+1>CONLbits = R_PG%<idx+1>CONL; /* -- WRITE CONFIG -- */				
%assign myDeclaration = myDeclaration + d
%endif
%endif
%endforeach
%openfile PGxIOCONL
%foreach idx = SIZE(ChOn,1)
%if ChOn[idx] == 1  	
%assign d = ""  	
%if ::PWM_HS_FEP_SWAP[idx] == 1
R_PG%<idx+1>IOCONL.SWAP	    = 1; 		/* Swap PWMH and PWML pins */	  	
%assign d = "PG%<idx+1>IOCONLBITS R_PG%<idx+1>IOCONL = {0};	"
%endif
%if !ISEMPTY(d)
PG%<idx+1>IOCONLbits = R_PG%<idx+1>IOCONL; /* -- WRITE CONFIG -- */	
%assign myDeclaration = myDeclaration + d
%endif
%endif
%endforeach	
%closefile PGxIOCONL
%if !ISEMPTY(PGxIOCONL)
/* PGxIOCONL */
%<PGxIOCONL>
%endif
%openfile PGxIOCONH
%foreach idx = SIZE(ChOn,1)
%if ChOn[idx] == 1  	
%assign d = ""  				
%if ::PWM_HS_FEP_POLL[idx] == 1
R_PG%<idx+1>IOCONH.POLL	    = 1; 		/* PWML active low (1) */
%assign d = "PG%<idx+1>IOCONHBITS R_PG%<idx+1>IOCONH = {0};	"  	
%endif
%if ::PWM_HS_FEP_POLH[idx] == 1
R_PG%<idx+1>IOCONH.POLH	    = 1; 		/* PWMH active low (1) */
%assign d = "PG%<idx+1>IOCONHBITS R_PG%<idx+1>IOCONH = {0};	"  	
%endif
%if PENL[idx] == 1
R_PG%<idx+1>IOCONH.PENL	    = 1; 		/* Enable PWMxL */
%assign d = "PG%<idx+1>IOCONHBITS R_PG%<idx+1>IOCONH = {0};	"  	
%endif
%if PENH[idx] == 1
R_PG%<idx+1>IOCONH.PENH	    = 1; 		/* Enable PWMxH */
%assign d = "PG%<idx+1>IOCONHBITS R_PG%<idx+1>IOCONH = {0};	"  	
%endif
%if !ISEMPTY(d)
PG%<idx+1>IOCONHbits = R_PG%<idx+1>IOCONH; /* -- WRITE CONFIG -- */	
%assign myDeclaration = myDeclaration + d
%endif
%endif
%endforeach	
%closefile PGxIOCONH
%if !ISEMPTY(PGxIOCONH)
/* PGxIOCONH */
%<PGxIOCONH>
%endif
%openfile PGxEVTL
%foreach idx = SIZE(ChOn,1)
%if ChOn[idx] == 1  	
%assign d = ""  	
%if ::PWM_HS_FEP_PWMx_ADTR1EN1[idx]  == 1
R_PG%<idx+1>EVTL.ADTR1EN1 = 1; /* PWM%<idx+1> TRIG A is trig src for ADC Trig 1 */
%assign d = "PG%<idx+1>EVTLBITS R_PG%<idx+1>EVTL = {0};"
%endif
%if ::PWM_HS_FEP_PWMx_ADTR1EN2[idx]  == 1
R_PG%<idx+1>EVTL.ADTR1EN2 = 1; /* PWM%<idx+1> TRIG B is trig src for ADC Trig 1 */
%assign d = "PG%<idx+1>EVTLBITS R_PG%<idx+1>EVTL = {0};"
%endif
%if ::PWM_HS_FEP_PWMx_ADTR1EN3[idx]  == 1
R_PG%<idx+1>EVTL.ADTR1EN3 = 1; /* PWM%<idx+1> TRIG C is trig src for ADC Trig 1 */
%assign d = "PG%<idx+1>EVTLBITS R_PG%<idx+1>EVTL = {0};"
%endif
%if !ISEMPTY(d)
PG%<idx+1>EVTLbits = R_PG%<idx+1>EVTL; /* -- WRITE CONFIG -- */	
%assign myDeclaration = myDeclaration + d
%endif
%endif
%endforeach	
%closefile PGxEVTL
%if !ISEMPTY(PGxEVTL)
/* PGxEVTL */
%<PGxEVTL>
%endif			
%openfile PGxEVTH
%foreach idx = SIZE(ChOn,1)
%if ChOn[idx] == 1  	
%assign d = ""  	
%if ::PWM_HS_FEP_PWMx_ADTR2EN1[idx] == 1
R_PG%<idx+1>EVTH.ADTR2EN1 = 1; /* PWM%<idx+1> TRIG A is trig src for ADC Trig 2 */
%assign d = "PG%<idx+1>EVTHBITS R_PG%<idx+1>EVTH = {0};	"
%endif
%if ::PWM_HS_FEP_PWMx_ADTR2EN2[idx] == 1
R_PG%<idx+1>EVTH.ADTR2EN2 = 1; /* PWM%<idx+1> TRIG B is trig src for ADC Trig 2 */
%assign d = "PG%<idx+1>EVTHBITS R_PG%<idx+1>EVTH = {0};	"
%endif
%if ::PWM_HS_FEP_PWMx_ADTR2EN3[idx] == 1
R_PG%<idx+1>EVTH.ADTR2EN3 = 1; /* PWM%<idx+1> TRIG C is trig src for ADC Trig 2 */
%assign d = "PG%<idx+1>EVTHBITS R_PG%<idx+1>EVTH = {0};	"
%endif
%if !ISEMPTY(d)
PG%<idx+1>EVTHbits = R_PG%<idx+1>EVTH; /* -- WRITE CONFIG -- */	
%assign myDeclaration = myDeclaration + d
%endif
%endif
%endforeach	
%closefile PGxEVTH
%if !ISEMPTY(PGxEVTH)
/* PGxEVTH */
%<PGxEVTH>
%endif
%closefile myCode
%<myDeclaration>
%<myCode>
}
%if (::MCHP_PWM_HS_FEP_PIC32EFMC_iBlocks == ::MCHP_PWM_HS_FEP_PIC32EFMC_nBlocks)  
%openfile myCode
%assign myDeclaration = "{ /* Shared Settings for all PWM channels */ \n"
%assign d = ""
%if ::PWM_HS_FEP_DIVSEL >= 0
R_PCLKCON.DIVSEL  = %<::PWM_HS_FEP_DIVSEL>; /* Clock divide ration {2 4 8 16} */
%assign d = "PCLKCONBITS R_PCLKCON = {0};\n"
%endif
%if !ISEMPTY(d)
PCLKCONbits = R_PCLKCON;
%endif
%assign myDeclaration = myDeclaration + d
%if ::PWM_HS_FEP_FSCL > 0
FSCL = %<::PWM_HS_FEP_FSCL>; /* Frequency Scaling Circuit */	
FSMINPER = %<::PWM_HS_FEP_FSMINPER>;  /* PWM clock = clk * (%<::PWM_HS_FEP_FSCL> / %<::PWM_HS_FEP_FSMINPER>) */
%endif
%closefile myCode
%<myDeclaration>
%<myCode>
/* Turning ON the PWM Generator %<EOCsyncIdx+1>;
Thus starting all the PWM modules in unison */	
PG%<EOCsyncIdx+1>CONLbits.ON = 1; 		
}
%endif 
%endfunction
%function Outputs(block, system) Output
%assign ::PWM_HS_FEP_PWMxMODSEL = MchpLocal2Global(block,::PWM_HS_FEP_PWMxMODSEL ,  CAST("Number",block.RTWdata.PWM_HS_FEP_PWMxMODSEL),"PWMxMODSEL" , "")
%assign ::PWM_HS_FEP_DIVSEL = MchpLocal2Global(block,::PWM_HS_FEP_DIVSEL ,  CAST("Number",block.RTWdata.PWM_HS_FEP_DIVSEL),"DIVSEL" , "")
%assign ::PWM_HS_FEP_FSCL = MchpLocal2Global(block,::PWM_HS_FEP_FSCL ,  CAST("Number",block.RTWdata.PWM_HS_FEP_FSCL),"FSCL" , "")
%assign ::PWM_HS_FEP_POLH = MchpLocal2Global(block,::PWM_HS_FEP_POLH ,  MchpVector64(block.RTWdata.PWM_HS_FEP_POLH),"POLH" , "")
%assign ::PWM_HS_FEP_POLL = MchpLocal2Global(block,::PWM_HS_FEP_POLL ,  MchpVector64(block.RTWdata.PWM_HS_FEP_POLL),"POLL" , "")
%assign ::PWM_HS_FEP_SWAP = MchpLocal2Global(block,::PWM_HS_FEP_SWAP ,  MchpVector64(block.RTWdata.PWM_HS_FEP_SWAP),"SWAP" , "")
%assign ::PWM_HS_FEP_PWMxCLKSEL = MchpLocal2Global(block,::PWM_HS_FEP_PWMxCLKSEL ,  CAST("Number",block.RTWdata.PWM_HS_FEP_PWMxCLKSEL),"PWMxCLKSEL" , "")
%assign ::PWM_HS_FEP_PWMx_ADTR1EN1 = MchpLocal2Global(block,::PWM_HS_FEP_PWMx_ADTR1EN1 ,  MchpVector64(block.RTWdata.PWM_HS_FEP_PWMx_ADTR1EN1),"PWMx_ADTR1EN1" , "")
%assign ::PWM_HS_FEP_PWMx_ADTR1EN2 = MchpLocal2Global(block,::PWM_HS_FEP_PWMx_ADTR1EN2 ,  MchpVector64(block.RTWdata.PWM_HS_FEP_PWMx_ADTR1EN2),"PWMx_ADTR1EN2" , "")
%assign ::PWM_HS_FEP_PWMx_ADTR1EN3 = MchpLocal2Global(block,::PWM_HS_FEP_PWMx_ADTR1EN3 ,  MchpVector64(block.RTWdata.PWM_HS_FEP_PWMx_ADTR1EN3),"PWMx_ADTR1EN3" , "")
%assign ::PWM_HS_FEP_PWMx_ADTR2EN1 = MchpLocal2Global(block,::PWM_HS_FEP_PWMx_ADTR2EN1 ,  MchpVector64(block.RTWdata.PWM_HS_FEP_PWMx_ADTR2EN1),"PWMx_ADTR2EN1" , "")
%assign ::PWM_HS_FEP_PWMx_ADTR2EN2 = MchpLocal2Global(block,::PWM_HS_FEP_PWMx_ADTR2EN2 ,  MchpVector64(block.RTWdata.PWM_HS_FEP_PWMx_ADTR2EN2),"PWMx_ADTR2EN2" , "")
%assign ::PWM_HS_FEP_PWMx_ADTR2EN3 = MchpLocal2Global(block,::PWM_HS_FEP_PWMx_ADTR2EN3 ,  MchpVector64(block.RTWdata.PWM_HS_FEP_PWMx_ADTR2EN3),"PWMx_ADTR2EN3" , "")
%assign ::PWM_HS_FEP_FSMINPER = MchpLocal2Global(block,::PWM_HS_FEP_FSMINPER ,  CAST("Number",block.RTWdata.PWM_HS_FEP_FSMINPER),"FSMINPER" , "")
%assign ::PWM_HS_FEP_InitPeriod_RAW = MchpLocal2Global(block,::PWM_HS_FEP_InitPeriod_RAW ,  MchpVector64(block.RTWdata.PWM_HS_FEP_InitPeriod_RAW),"InitPeriod_RAW" , "")
%assign ::PWM_HS_FEP_DutyCycleP_RAW = MchpLocal2Global(block,::PWM_HS_FEP_DutyCycleP_RAW ,  MchpVector64(block.RTWdata.PWM_HS_FEP_DutyCycleP_RAW),"DutyCycleP_RAW" , "")
%assign ::PWM_HS_FEP_DutyCycleS_RAW = MchpLocal2Global(block,::PWM_HS_FEP_DutyCycleS_RAW ,  MchpVector64(block.RTWdata.PWM_HS_FEP_DutyCycleS_RAW),"DutyCycleS_RAW" , "")
%assign ::PWM_HS_FEP_InitPhase_RAW = MchpLocal2Global(block,::PWM_HS_FEP_InitPhase_RAW ,  MchpVector64(block.RTWdata.PWM_HS_FEP_InitPhase_RAW),"InitPhase_RAW" , "")
%assign ::PWM_HS_FEP_DeadTime_RAW = MchpLocal2Global(block,::PWM_HS_FEP_DeadTime_RAW ,  MchpVector64(block.RTWdata.PWM_HS_FEP_DeadTime_RAW),"DeadTime_RAW" , "")
%assign ::PWM_HS_FEP_DeadTimeAlt_RAW = MchpLocal2Global(block,::PWM_HS_FEP_DeadTimeAlt_RAW ,  MchpVector64(block.RTWdata.PWM_HS_FEP_DeadTimeAlt_RAW),"DeadTimeAlt_RAW" , "")
%assign ::PWM_HS_FEP_PGxTRIGA_RAW = MchpLocal2Global(block,::PWM_HS_FEP_PGxTRIGA_RAW ,  MchpVector64(block.RTWdata.PWM_HS_FEP_PGxTRIGA_RAW),"PGxTRIGA_RAW" , "")
%assign ::PWM_HS_FEP_PGxTRIGB_RAW = MchpLocal2Global(block,::PWM_HS_FEP_PGxTRIGB_RAW ,  MchpVector64(block.RTWdata.PWM_HS_FEP_PGxTRIGB_RAW),"PGxTRIGB_RAW" , "")
%assign ::PWM_HS_FEP_PGxTRIGC_RAW = MchpLocal2Global(block,::PWM_HS_FEP_PGxTRIGC_RAW ,  MchpVector64(block.RTWdata.PWM_HS_FEP_PGxTRIGC_RAW),"PGxTRIGC_RAW" , "")
%assign name_PGxPHASE = CAST("String",block.RTWdata.name_PGxPHASE)
%assign name_PGxDC = CAST("String",block.RTWdata.name_PGxDC)
%assign name_PGxTRIGA = CAST("String",block.RTWdata.name_PGxTRIGA)
%assign name_PGxTRIGB = CAST("String",block.RTWdata.name_PGxTRIGB)
%assign ChOn =  MchpVector64(block.RTWdata.ChOn)
%assign PENH =  MchpVector64(block.RTWdata.PENH)
%assign PENL =  MchpVector64(block.RTWdata.PENL)
%assign PGxTRIGA_init_s =  MchpVectorDbl(block.RTWdata.PGxTRIGA_init_s)
%assign PGxTRIGB_init_s =  MchpVectorDbl(block.RTWdata.PGxTRIGB_init_s)
%assign PGxTRIGC_init_s =  MchpVectorDbl(block.RTWdata.PGxTRIGC_init_s)
%assign BlockInput_Period =  CAST("Number",block.RTWdata.BlockInput_Period)
%assign BlockInput_DutyCycle =  MchpVector64(block.RTWdata.BlockInput_DutyCycle)
%assign BlockInput_PhaseShift =  MchpVector64(block.RTWdata.BlockInput_PhaseShift)
%assign BlockInput_SEVTCMP =  MchpVector64(block.RTWdata.BlockInput_SEVTCMP)
%assign BlockInput_TRIGx =  MchpVector64(block.RTWdata.BlockInput_TRIGx)
%assign BlockInput_DeadTime =  MchpVector64(block.RTWdata.BlockInput_DeadTime)
%assign MaxPeriod_s =  MchpVectorDbl(block.RTWdata.MaxPeriod_s)
%assign InitPeriode_s =  MchpVectorDbl(block.RTWdata.InitPeriode_s)
%assign InitDutyCycleP_s =  MchpVectorDbl(block.RTWdata.InitDutyCycleP_s)
%assign InitDutyCycleS_s =  MchpVectorDbl(block.RTWdata.InitDutyCycleS_s)
%assign InitPhase_s =  MchpVectorDbl(block.RTWdata.InitPhase_s)
%assign DeadTime_s =  MchpVectorDbl(block.RTWdata.DeadTime_s)
%assign DeadTimeAlt_s =  MchpVectorDbl(block.RTWdata.DeadTimeAlt_s)
%assign MaxPeriod_RAW =  MchpVector64(block.RTWdata.MaxPeriod_RAW)
%assign MaxPeriod_ss =  MchpVectorDbl(block.RTWdata.MaxPeriod_ss)
%assign MaxDeadTimePhase_ss =  MchpVectorDbl(block.RTWdata.MaxDeadTimePhase_ss)
%assign MaxDeadTimePhase_RAW =  MchpVector64(block.RTWdata.MaxDeadTimePhase_RAW)
%assign BlockInput_VectorScalar =  CAST("Number",block.RTWdata.BlockInput_VectorScalar)
%assign iChOn = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
%assign iiChOn = 0
%foreach idx=SIZE(ChOn,1)
%if ChOn[idx] == 1
%assign iChOn[iiChOn] = idx
%assign iiChOn = iiChOn +1
%endif
%endforeach
%assign IndexOutput = 0
%assign IndexInput = 0
%assign IndexVect = 0
%assign first = 0
%assign EOCsyncIdx = -1
%foreach idx = SIZE(ChOn,1)
%if ChOn[idx] == 1  	
%if first == 0
%assign EOCsyncIdx = %<idx>	
%endif
%assign first = first+1
%endif
%endforeach
%assign BlockInput_xx = BlockInput_Period			
%foreach idx= SIZE(BlockInput_xx,1)	
%if BlockInput_xx[idx] != -1
%assign yConnected = LibBlockInputSignalConnected(IndexInput)
%switch BlockInput_VectorScalar		
%case 0	
%assign y = LibBlockInputSignal(IndexInput, "", "",0)					
%assign y_dtId = LibBlockInputSignalDataTypeId(IndexInput)
%assign IndexInput = IndexInput + 1							
%break
%case 1 
%assign y = LibBlockInputSignal(IndexInput, "", "",IndexVect)		
%assign y_dtId = LibBlockInputSignalDataTypeId(IndexInput)
%assign IndexVect = IndexVect + 1
%break
%endswitch
%assign yScale = yScaleFct(y,y_dtId,BlockInput_xx[idx],MaxPeriod_RAW[iChOn[idx]],MaxPeriod_ss[iChOn[idx]],0)		
%if yConnected
%if ::PWM_HS_FEP_PWMxMODSEL < 4    
PG%<iChOn[idx]+1>PER = %<yScale>;	/* Update PWM%<iChOn[idx]+1> Period */
%else
%foreach idxx = SIZE(ChOn,1)
%if ChOn[idxx] == 1  	
PG%<idxx+1>PER = %<yScale>;	/* Update PWM%<idxx+1> Period */
%endif
%endforeach
%endif
%endif
%endif
%endforeach	
%assign IndexInput = IndexInput + (IndexVect != 0)
%assign IndexVect = 0
%assign tmpReverseOrderWrite = ""
%assign BlockInput_xx = BlockInput_DutyCycle
%foreach idx= SIZE(BlockInput_xx,1)	
%if BlockInput_xx[idx] != -1
%assign yConnected = LibBlockInputSignalConnected(IndexInput)
%switch BlockInput_VectorScalar						
%case 0	
%assign y = LibBlockInputSignal(IndexInput, "", "",0)			
%assign y_dtId = LibBlockInputSignalDataTypeId(IndexInput)		 				
%assign IndexInput = IndexInput + 1		
%break
%case 1 
%assign y = LibBlockInputSignal(IndexInput, "", "",IndexVect)		
%assign y_dtId = LibBlockInputSignalDataTypeId(IndexInput)
%assign IndexVect = IndexVect + 1
%break
%endswitch
%if yConnected
%assign yScale = yScaleFct(y,y_dtId,BlockInput_xx[idx],MaxPeriod_RAW[iChOn[idx]],MaxPeriod_ss[iChOn[idx]],0)		
%assign tmpReverseOrderWrite = "PG%<iChOn[idx]+1>DC = %<yScale>;		/* Update PWM%<iChOn[idx]+1> Duty Cycle */ " + tmpReverseOrderWrite											
%endif
%endif
%endforeach	
%if ISEMPTY(tmpReverseOrderWrite) == 0
/* Update PWM Duty Cycle */
%<tmpReverseOrderWrite>
%endif
%assign IndexInput = IndexInput + (IndexVect != 0)
%assign IndexVect = 0
%assign BlockInput_xx = BlockInput_PhaseShift			
%foreach idx= SIZE(BlockInput_xx,1)	
%if BlockInput_xx[idx] != -1
%assign yConnected = LibBlockInputSignalConnected(IndexInput)
%switch BlockInput_VectorScalar		
%case 0	
%assign y = LibBlockInputSignal(IndexInput, "", "",0)		
%assign y_dtId = LibBlockInputSignalDataTypeId(IndexInput)						
%assign IndexInput = IndexInput + 1		
%break
%case 1 
%assign y = LibBlockInputSignal(IndexInput, "", "",IndexVect)		
%assign y_dtId = LibBlockInputSignalDataTypeId(IndexInput)						
%assign IndexVect = IndexVect + 1
%break
%endswitch
%assign yScale = yScaleFct(y,y_dtId,BlockInput_xx[idx],MaxDeadTimePhase_RAW[iChOn[idx]],MaxDeadTimePhase_ss[iChOn[idx]],0)
%if yConnected
PG%<iChOn[idx]+1>PHASE = %<yScale>;	/* Update PWM%<iChOn[idx]+1> Phase Shift */
%endif
%endif
%endforeach	
%assign IndexInput = IndexInput + (IndexVect != 0)
%assign IndexVect = 0
%if EOCsyncIdx != -1
PG%<EOCsyncIdx+1>STATbits.UPDREQ = 1;	/* synchronized UPDATE */
%endif
%endfunction
%function Update(block, system) Output
%endfunction
%function MCHP_MAX0(val) void
%if val < 0
%return CAST("Number",0)
%else
%return CAST("Number",val)
%endif
%endfunction	
%function yScaleFct(y,y_dtId,BlockInput_xx,MaxPeriod_RAW,MaxPeriod_ss,Rshift) void
%switch y_dtId
%case 0
%assign y_CAST = "Real"		
%break
%case 1
%assign y_CAST = "Real32"	
%break
%endswitch 		
%switch Rshift
%case 0
%assign RshiftMult = 1
%break
%default
%assign RshiftMult = 1.0/(1 << Rshift)
%break
%endswitch
%switch BlockInput_xx
%case 1		
%if Rshift > 0
%assign yScale = "(%<y> >> %<Rshift>)"
%else
%assign yScale = y
%endif
%break
%case 10	
%assign yScale = "((unsigned int)( %<y>  *  %< CAST(y_CAST, MaxPeriod_RAW * RshiftMult) >  ))"
%break
%case 11	
%assign yScale = "((unsigned int)( %<y>  *  %< CAST(y_CAST, 0.5*MaxPeriod_RAW * RshiftMult) >  +  %< CAST(y_CAST, 0.5*MaxPeriod_RAW*RshiftMult) >  ))"
%break
%case 12	
%assign yScale = "((unsigned int)( %<y>  *  %< CAST(y_CAST, MaxPeriod_RAW*RshiftMult/MaxPeriod_ss) >  ))"
%break
%endswitch
%return yScale
%endfunction
