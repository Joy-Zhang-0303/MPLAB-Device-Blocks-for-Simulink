#
# File: MCHP_pic32.tmf
#
#--------------------------------------------------------------
#   Embedded Coder for Microchip dsPIC30/dsPIC33/PIC24 family. |
#   Generate .c and .h files from your Matlab/simulink model   |
#   and compile the diagram to .hex / .elf or .coff file that  |
#   can be downloaded directly into the microcontroller        |
#                                                              |
#      The Microchip name PIC, dsPIC, and MPLAB are            |
#      registered trademarks of Microchip Technology Inc.      |
#      MATLAB, Simulink, and Real-Time Workshop are            |
#      registered trademarks of The MathWorks, Inc.            |
#                                                              |
#--------------------------------------------------------------
#------------------------ Macros read by make_rtw ------------------------------
MAKECMD          = "|>MATLAB_BIN<|/|>ARCH<|/gmake"
#SHELL            = cmd / sh for windows / linux
#HOST             = |>HOST_PLATFORM<|
HOST            = ANY
BUILD            = yes
BUILD_SUCCESS    = +++ Created
SYS_TARGET_FILE  = MCHP_pic32_stf.tlc
MAKEFILE_FILESEP = /
#---------------------- Tokens expanded by make_rtw ----------------------------
#
# The following tokens, when wrapped with "|>" and "<|" are expanded by the
# Real-Time Workshop build procedure.
#
#
#  ---  ERT-only symbols:
#  INTEGER_CODE        - yes (1) or no (0): Is generated code purely integer
#  MAT_FILE            - yes (1) or no (0): Should mat file logging be done; if 0, the generated code runs indefinitely
#  MULTI_INSTANCE_CODE - Is the generated code multi instantiable (1/0)?
#  ADD_MDL_NAME_TO_GLOBALS - Do we add the model name to global 
#                        identifiers (1/0)?
#  TERMFCN             - include terminate function
#  ONESTEPFCN          - include one-step function
#  --- Shared with ERT and GRT formats:
#  MODEL_NAME          - Name of the Simulink block diagram
#  MODEL_MODULES       - Any additional generated source modules
#  MAKEFILE_NAME       - Name of makefile created from template makefile <model>.mk
#  MATLAB_ROOT         - Path to where MATLAB is installed.
#  MATLAB_BIN          - Path to MATLAB executable.
#  S_FUNCTIONS         - List of additional S-function modules.
#  S_FUNCTIONS_LIB     - List of S-functions libraries to link. 
#  HASCPPSFUNCTION     - Are we compiling any C++ S-Function as .obj(1/0)
#  NUMST               - Number of sample times
#  NCSTATES            - Number of continuous states
#  COMPUTER            - Computer type. See the MATLAB computer command.
#  BUILDARGS           - Options passed in at the command line.
#  MULTITASKING        - yes (1) or no (0): Is solver mode multitasking
#  EXT_MODE            - yes (1) or no (0): Build for external mode
#  EXTMODE_TRANSPORT   - Index of transport mechanism (e.g. tcpip, serial) for extmode
#  EXTMODE_STATIC      - yes (1) or no (0): Use static instead of dynamic mem alloc.
#  EXTMODE_STATIC_SIZE - Size of static memory allocation buffer.
#  START_EXPAND_INCLUDES
#  EXPAND_DIR_NAME
#  END_EXPAND_INCLUDES

#  INTEGER_CODE        - yes (1) or no (0): Is generated code purely integer
#  MAT_FILE            - yes (1) or no (0): Should mat file logging be done,
#                        if 0, the generated code runs indefinitely
#  MULTI_INSTANCE_CODE - Is the generated code multi instantiable (1/0)?
#  MODELREFS           - List of referenced models
#  TGT_FCN_LIB         - Target function (code replacement) library to use
#  SHRLIBTARGET        - Is this build intended for generation of a shared library instead 
#                        of executable (1/0)?
#  MAKEFILEBUILDER_TGT - Is this build performed by the MakefileBuilder class
#                        e.g. to create a PIL executable?
#  STANDALONE_SUPPRESS_EXE - Build the standalone target but only create object code modules 
#                            and do not build an executable



MODEL                   = |>MODEL_NAME<|
MODULES                 = |>MODEL_MODULES<|
#MODULES_OBJ            = |>MODEL_MODULES_OBJ<|
#PRODUCT                 = |>PRODUCT<|
MAKEFILE                = |>MAKEFILE_NAME<|
MATLAB_ROOT             = |>MATLAB_ROOT<|
ALT_MATLAB_ROOT         = |>ALT_MATLAB_ROOT<|
MASTER_ANCHOR_DIR       = |>MASTER_ANCHOR_DIR<|
START_DIR               = |>START_DIR<|
S_FUNCTIONS             = |>S_FUNCTIONS<|
S_FUNCTIONS_LIB         = |>S_FUNCTIONS_LIB<|
NUMST                   = |>NUMST<|
NCSTATES                = |>NCSTATES<|
COMPUTER                = |>COMPUTER<|
BUILDARGS               = |>BUILDARGS<|
MULTITASKING            = |>MULTITASKING<|
INTEGER_CODE            = |>INTEGER_CODE<|
MAT_FILE                = |>MAT_FILE<|
ALLOCATIONFCN           = |>GENERATE_ALLOC_FCN<|
ONESTEPFCN              = |>COMBINE_OUTPUT_UPDATE_FCNS<|
TERMFCN                 = |>INCLUDE_MDL_TERMINATE_FCN<|
B_ERTSFCN               = |>GENERATE_ERT_S_FUNCTION<|
MEXEXT                  = |>MEXEXT<|
EXT_MODE                = |>EXT_MODE<|
TMW_EXTMODE_TESTING     = |>TMW_EXTMODE_TESTING<|
EXTMODE_TRANSPORT       = |>EXTMODE_TRANSPORT<|
EXTMODE_STATIC          = |>EXTMODE_STATIC_ALLOC<|
EXTMODE_STATIC_SIZE     = |>EXTMODE_STATIC_ALLOC_SIZE<|
MULTI_INSTANCE_CODE     = |>MULTI_INSTANCE_CODE<|
CLASSIC_INTERFACE       = |>CLASSIC_INTERFACE<|

GEN_SAMPLE_MAIN         = |>GEN_SAMPLE_MAIN<|
TARGET_LANG_EXT         = |>TARGET_LANG_EXT<|
PORTABLE_WORDSIZES      = |>PORTABLE_WORDSIZES<|
SHRLIBTARGET            = |>SHRLIBTARGET<|
MAKEFILEBUILDER_TGT     = |>MAKEFILEBUILDER_TGT<|
STANDALONE_SUPPRESS_EXE = |>STANDALONE_SUPPRESS_EXE<|
OPTIMIZATION_FLAGS      = |>OPTIMIZATION_FLAGS<|
ADDITIONAL_LDFLAGS      = |>ADDITIONAL_LDFLAGS<|
INTERLEAVED_COMPLEX_FLAGS = |>INTERLEAVED_COMPLEX_FLAGS<|
DEFINES_CUSTOM          = |>DEFINES_CUSTOM<|
DEFINES_OTHER           = |>DEFINES_OTHER<|
COMPILE_FLAGS_OTHER     = |>COMPILE_FLAGS_OTHER<|
SYSTEM_LIBS             = |>SYSTEM_LIBS<|
MODEL_HAS_DYNAMICALLY_LOADED_SFCNS = |>MODEL_HAS_DYNAMICALLY_LOADED_SFCNS<|

#--------------------------- Model and reference models -----------------------
MODELREFS                 = |>MODELREFS<|
MODELLIB                  = |>MODELLIB<|
MODELREF_LINK_LIBS        = |>MODELREF_LINK_LIBS<|
MODELREF_LINK_RSPFILE     = |>MODELREF_LINK_RSPFILE_NAME<|
MODELREF_INC_PATH         = |>START_MDLREFINC_EXPAND_INCLUDES<|-I"|>MODELREF_INC_PATH<|" |>END_MDLREFINC_EXPAND_INCLUDES<|

TGT_FCN_LIB             = |>TGT_FCN_LIB<|
SHARED_SRC              = |>SHARED_SRC<|
SHARED_SRC_DIR          = |>SHARED_SRC_DIR<|
SHARED_BIN_DIR          = |>SHARED_BIN_DIR<|
SHARED_LIB              = |>SHARED_LIB<|

#--------------Simplify relative path -------------------------------
# xc16 might fail with path like ../../../../slprj/MCHP_pic32_stf/Microstick_II_PlusDevBoard_33EP128MC202_Temperature_PIL_Sub/Microstick_II_PlusDevBoard_33EP128MC202_Temperature_PIL_Sub_rtwlib_lib.a
MODELREF_LINK_LIBS := $(abspath  $(MODELREF_LINK_LIBS))


# warning: |>RELATIVE_PATH_TO_ANCHOR<| is different from MAtlab 2013a version (pointing to a folder beyong)
RELATIVE_PATH_TO_ANCHOR   = |>RELATIVE_PATH_TO_ANCHOR<|
MODELREF_TARGET_TYPE       = |>MODELREF_TARGET_TYPE<|

#-- For gcc, link model reference libraries as a group to resolve circular references ---
#   (NOTE: Clang does not recognize these switches but it already resolves circular references)
#MODELREF_LINK_LIBS_GROUP = |>MODELREF_LINK_LIBS<|
#ifeq ($(COMPUTER),GLNXA64)
  MODELREF_LINK_LIBS_GROUP = -Wl,--start-group $(MODELREF_LINK_LIBS) -Wl,--end-group
#endif

#-- In the case when directory name contains space ---
ifneq ($(MATLAB_ROOT),$(ALT_MATLAB_ROOT))
	MATLAB_ROOT := $(ALT_MATLAB_ROOT)
endif
# if MATLAB_ROOT has space (for system with no 8.3 compatibility mode, then any requirement of code from the matlab folder will fail to compile. That is the case for PIL or External Mode for ex.)


#--------------------------- Compatibility TRICKS -------------------------------

# Matlab R2020b: Instrumented code place makefile in the instrumented subfolder with no sources. Sources is one folder up.
# not OK if intrumenting the code ?
#ifeq (,$(wildcard $(MODULES)))	
#	MODULES := $(addprefix ../,$(MODULES))
#endif


#--------------------------- Backward Compabitility -------------------------------
# Declare variable that does not exist in older version with empty counterpart
STRING1 = |>SYSTEM_LIBS
STRING2 = <|
ifeq ($(SYSTEM_LIBS),$(STRING1)$(STRING2)) # split TMF variables for not beeing replaced
	SYSTEM_LIBS = 
endif
STRING1 = |>DEFINES_OTHER
STRING2 = <|
ifeq ($(DEFINES_OTHER),$(STRING1)$(STRING2)) # split TMF variables for not beeing replaced
	DEFINES_OTHER = 
endif
STRING1 = |>COMPILE_FLAGS_OTHER
STRING2 = <|
ifeq ($(COMPILE_FLAGS_OTHER),$(STRING1)$(STRING2)) # split TMF variables for not beeing replaced
	COMPILE_FLAGS_OTHER = 
endif

STRING1 = |>INTERLEAVED_COMPLEX_FLAGS
STRING2 = <|
ifeq ($(INTERLEAVED_COMPLEX_FLAGS),$(STRING1)$(STRING2)) # split TMF variables for not beeing replaced
	INTERLEAVED_COMPLEX_FLAGS = 0
endif

STRING1 = |>DEFINES_CUSTOM
STRING2 = <|
ifeq ($(DEFINES_CUSTOM),$(STRING1)$(STRING2)) # split TMF variables for not beeing replaced
	DEFINES_CUSTOM = 
endif

STRING1 = |>MODEL_HAS_DYNAMICALLY_LOADED_SFCNS
STRING2 = <|
ifeq ($(MODEL_HAS_DYNAMICALLY_LOADED_SFCNS),$(STRING1)$(STRING2)) # split TMF variables for not beeing replaced
	MODEL_HAS_DYNAMICALLY_LOADED_SFCNS = 0
endif

STRING1 = |>GENERATE_ALLOC_FCN
STRING2 = <|
ifeq ($(ALLOCATIONFCN),$(STRING1)$(STRING2)) # split TMF variables for not beeing replaced
	ALLOCATIONFCN = 
endif


#--------------------------- Tool Specifications -------------------------------

AssemblyListing = |>AssemblyListing<|
ProduceHexOutput = |>ProduceHexOutput<|

GCC1    := |>GCC1<|
AR1     = |>AR1<|
BIN2HEX1 = |>BIN2HEX<|
OBJDUMP1 = |>OBJDUMP<|

GCC1 :=  $(basename $(GCC1))

GCCPATH	:= |>GCCPATH<|
ifeq ($(strip $(GCCPATH)),)
	CC   = $(GCC1)
	CPP  = $(GCC1)
	LD   = $(GCC1)
	AR   = $(AR1) -r 
	BIN2HEX = $(BIN2HEX1)
	OBJDUMP = $(OBJDUMP1)	
else
	CC   = "$(GCCPATH)/$(GCC1)"
	CPP  = "$(GCCPATH)/$(GCC1)"
	LD   = "$(GCCPATH)/$(GCC1)"
	AR   = "$(GCCPATH)/$(AR1)" -r 
	BIN2HEX = "$(GCCPATH)/$(BIN2HEX1)"
	OBJDUMP = "$(GCCPATH)/$(OBJDUMP1)"		
endif

# ifeq ($(HOST),PC)
ifeq ($(COMPUTER),GLNXA64)
	DEL = rm -rf
	SHELL = sh
else
	DEL = del /Q
	SHELL = cmd
endif

#------------------------------ Others pic32 blockset parameters --------------
EXTMODE_DATA_UPLOAD = |>EXTMODE_DATA_UPLOAD<|

OPTIM_GCC 		= |>OPTIM_GCC<|
LDFLAGS 		= |>LDFLAGS<|
LINKER_SCRIPT 	= "|>LINKER_SCRIPT<|"
PIC_LIB 		= |>PIC_LIB<|
PIC_INCLUDES 	= |>PIC_INCLUDES<|
PIC_REF 		= |>PIC_REF<|

#-- always add one space just before -Xlinker solve possible ambiguity while using -Wl flag. Solve problem when LDFLAGS starts with -Xlinker (old style)
LDFLAGS := $(subst -Xlinker, -Xlinker,$(LDFLAGS))


MCPU  			   = -mprocessor=$(PIC_REF)
PROGRAM_FILE_EXT   = .elf

T_LINKER_SCRIPT = -Wl

LDLIBPIC = $(PIC_LIB)


CC_OPTS 		= $(MCPU)  $(OPTIM_GCC) $(OPTS)

ifeq ($(INTEGER_CODE),1)
	CC_OPTS 		+= -DINTEGER_CODE=1
endif

OBJ_EXT =.o
CCOUTPUTFLAG = -o


#----------------------------- External mode -----------------------------------
# added OPTS: from make file call, define MemUnit_T=uint8_T and MEM_UNIT_BYTES=, usefull for PIL or external mode
# EXTMODE_DISABLESIGNALMONITORING EXTMODE_DISABLE_ARGS_PROCESSING  MULTITASKING
# -DEXTMODE_DISABLESIGNALMONITORING=1

EXT_SRC = 

ifeq ($(EXT_MODE),1)
	#---Compiler and Linker settings---
    ifeq ($(MULTITASKING),1)
		LDFLAGS += -Wl,--wrap,_SetParam
    endif

	CC_OPTS += -DEXT_MODE=1 -DEXTMODE_DISABLEPRINTF=1 -DEXTMODE_DISABLETESTING=1 -DEXTMODE_DISABLE_ARGS_PROCESSING=1
    ifeq ($(EXTMODE_DATA_UPLOAD),0)
		CC_OPTS += -DEXTMODE_DISABLESIGNALMONITORING=1
    endif

	#---required files---

	#external mode sources
	EXT_SRC  += ext_svr.c updown.c ext_work.c 

	# static memory management (optional)
    ifeq ($(EXTMODE_STATIC),1)
	  EXT_SRC += mem_mgr.c
	  CC_OPTS +=  -DEXTMODE_STATIC=1 -DEXTMODE_STATIC_SIZE=$(EXTMODE_STATIC_SIZE)
    endif

	# add rtiostream_utils.c
	EXT_SRC += $(S_FUNCTIONS) # add rtiostream_utils.c from R2013 to ~R2018?     
endif

#------------------------------ parameter controlled from simulink ----------------



# Keep following line, help the Matlab programming tool to find the programmer.
# Additional info : PICREF{|>PIC_REF<|} PROGRAMMER{|>MCHP_PROGRAMMER<|}

#------------------------------ Include Path -----------------------------------
#

# Additional includes 
ADD_INCLUDES += \
|>START_EXPAND_INCLUDES<|	-I|>EXPAND_DIR_NAME<| \
|>END_EXPAND_INCLUDES<|

INCLUDES = -I. -I$(RELATIVE_PATH_TO_ANCHOR) $(USER_INCLUDES) \
	$(INSTRUMENT_INCLUDES) $(ADD_INCLUDES)

# MATLAB_INCLUDES = \
# 	-I"$(MATLAB_ROOT)/rtw/c/ert" \
# 	-I"$(MATLAB_ROOT)/extern/include" \
# 	-I"$(MATLAB_ROOT)/simulink/include" \
# 	-I"$(MATLAB_ROOT)/rtw/c/src" \
# 	-I"$(MATLAB_ROOT)/rtw/c/src/ext_mode/common"
# 
# # Additional includes
# #
# ADD_INCLUDES = \
# |>START_EXPAND_INCLUDES<|	-I"|>EXPAND_DIR_NAME<|" \
# |>END_EXPAND_INCLUDES<|
# 
# 
# SHARED_INCLUDES =
# ifneq ($(SHARED_SRC_DIR),)
# 	SHARED_INCLUDES = -I"$(SHARED_SRC_DIR)"
# endif
# 
# INCLUDES = -I. -I"$(RELATIVE_PATH_TO_ANCHOR)" $(MATLAB_INCLUDES) $(ADD_INCLUDES) \
# 			 $(PIC_INCLUDES) $(MODELREF_INC_PATH) \
# 			 $(SHARED_INCLUDES) \
# 			 $(USER_INCLUDES) $(INSTRUMENT_INCLUDES) $(USER_INCLUDES)


#--------------------------- Backward Compabitility -------------------------------
#ifeq ($(EXT_MODE),1)	
    ifeq (,$(findstring /simulink/include,$(ADD_INCLUDES)))  # apply to OLD matlab release only
		# add some required includes for external mode
		ADD_INCLUDES += \
			-I$(MATLAB_ROOT)/rtw/c/ert \
			-I$(MATLAB_ROOT)/extern/include \
			-I$(MATLAB_ROOT)/simulink/include \
			-I$(MATLAB_ROOT)/rtw/c/src/ext_mode/common \
			-I$(MATLAB_ROOT)/rtw/c/src 

		# required for PIl with R2012a
        ifneq ($(SHARED_SRC_DIR),)
			ADD_INCLUDES += -I"$(SHARED_SRC_DIR)"
        endif   


    endif
#endif

#-------------------------------- C Flags --------------------------------------
# General User Options

# New : to support Continuous States ? find in "Upgrading from V3.2.1 or V3.2"
#removed -DHAVESTDIO as we do not use STDIO input/output
# not added: -DADD_MDL_NAME_TO_GLOBALS=$(ADD_MDL_NAME_TO_GLOBALS)
CPP_REQ_DEFINES1 = -DMODEL=$(MODEL) -DNUMST=$(NUMST) -DNCSTATES=$(NCSTATES) \
		  -DMAT_FILE=$(MAT_FILE) -DINTEGER_CODE=$(INTEGER_CODE) \
		  -DONESTEPFCN=$(ONESTEPFCN) -DTERMFCN=$(TERMFCN) \
		  -DMULTI_INSTANCE_CODE=$(MULTI_INSTANCE_CODE) \
		  -DCLASSIC_INTERFACE=$(CLASSIC_INTERFACE)\
		  -DALLOCATIONFCN=$(ALLOCATIONFCN)\
		  



#!if "$(MODELREF_TARGET_TYPE)" == "SIM"
#CPP_REQ_DEFINES = $(CPP_REQ_DEFINES) $(MDLREF_FLAG)
#!else
#CPP_REQ_DEFINES = $(CPP_REQ_DEFINES) -DMT=$(MULTITASKING)
#!endif		

ifneq ($(ENABLE_SLEXEC_SSBRIDGE), 0)
    ifeq ($(MODELREF_TARGET_TYPE),SIM)
        CPP_REQ_DEFINES1 += -DENABLE_SLEXEC_SSBRIDGE=$(ENABLE_SLEXEC_SSBRIDGE)
    endif
endif

CPP_REQ_DEFINES = $(CPP_REQ_DEFINES1)


ifeq ($(MODELREF_TARGET_TYPE),SIM)
	CPP_REQ_DEFINES += -DMDL_REF_SIM_TGT=1 
else
	CPP_REQ_DEFINES += -DMT=$(MULTITASKING)
endif

CPP_REQ_DEFINES += -DMODEL_HAS_DYNAMICALLY_LOADED_SFCNS=$(MODEL_HAS_DYNAMICALLY_LOADED_SFCNS)

CFLAGS    =$(CC_OPTS)  $(INCLUDES)
CPPFLAGS = $(CC_OPTS)  $(INCLUDES)

DEFINES = $(DEFINES_CUSTOM) $(CPP_REQ_DEFINES) $(DEFINES_OTHER)
CFLAGS = $(ANSI_OPTS) $(DBG_FLAG) $(CC_OPTS) $(DEFINES) $(INCLUDES)
CPPFLAGS = $(CPP_ANSI_OPTS) $(DBG_FLAG) $(CPP_OPTS) $(CC_OPTS) $(DEFINES) $(INCLUDES)

#-------------------------- Additional Libraries ------------------------------

#LIBS =
#|>START_PRECOMP_LIBRARIES<|
#LIBS += |>EXPAND_LIBRARY_NAME<|.a
#|>END_PRECOMP_LIBRARIES<|

#|>START_EXPAND_LIBRARIES<|
#LIBS += |>EXPAND_LIBRARY_LOCATION<|/|>EXPAND_LIBRARY_NAME<|.a
#|>END_EXPAND_LIBRARIES<|

#LIBS += $(S_FUNCTIONS_LIB) $(INSTRUMENT_LIBS)

SYSTEM_LIBS += -lm

LIBS =
|>START_PRECOMP_LIBRARIES<|
ifeq ($(OPT_OPTS),$(DEFAULT_OPT_OPTS))
ifeq ($(INTEGER_CODE),0)
ifeq ($(MODELREF_TARGET_TYPE),SIM)
LIBS += |>EXPAND_LIBRARY_LOCATION<|/|>EXPAND_LIBRARY_NAME<|_rtwsfcn.a
else
LIBS += |>EXPAND_LIBRARY_LOCATION<|/|>EXPAND_LIBRARY_NAME<|_ert.a
endif
else
LIBS += |>EXPAND_LIBRARY_LOCATION<|/|>EXPAND_LIBRARY_NAME<|_int_ert.a
endif
else
LIBS += |>EXPAND_LIBRARY_NAME<|.a
endif
|>END_PRECOMP_LIBRARIES<| |>START_EXPAND_LIBRARIES<|
LIBS += |>EXPAND_LIBRARY_NAME<|.a |>END_EXPAND_LIBRARIES<|
LIBS += $(S_FUNCTIONS_LIB) $(INSTRUMENT_LIBS)
#-------------------------------- Target application --------------------------------------
# Define the target file

ifeq ($(MODELREF_TARGET_TYPE), NONE)
    ifeq ($(SHRLIBTARGET), 1)
		-@echo "Shared Lib Targer: do nothing"
    endif
    ifeq ($(MAKEFILEBUILDER_TGT), 0)
		ifeq ($(STANDALONE_SUPPRESS_EXE), 1)
			# Build object code only for top level model (preliminary step for building
			# PIL application)		
			BUILD_MODE=pil_prebuild
			PRODUCT=ObjectModules			
			BUILD_PRODUCT_TYPE = object modules

			# BUILD_MODE= pil_prebuild
			# PRODUCT = $(MODELLIB)
			# BUILD_PRODUCT_TYPE = library		

		else
			# Building executable for real-time deployment
			BUILD_MODE=real_time
			# remove MODELLIB from linker
			# MODELLIB =
			PRODUCT = $(MODEL)$(PROGRAM_FILE_EXT)
			BUILD_PRODUCT_TYPE = executable
		endif
    else
		# Building executable for deployment as PIL application (non-real-time
		# simulation)
		BUILD_MODE= pil_application
		PRODUCT = $(MODEL)$(PROGRAM_FILE_EXT)
		BUILD_PRODUCT_TYPE = executable
    endif
else
	# Building a library for a referenced model
	BUILD_MODE = model_reference
	PRODUCT = $(MODELLIB)
	BUILD_PRODUCT_TYPE = library
endif


#----------------------------- Source Files ------------------------------------

# # add assembly source file from root folder, generated by Code Replacement Library and others
# #ASM_OPTIM_SRCS = 
# #|>START_EXPAND_INCLUDES<|
# #ASM_OPTIM_SRCS += $(wildcard |>EXPAND_DIR_NAME<|/*.s) |>END_EXPAND_INCLUDES<|
# 
# #ASM_OPTIM_SRCS = $(wildcard *.s)
# #    # for instrumented code
# #ASM_OPTIM_SRCS = $(wildcard ../*.s) 
# 
# SRCS = $(S_FUNCTIONS)
# #SRCS += $(ASM_OPTIM_SRCS)
# 
# ifeq ($(BUILD_MODE), pil_prebuild)
#   SRCS += $(MODULES) $(MODEL).$(TARGET_LANG_EXT) $(EXT_SRC)
# endif
# 
# ifeq ($(BUILD_MODE), pil_application)
#   SRCS += $(TARGET_SRCS)
#   PREBUILT_SRCS      = $(MODULES)
#   PREBUILT_OBJS      = $(addsuffix $(OBJ_EXT), $(basename $(PREBUILT_SRCS)))
# endif
# 
# ifeq ($(BUILD_MODE), real_time)
#   SRCS += $(MODULES) $(MODEL).$(TARGET_LANG_EXT) $(EXT_SRC)
#   SRCS += $(TARGET_SRCS)
# endif
# 
# ifeq ($(BUILD_MODE), model_reference)
#   SRCS += $(MODULES)
# endif
# 
# USER_SRCS =
# USER_OBJS       = $(addsuffix $(OBJ_EXT), $(basename $(USER_SRCS)))
# LOCAL_USER_OBJS = $(notdir $(USER_OBJS))
# 
# OBJS      = $(addsuffix $(OBJ_EXT), $(basename $(SRCS))) $(USER_OBJS)
# LINK_OBJS = $(addsuffix $(OBJ_EXT), $(basename $(SRCS))) $(LOCAL_USER_OBJS) $(PREBUILT_OBJS)
# 
# LIBS += $(S_FUNCTIONS_LIB)
# 
# #wildcard does not support slash, must be replaced with backslash at least for SHARED_SRC
SHARED_SRC := $(subst \,/,$(SHARED_SRC))
# #SHARED_SRC_DIR := $(subst \,/,$(SHARED_SRC_DIR))
# #SHARED_BIN_DIR := $(subst \,/,$(SHARED_BIN_DIR))
# #SHARED_LIB := $(subst \,/,$(SHARED_LIB))
# 

# SHARED_SRC source file required with R2012a for PIL
SHARED_SRC := $(wildcard $(SHARED_SRC))
SHARED_OBJS = $(addsuffix $(OBJ_EXT), $(basename $(SHARED_SRC)))

ADD_SRCS = $(SHARED_SRC)

SRCS = $(ADD_SRCS) $(MODULES) $(EXT_SRC)

ifeq ($(BUILD_MODE), real_time)
   SRCS += $(MODEL).$(TARGET_LANG_EXT) 
endif

USER_SRCS =

USER_OBJS       = $(addsuffix .o, $(basename $(USER_SRCS)))
LOCAL_USER_OBJS = $(notdir $(USER_OBJS))

OBJS      = $(addsuffix .o, $(basename $(SRCS))) $(USER_OBJS)
LINK_OBJS = $(addsuffix .o, $(basename $(SRCS))) $(LOCAL_USER_OBJS)

ADDITIONAL_LDFLAGS += $(ARCH_SPECIFIC_LDFLAGS)

#------------------------------- Libraries -------------------------------------

|>START_EXPAND_LIBRARIES<|MODULES_|>EXPAND_LIBRARY_NAME<| = \
|>START_EXPAND_MODULES<|    |>EXPAND_MODULE_NAME<|.o \
|>END_EXPAND_MODULES<|

|>EXPAND_LIBRARY_NAME<|.a : $(MAKEFILE) rtw_proj.tmw $(MODULES_|>EXPAND_LIBRARY_NAME<|)
	-@echo "+++ Creating $@ "
	$(AR) rs $@ $(MODULES_|>EXPAND_LIBRARY_NAME<|)
	-@echo "+++ $@ Created "

|>END_EXPAND_LIBRARIES<|

|>START_PRECOMP_LIBRARIES<|MODULES_|>EXPAND_LIBRARY_NAME<| = \
|>START_EXPAND_MODULES<|    |>EXPAND_MODULE_NAME<|.o \
|>END_EXPAND_MODULES<|

|>EXPAND_LIBRARY_NAME<|.a : $(MAKEFILE) rtw_proj.tmw $(MODULES_|>EXPAND_LIBRARY_NAME<|)
	-@echo "+++ Creating $@ "
	$(AR) rs $@ $(MODULES_|>EXPAND_LIBRARY_NAME<|)
	-@echo "+++ $@ Created "

|>END_PRECOMP_LIBRARIES<|

#-------------- Default target -----------
TARGETS = $(PRODUCT)

all: $(TARGETS)

# Need a rule to generate the build success string if product was already up to date
.PHONY : all
all : $(PRODUCT)
	-@echo "### Created $(PRODUCT) successfully (or it was already up to date)"





##-------------------------- Support for building modules ----------------------
ifeq ($(BUILD_MODE), pil_prebuild)
.PHONY: $(PRODUCT)
$(PRODUCT) : $(OBJS) $(LIBS)
	-@echo "### BUILD_MODE $(BUILD_MODE)"
	-@echo "+++ Created object modules: $@"
endif


ifeq ($(BUILD_MODE), model_reference)
$(PRODUCT) : $(OBJS) 	
	-@echo "### BUILD_MODE $(BUILD_MODE)"
	@$(DEL) $(MODELLIB)
	-@echo "+++ Creating library ..."
	$(AR) $(MODELLIB) $(LINK_OBJS)
	-@echo "$(BUILD_SUCCESS) $(BUILD_PRODUCT_TYPE): $@"
endif


ifeq ($(BUILD_MODE), pil_application)
$(PRODUCT) : $(OBJS) $(LIBS) $(MODELLIB) $(MODELREF_LINK_LIBS)
	-@echo "### BUILD_MODE $(BUILD_MODE)"
	-@echo "LDLIBPIC $(LDLIBPIC)"
	-@echo "LINK_OBJS $(LINK_OBJS)"
	-@echo "MODELLIB $(MODELLIB)"
	-@echo "MODELREF_LINK_LIBS_GROUP $(MODELREF_LINK_LIBS_GROUP)"
	-@echo "LIBS $(LIBS)"
	-@echo "SYSTEM_LIBS $(SYSTEM_LIBS)"	
	$(LD) $(MCPU) $(LDLIBPIC) $(LINK_OBJS) $(MODELLIB) $(MODELREF_LINK_LIBS_GROUP) $(LIBS) $(SYSTEM_LIBS) -o $(MODEL)$(PROGRAM_FILE_EXT) $(T_LINKER_SCRIPT),$(LDFLAGS)
	-@echo "$(BUILD_SUCCESS) $(BUILD_PRODUCT_TYPE): $@  [$(PIC_REF)]"
    ifeq ($(ProduceHexOutput),1)
		$(BIN2HEX)  $(PRODUCT)
		-@echo "+++ Converted $(MODEL)$(PROGRAM_FILE_EXT) to $(MODEL).hex"
    endif
    ifeq ($(AssemblyListing),1)
		$(OBJDUMP)  -S -f -Msymbolic $(PRODUCT) > $(MODEL).lst
		-@echo "+++ Created Assembly list file $(MODEL).lst"
    endif
endif

ifeq ($(BUILD_MODE), real_time)
#$(MODEL)$(PROGRAM_FILE_EXT) : $(OBJS) $(MODELREF_LINK_LIBS) $(SHARED_LIB) $(LIBS)
$(PRODUCT) : $(OBJS) $(LIBS) $(MODELREF_LINK_LIBS)
	-@echo "### BUILD_MODE $(BUILD_MODE)"
	$(LD) $(MCPU) $(LDLIBPIC) $(LINK_OBJS) $(MODELREF_LINK_LIBS_GROUP) $(LIBS) $(SYSTEM_LIBS) -o $(MODEL)$(PROGRAM_FILE_EXT) $(T_LINKER_SCRIPT),$(LDFLAGS)	
	-@echo "$(BUILD_SUCCESS) $(BUILD_PRODUCT_TYPE): $@"
    ifeq ($(ProduceHexOutput),1)
		$(BIN2HEX)  $(PRODUCT)
		-@echo "+++ Converted $(PRODUCT) to $(MODEL).hex"
    endif
    ifeq ($(AssemblyListing),1)
		$(OBJDUMP)  -S -f -Msymbolic $(PRODUCT) > $(MODEL).lst
		-@echo "+++ Created Assembly list file $(MODEL).lst"
    endif
endif


#-------------------------- Clean up ----------------------

ifeq ($(ProduceHexOutput),0)
ifeq (,$(wildcard $(MODEL).hex))	# if file exist
else
	$(DEL) $(MODEL).hex
endif
endif

ifeq ($(AssemblyListing),0)
ifeq (,$(wildcard $(MODEL).lst))		# if file exist
else
	$(DEL) $(MODEL).lst
endif
endif

#-------------------------- Support for building modules ----------------------

mem_mgr.o : $(MATLAB_ROOT)/rtw/c/src/ext_mode/common/mem_mgr.c
	$(CC) -c -fno-strict-aliasing $(CFLAGS) $< $(CCOUTPUTFLAG) $@

%$(OBJ_EXT) : $(RELATIVE_PATH_TO_ANCHOR)/%.c
	-@echo Compiling: $<
	$(CC) -c $(CFLAGS) $< $(CCOUTPUTFLAG) $@

%$(OBJ_EXT) : $(RELATIVE_PATH_TO_ANCHOR)/%.cpp
	-@echo Compiling: $<
	$(CC) -c $(CPPFLAGS) $< $(CCOUTPUTFLAG) $@

%$(OBJ_EXT) : $(RELATIVE_PATH_TO_ANCHOR)/%.s
	-@echo Compiling: $<
	$(CC) -c -mcpu=$(PIC_REF) $< -Wa,-g $(CCOUTPUTFLAG) $@

%$(OBJ_EXT) : %.c
	-@echo Compiling: $<
	$(CC) -c $(CFLAGS) $< $(CCOUTPUTFLAG) $@

%$(OBJ_EXT) : %.cpp
	-@echo Compiling: $<
	$(CC) -c $(CPPFLAGS) $< $(CCOUTPUTFLAG) $@

%$(OBJ_EXT) : %.s
	-@echo Compiling: $<
	$(CC) -c -mcpu=$(PIC_REF) $< -Wa,-g $(CCOUTPUTFLAG) $@

# required ? (for PIL with some matlab releases)
%$(OBJ_EXT) : ../%.c
	-@echo Compiling: $<
	$(CC) -c $(CFLAGS) $< $(CCOUTPUTFLAG) $@

|>START_EXPAND_RULES<|%$(OBJ_EXT) : |>EXPAND_DIR_NAME<|/%.c
	-@echo Compiling: $<
	$(CC) -c $(CFLAGS) $< $(CCOUTPUTFLAG) $@

|>END_EXPAND_RULES<|

|>START_EXPAND_RULES<|%$(OBJ_EXT) : |>EXPAND_DIR_NAME<|/%.cpp
	-@echo Compiling: $<
	$(CC) -c $(CPPFLAGS) $< $(CCOUTPUTFLAG) $@

|>END_EXPAND_RULES<|

|>START_EXPAND_RULES<|%$(OBJ_EXT) : |>EXPAND_DIR_NAME<|/%.s
	-@echo Compiling: $<
	$(CC) -c -mcpu=$(PIC_REF) $< -Wa,-g $(CCOUTPUTFLAG) $@

|>END_EXPAND_RULES<|


#----------------------------- Dependencies ------------------------------------

$(OBJS) : $(MAKEFILE) rtw_proj.tmw

#$(SHARED_LIB) : $(SHARED_OBJS)
#	-@echo ### Creating $@
#	$(AR) $@ $(SHARED_OBJS)
#	-@echo ### $@ Created
